.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OP::Parse::BL 3pm"
.TH OP::Parse::BL 3pm "2012-09-01" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::BooleanLogic \- parser of boolean expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Parse::BL;
\&    use Data::Dumper;
\&
\&    my $parser = Parse::BooleanLogic\->new( operators => [\*(Aq\*(Aq, \*(AqOR\*(Aq] );
\&    my $tree = $parser\->as_array( \*(Aqlabel:parser subject:"boolean logic"\*(Aq );
\&    print Dumper($tree);
\&
\&    $parser = new Parse::BooleanLogic;
\&    $tree = $parser\->as_array( \*(Aqx = 10\*(Aq );
\&    print Dumper($tree);
\&
\&    $tree = $parser\->as_array( \*(Aqx = 10 OR (x > 20 AND x < 30)\*(Aq );
\&    print Dumper($tree);
\&
\&    # custom parsing using callbacks
\&    $parser\->parse(
\&        string   => \*(Aqx = 10 OR (x > 20 AND x < 30)\*(Aq,
\&        callback => {
\&            open_paren   => sub { ... },
\&            operator     => sub { ... },
\&            operand      => sub { ... },
\&            close_paren  => sub { ... },
\&            error        => sub { ... },
\&        },
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is quite fast parser for boolean expressions. Originally it's been writen for
Request Tracker to parse \s-1SQL\s0 like expressions and it's still capable, but
it can be used to parse other boolean logic sentences with OPERANDs joined using
binary OPERATORs and grouped and nested using parentheses (\s-1OPEN_PAREN\s0 and \s-1CLOSE_PAREN\s0).
.PP
Operand is not qualified strictly what makes parser flexible enough to parse different
things, for example:
.PP
.Vb 2
\&    # SQL like expressions
\&    (task.status = "new" OR task.status = "open") AND task.owner_id = 123
\&
\&    # Google like search syntax used in Gmail and other service
\&    subject:"some text" (from:me OR to:me) label:todo !label:done
\&
\&    # Binary boolean logic expressions
\&    (a | b) & (c | d)
.Ve
.PP
You can change literals used for boolean operators and parens. Read more
about this in description of constructor's arguments.
.PP
As you can see quoted strings are supported. Read about that below in
\&\*(L"Quoting and dequoting\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "Building parser"
.IX Subsection "Building parser"
\fInew\fR
.IX Subsection "new"
.PP
A constructor, takes the following named arguments:
.IP "operators, default is ['\s-1AND\s0' '\s-1OR\s0']" 4
.IX Item "operators, default is ['AND' 'OR']"
Pair of literal strings representing boolean operators \s-1AND\s0 and \s-1OR\s0,
pass it as array reference. For example:
.Sp
.Vb 2
\&    # from t/custom_ops.t
\&    my $parser = Parse::BooleanLogic\->new( operators => [qw(& |)] );
\&
\&    # from t/custom_googlish.t
\&    my $parser = Parse::BooleanLogic\->new( operators => [\*(Aq\*(Aq, \*(AqOR\*(Aq] );
\&$self\->{\*(Aqparens\*(Aq}
\&It\*(Aqs ok to have any operators and even empty.
.Ve
.IP "parens, default is ['(', ')']" 4
.IX Item "parens, default is ['(', ')']"
Pair of literal strings representing parentheses, for example it's
possible to use curly braces:
.Sp
.Vb 2
\&    # from t/custom_parens.t
\&    my $parser = Parse::BooleanLogic\->new( parens => [qw({ })] );
.Ve
.Sp
No matter which pair is used parens must be balanced in expression.
.PP
This constructor compiles several heavy weight regular expressions
so it's better avoid building object each time right before parsing,
but instead use global or cached one.
.PP
\fIinit\fR
.IX Subsection "init"
.PP
An initializer, called from the constructor. Compiles regular expressions
and do other things with constructor's arguments. Returns this object back.
.SS "Parsing expressions"
.IX Subsection "Parsing expressions"
\fIas_array \f(CI$string\fI [ \f(CI%options\fI ]\fR
.IX Subsection "as_array $string [ %options ]"
.PP
Takes a string and parses it into perl structure, where parentheses represented using
array references, operands are hash references with one key/value pair: operand,
when binary operators are simple scalars. So string \f(CW\*(C`x = 10 OR (x \*(C'\fR 20 \s-1AND\s0 x < 30)>
is parsed into the following structure:
.PP
.Vb 9
\&    [
\&        { operand => \*(Aqx = 10\*(Aq },
\&        \*(AqOR\*(Aq,
\&        [
\&            { operand => \*(Aqx > 20\*(Aq },
\&            \*(AqAND\*(Aq,
\&            { operand => \*(Aqx < 30\*(Aq },
\&        ]
\&    ]
.Ve
.PP
Aditional options:
.IP "operand_cb \- custom operands handler, for example:" 4
.IX Item "operand_cb - custom operands handler, for example:"
.Vb 11
\&    my $tree = $parser\->as_array(
\&        "some s                                          tring",
\&        operand_cb => sub {
\&            my $op = shift;
\&            if ( $op =~ m/^(!?)(label|subject|from|to):(.*)/ ) {
\&                ...
\&            } else {
\&                die "You have an error in your query, in \*(Aq$op\*(Aq";
\&            }
\&        },
\&    );
.Ve
.IP "error_cb \- custom errors handler" 4
.IX Item "error_cb - custom errors handler"
.Vb 7
\&    my $tree = $parser\->as_array(
\&        "some string",
\&        error_cb => sub {
\&            my $msg = shift;
\&            MyParseException\->throw($msg);
\&        },
\&    );
.Ve
.PP
\fIparse\fR
.IX Subsection "parse"
.PP
Takes named arguments: string and callback. Where the first one is scalar with
expression, the latter is a reference to hash with callbacks: open_paren, operator
operand, close_paren and error. Callback for errors is optional and parser dies if
it's omitted. Each callback is called when parser finds corresponding element in the
string. In all cases the current match is passed as argument into the callback.
.PP
Here is simple example based on \*(L"as_array\*(R" method:
.PP
.Vb 3
\&    # result tree and the current group
\&    my ($tree, $node);
\&    $tree = $node = [];
\&
\&    # stack with nested groups, outer most in the bottom, inner on the top
\&    my @pnodes = ();
\&
\&    my %callback;
\&    # on open_paren put the current group on top of the stack,
\&    # create new empty group and at the same time put it into
\&    # the end of previous one
\&    $callback{\*(Aqopen_paren\*(Aq} = sub {
\&        push @pnodes, $node;
\&        push @{ $pnodes[\-1] }, $node = []
\&    };
\&
\&    # on close_paren just switch to previous group by taking it
\&    # from the top of the stack
\&    $callback{\*(Aqclose_paren\*(Aq} = sub { $node = pop @pnodes };
\&
\&    # push binary operators as is and operands as hash references
\&    $callback{\*(Aqoperator\*(Aq} = sub { push @$node, $_[0] };
\&    $callback{\*(Aqoperand\*(Aq}  = sub { push @$node, { operand => $_[0] } };
\&
\&    # run parser
\&    $parser\->parse( string => $string, callback => \e%callback );
\&
\&    return $tree;
.Ve
.PP
Using this method you can build other representations of an expression.
.SS "Quoting and dequoting"
.IX Subsection "Quoting and dequoting"
This module supports quoting with single quote ' and double ",
literal quotes escaped with \e.
.PP
from Regexp::Common::delimited with ' and " as delimiters.
.PP
\fIq, qq, fq and dq\fR
.IX Subsection "q, qq, fq and dq"
.PP
Four methods to work with quotes:
.IP "q \- quote a string with single quote character." 4
.IX Item "q - quote a string with single quote character."
.PD 0
.IP "qq \- quote a string with double quote character." 4
.IX Item "qq - quote a string with double quote character."
.IP "fq \- quote with single if string has no single quote character, otherwisee use double quotes." 4
.IX Item "fq - quote with single if string has no single quote character, otherwisee use double quotes."
.IP "dq \- delete either single or double quotes from a string if it's quoted." 4
.IX Item "dq - delete either single or double quotes from a string if it's quoted."
.PD
.PP
All four works either in place or return result, for example:
.PP
.Vb 1
\&    $parser\->q($str); # inplace
\&
\&    my $q = $parser\->q($s); # $s is untouched
.Ve
.SS "Tree evaluation and modification"
.IX Subsection "Tree evaluation and modification"
Several functions taking a tree of boolean expressions as returned by
as_array method and evaluating or changing it using a callback.
.PP
\fIwalk \f(CI$tree\fI \f(CI$callbacks\fI \f(CI@rest\fI\fR
.IX Subsection "walk $tree $callbacks @rest"
.PP
A simple method for walking a \f(CW$tree\fR using four callbacks: open_paren,
close_paren, operand and operator. All callbacks are optional.
.PP
Example:
.PP
.Vb 9
\&    $parser\->walk(
\&        $tree,
\&        {
\&            open_paren => sub { ... },
\&            close_paren => sub { ... },
\&            ...
\&        },
\&        $some_context_argument, $another, ...
\&    );
.Ve
.PP
Any additional arguments (@rest) are passed all the time into callbacks.
.PP
\fIfilter \f(CI$tree\fI \f(CI$callback\fI \f(CI@rest\fI\fR
.IX Subsection "filter $tree $callback @rest"
.PP
Filters a \f(CW$tree\fR using provided \f(CW$callback\fR. The callback is called for each operand
in the tree and operand is left when it returns true value.
.PP
Any additional arguments (@rest) are passed all the time into the callback.
See example below.
.PP
Boolean operators (\s-1AND/OR\s0) are skipped according to parens and left first rule,
for example:
.PP
.Vb 6
\&    X OR Y AND Z \-> X AND Z
\&    X OR (Y AND Z) \-> X OR Z
\&    X OR Y AND Z \-> Y AND Z
\&    X OR (Y AND Z) \-> Y AND Z
\&    X OR Y AND Z \-> X OR Y
\&    X OR (Y AND Z) \-> X OR Y
.Ve
.PP
Returns new sub-tree. Original tree is not changed, but operands in new tree
still refer to the same hashes in the original.
.PP
Example:
.PP
.Vb 6
\&    my $filter = sub {
\&        my ($condition, $some) = @_;
\&        return 1 if $condition\->{\*(Aqoperand\*(Aq} eq $some;
\&        return 0;
\&    };
\&    my $new_tree = $parser\->filter( $tree, $filter, $some );
.Ve
.PP
See also solve
.PP
\fIsolve \f(CI$tree\fI \f(CI$callback\fI \f(CI@rest\fI\fR
.IX Subsection "solve $tree $callback @rest"
.PP
Solves a boolean expression represented by a \f(CW$tree\fR using provided \f(CW$callback\fR.
The callback is called for operands and should return a boolean value
(0 or 1 will work).
.PP
Any additional arguments (@rest) are passed all the time into the callback.
See example below.
.PP
Functions matrixes:
.PP
.Vb 5
\&    A B AND OR
\&    0 0 0   0
\&    0 1 0   1
\&    1 0 0   1
\&    1 1 1   1
.Ve
.PP
Whole branches of the tree can be skipped when result is obvious, for example:
.PP
.Vb 2
\&    1 OR  (...)
\&    0 AND (...)
.Ve
.PP
Returns result of the expression.
.PP
Example:
.PP
.Vb 6
\&    my $solver = sub {
\&        my ($condition, $some) = @_;
\&        return 1 if $condition\->{\*(Aqoperand\*(Aq} eq $some;
\&        return 0;
\&    };
\&    my $result = $parser\->solve( $tree, $filter, $some );
.Ve
.PP
See also filter.
.PP
\fIfsolve \f(CI$tree\fI \f(CI$callback\fI \f(CI@rest\fI\fR
.IX Subsection "fsolve $tree $callback @rest"
.PP
Does in filter+solve in one go. Callback can return undef to filter out an operand,
and a defined boolean value to be used in solve.
.PP
Any additional arguments (@rest) are passed all the time into the callback.
.PP
Returns boolean result of the equation or undef if all operands have been filtered.
.PP
See also filter and solve.
.PP
\fIcollect \f(CI$tree\fI\fR
.IX Subsection "collect $tree"
.PP
Collapse the tree into a string. Returns a string.
.PP
\fIpartial_solve \f(CI$tree\fI \f(CI$callback\fI \f(CI@rest\fI\fR
.IX Subsection "partial_solve $tree $callback @rest"
.PP
Partially solve a \f(CW$tree\fR. Callback can return undef or a new expression
and a defined boolean value to be used in solve.
.PP
Returns either result or array reference with expression.
.PP
Any additional arguments (@rest) are passed all the time into the callback.
.SH "ALTERNATIVES"
.IX Header "ALTERNATIVES"
There are some alternative implementations available on the \s-1CPAN\s0.
.IP "Search::QueryParser \- similar purpose with several differences." 4
.IX Item "Search::QueryParser - similar purpose with several differences."
.PD 0
.IP "Another?" 4
.IX Item "Another?"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
The authors of the initial package Parse::BooleanLogic are:
.PP
Ruslan Zakirov <ruz@cpan.org>, Robert Spier <rspier@pobox.com>
.PP
Parse::BL was forked from Parse::BooleanLogic by op226, op226@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
