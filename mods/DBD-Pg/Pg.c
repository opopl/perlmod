/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of Pg.xs. Do not edit this file, edit Pg.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Pg.xs"
/*

  Copyright (c) 2000-2012 Greg Sabino Mullane and others: see the Changes file
  Portions Copyright (c) 1997-2000 Edmund Mergl
  Portions Copyright (c) 1994-1997 Tim Bunce

  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the Perl README file.

*/


#include "Pg.h"

#ifdef _MSC_VER
#define strncasecmp(a,b,c) _strnicmp((a),(b),(c))
#endif

#line 29 "Pg.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 171 "Pg.c"

XS_EUPXS(XS_DBD__Pg_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg_constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "name=Nullch");
    {
	char *	name;
	I32	RETVAL;
	dXSTARG;

	if (items < 1)
	    name = Nullch;
	else {
	    name = (char *)SvPV_nolen(ST(0))
;
	}
#line 169 "Pg.xs"
		if (0==ix) {
			if (!name) {
				name = GvNAME(CvGV(cv));
			}
			croak("Unknown DBD::Pg constant '%s'", name);
		}
		else {
			RETVAL = ix;
		}
#line 201 "Pg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE:  Including 'Pg.xsi' from 'Pg.xs' */

#include "Driver_xst.h"

XS_EUPXS(XS_DBD__Pg__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__dr_dbixs_revision)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 36 "./Pg.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 222 "Pg.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_DBD__Pg__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__dr_discon_all_)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0)
;
#line 48 "./Pg.xsi"
    D_imp_drh(drh);
    PERL_UNUSED_VAR(ix);
    ST(0) = dbd_discon_all(drh, imp_drh) ? &PL_sv_yes : &PL_sv_no;
#line 246 "Pg.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_DBD__Pg__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__dr_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 62 "./Pg.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 288 "Pg.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__Pg__db__login); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db__login)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	dbname = ST(1)
;
	SV *	username = ST(2)
;
	SV *	password = ST(3)
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 92 "./Pg.xsi"
    {
    D_imp_dbh(dbh);
#if !defined(dbd_db_login6_sv)
    STRLEN lna;
    char *u = (SvOK(username)) ? SvPV(username,lna) : (char*)"";
    char *p = (SvOK(password)) ? SvPV(password,lna) : (char*)"";
#endif
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &PL_sv_yes : &PL_sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 335 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_selectall_arrayref)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 112 "./Pg.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *tmp_sv;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 354 "Pg.c"
#line 119 "./Pg.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::Pg::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    tmp_sv = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
    SPAGAIN;
    ST(0) = tmp_sv;
#line 401 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_selectrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 171 "./Pg.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 421 "Pg.c"
#line 176 "./Pg.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 477 "Pg.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_DBD__Pg__db_dontdo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_dontdo)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    {
	SV *	dbh = ST(0)
;
	char *	statement = (char *)SvPV_nolen(ST(1))
;
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2)
;
	}
#line 240 "./Pg.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 519 "Pg.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_DBD__Pg__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog, schema, table, field, attr=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	catalog = ST(1)
;
	SV *	schema = ST(2)
;
	SV *	table = ST(3)
;
	SV *	field = ST(4)
;
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 267 "./Pg.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 559 "Pg.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__Pg__db_commit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_commit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 279 "./Pg.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 580 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_rollback)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 289 "./Pg.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 600 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 299 "./Pg.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !PL_dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? (char*)"" : (char*)"s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 631 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 322 "./Pg.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 658 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_FETCH)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
#line 336 "./Pg.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 681 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
#line 347 "./Pg.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !PL_dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* wants ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!PL_dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 744 "Pg.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_DBD__Pg__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_take_imp_data)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0)
;
#line 400 "./Pg.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::Pg::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 778 "Pg.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_DBD__Pg__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 424 "./Pg.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 820 "Pg.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__Pg__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st__prepare)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2)
;
	}
#line 453 "./Pg.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 857 "Pg.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_DBD__Pg__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 470 "./Pg.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 878 "Pg.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_DBD__Pg__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_bind_col)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	col = ST(1)
;
	SV *	ref = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 485 "./Pg.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &PL_sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &PL_sv_yes : &PL_sv_no;
                break;
    default:    ST(0) = &PL_sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 938 "Pg.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS_EUPXS(XS_DBD__Pg__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_bind_param)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 523 "./Pg.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 987 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_bind_param_inout)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value_ref = ST(2)
;
	IV	maxlen = (IV)SvIV(ST(3))
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 553 "./Pg.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 1042 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_execute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_execute)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0)
;
#line 584 "./Pg.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1076 "Pg.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_DBD__Pg__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_execute_for_fetch)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	fetch_tuple_sub = ST(1)
;
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2)
;
	}
#line 612 "./Pg.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 1109 "Pg.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__Pg__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_fetchrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 627 "./Pg.xsi"
    D_imp_sth(sth);
    AV *av;
    PERL_UNUSED_VAR(ix);
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1132 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_fetchrow_array)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 640 "./Pg.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        PERL_UNUSED_VAR(ix);
    }
#line 1163 "Pg.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__Pg__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_fetchall_arrayref)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0)
;
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1)
;
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2)
;
	}
#line 660 "./Pg.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::Pg::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        SV *tmp = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
        SPAGAIN;
        ST(0) = tmp;
    }
#line 1206 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 676 "./Pg.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#endif
#line 1239 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_blob_read)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0)
;
	int	field = (int)SvIV(ST(1))
;
	long	offset = (long)SvIV(ST(2))
;
	long	len = (long)SvIV(ST(3))
;
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4)
;
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5))
;
	}
#line 704 "./Pg.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1285 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 720 "./Pg.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 1312 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_FETCH_attrib)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
#line 737 "./Pg.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    PERL_UNUSED_VAR(ix);
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1338 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 750 "./Pg.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !PL_dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) {  /* wants ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1387 "Pg.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Pg.xs' from 'Pg.xsi' */


XS_EUPXS(XS_DBD__Pg__db_quote); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_quote)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, to_quote_sv, type_sv=Nullsv");
    {
	SV*	dbh = ST(0)
;
	SV*	to_quote_sv = ST(1)
;
	SV*	type_sv;
	SV *	RETVAL;

	if (items < 3)
	    type_sv = Nullsv;
	else {
	    type_sv = ST(2)
;
	}
#line 197 "Pg.xs"
	{
		D_imp_dbh(dbh);

		SvGETMAGIC(to_quote_sv);

		/* Reject references other than overloaded objects (presumed
		  stringifiable) and arrays (will make a PostgreSQL array). */
		if (SvROK(to_quote_sv) && !SvAMAGIC(to_quote_sv)) {
			if (SvTYPE(SvRV(to_quote_sv)) != SVt_PVAV)
				croak("Cannot quote a reference");
			to_quote_sv = pg_stringify_array(to_quote_sv, ",", imp_dbh->pg_server_version);
		}

		/* Null is always returned as "NULL", so we can ignore any type given */
		if (!SvOK(to_quote_sv)) {
			RETVAL = newSVpvn("NULL", 4);
		}
		else {
			sql_type_info_t *type_info;
			char *quoted;
			const char *to_quote;
			STRLEN retlen=0;
			STRLEN len=0;

			/* If no valid type is given, we default to unknown */
			if (!type_sv || !SvOK(type_sv)) {
				type_info = pg_type_data(PG_UNKNOWN);
			}
			else {
				if SvMAGICAL(type_sv)
					(void)mg_get(type_sv);
				if (SvNIOK(type_sv)) {
					type_info = sql_type_data(SvIV(type_sv));
				}
				else {
					SV **svp;
					if ((svp = hv_fetch((HV*)SvRV(type_sv),"pg_type", 7, 0)) != NULL) {
						type_info = pg_type_data(SvIV(*svp));
					}
					else if ((svp = hv_fetch((HV*)SvRV(type_sv),"type", 4, 0)) != NULL) {
						type_info = sql_type_data(SvIV(*svp));
					}
					else {
						type_info = NULL;
					}
				}
				if (!type_info) {
					warn("Unknown type %" IVdf ", defaulting to UNKNOWN",SvIV(type_sv));
					type_info = pg_type_data(PG_UNKNOWN);
				}
			}

			/* At this point, type_info points to a valid struct, one way or another */

			if (SvMAGICAL(to_quote_sv))
				(void)mg_get(to_quote_sv);

			to_quote = SvPV(to_quote_sv, len);
			/* Need good debugging here */
			quoted = type_info->quote(to_quote, len, &retlen, imp_dbh->pg_server_version >= 80100 ? 1 : 0);
			RETVAL = newSVpvn(quoted, retlen);
			if (SvUTF8(to_quote_sv)) /* What about overloaded objects? */
				SvUTF8_on(RETVAL);
			Safefree (quoted);
		}
	}
#line 1484 "Pg.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_state); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_state)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 276 "Pg.xs"
	D_imp_dbh(dbh);
	ST(0) = strEQ(imp_dbh->sqlstate,"00000") ? &PL_sv_no : newSVpv(imp_dbh->sqlstate, 5);
#line 1504 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_do)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "dbh, statement, attr=Nullsv, ...");
    {
	SV *	dbh = ST(0)
;
	char *	statement = (char *)SvPV_nolen(ST(1))
;
	SV *	attr;

	if (items < 3)
	    attr = Nullsv;
	else {
	    attr = ST(2)
;
	}
#line 286 "Pg.xs"
	{
		int retval;
		int asyncflag = 0;

		if (statement[0] == '\0') { /* Corner case */
			XST_mUNDEF(0);
			return;
		}

		if (attr && SvROK(attr) && SvTYPE(SvRV(attr)) == SVt_PVHV) {
			SV **svp;
			if ((svp = hv_fetch((HV*)SvRV(attr),"pg_async", 8, 0)) != NULL) {
			   asyncflag = (int)SvIV(*svp);
			}
		}
		if (items < 4) { /* No bind arguments */
			/* Quick run via PQexec */
			retval = pg_quickexec(dbh, statement, asyncflag);
		}
		else { /* We've got bind arguments, so we do the whole prepare/execute route */
			imp_sth_t *imp_sth;
			SV * const sth = dbixst_bounce_method("prepare", 3);
			if (!SvROK(sth))
				XSRETURN_UNDEF;
			imp_sth = (imp_sth_t*)(DBIh_COM(sth));
			if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2))
				XSRETURN_UNDEF;
			imp_sth->onetime = 1; /* Tells dbdimp.c not to bother preparing this */
			imp_sth->async_flag = asyncflag;
			retval = dbd_st_execute(sth, imp_sth);
		}

		if (retval == 0)
			XST_mPV(0, "0E0");
		else if (retval < -1)
			XST_mUNDEF(0);
		else
			XST_mIV(0, retval);
}
#line 1569 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db__ping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db__ping)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 331 "Pg.xs"
		ST(0) = sv_2mortal(newSViv(dbd_db_ping(dbh)));
#line 1586 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_getfd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_getfd)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 338 "Pg.xs"
		int ret;
		D_imp_dbh(dbh);
		ret = pg_db_getfd(imp_dbh);
		ST(0) = sv_2mortal( newSViv( ret ) );
#line 1606 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_endcopy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_endcopy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 348 "Pg.xs"
		ST(0) = (pg_db_endcopy(dbh)!=0) ? &PL_sv_no : &PL_sv_yes;
#line 1623 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_notifies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_notifies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 355 "Pg.xs"
		D_imp_dbh(dbh);
		ST(0) = pg_db_pg_notifies(dbh, imp_dbh);
#line 1641 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_savepoint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_savepoint)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, name");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 364 "Pg.xs"
		D_imp_dbh(dbh);
		if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
			warn("savepoint ineffective with AutoCommit enabled");
		ST(0) = (pg_db_savepoint(dbh, imp_dbh, name)!=0) ? &PL_sv_yes : &PL_sv_no;
#line 1663 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_rollback_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_rollback_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, name");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 375 "Pg.xs"
		D_imp_dbh(dbh);
		if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
			warn("rollback_to ineffective with AutoCommit enabled");
		ST(0) = (pg_db_rollback_to(dbh, imp_dbh, name)!=0) ? &PL_sv_yes : &PL_sv_no;
#line 1685 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_release); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_release)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, name");
    {
	SV *	dbh = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 386 "Pg.xs"
		D_imp_dbh(dbh);
		if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
			warn("release ineffective with AutoCommit enabled");
		ST(0) = (pg_db_release(dbh, imp_dbh, name)!=0) ? &PL_sv_yes : &PL_sv_no;
#line 1707 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_creat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_creat)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, mode");
    {
	SV *	dbh = ST(0)
;
	int	mode = (int)SvIV(ST(1))
;
#line 396 "Pg.xs"
		const unsigned int ret = pg_db_lo_creat(dbh, mode);
		ST(0) = (ret > 0) ? sv_2mortal(newSVuv(ret)) : &PL_sv_undef;
#line 1727 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_open)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, lobjId, mode");
    {
	SV *	dbh = ST(0)
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(1))
;
	int	mode = (int)SvIV(ST(2))
;
#line 405 "Pg.xs"
		const int ret = pg_db_lo_open(dbh, lobjId, mode);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 1749 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_write)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, fd, buf, len");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
	char *	buf = (char *)SvPV_nolen(ST(2))
;
	size_t	len = (size_t)SvUV(ST(3))
;
#line 416 "Pg.xs"
		const int ret = pg_db_lo_write(dbh, fd, buf, len);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 1773 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_read)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, fd, buf, len");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
	char *	buf = (char *)SvPV_nolen(ST(2))
;
	size_t	len = (size_t)SvUV(ST(3))
;
#line 427 "Pg.xs"
		SV * const bufsv = SvROK(ST(2)) ? SvRV(ST(2)) : ST(2);
		int ret;
#line 1797 "Pg.c"
#line 430 "Pg.xs"
		sv_setpvn(bufsv,"",0); /* Make sure we can grow it safely */
		buf = SvGROW(bufsv, len + 1);
		ret = pg_db_lo_read(dbh, fd, buf, len);
		if (ret > 0) {
			SvCUR_set(bufsv, ret);
			*SvEND(bufsv) = '\0';
			sv_setpvn(ST(2), buf, (unsigned)ret);
			SvSETMAGIC(ST(2));
		}
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 1809 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_lseek); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_lseek)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, fd, offset, whence");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
	int	offset = (int)SvIV(ST(2))
;
	int	whence = (int)SvIV(ST(3))
;
#line 449 "Pg.xs"
		const int ret = pg_db_lo_lseek(dbh, fd, offset, whence);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 1833 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_tell); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_tell)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, fd");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
#line 458 "Pg.xs"
		const int ret = pg_db_lo_tell(dbh, fd);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 1853 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_close)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, fd");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
#line 467 "Pg.xs"
		ST(0) = (pg_db_lo_close(dbh, fd) >= 0) ? &PL_sv_yes : &PL_sv_no;
#line 1872 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_unlink); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_unlink)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, lobjId");
    {
	SV *	dbh = ST(0)
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(1))
;
#line 475 "Pg.xs"
		ST(0) = (pg_db_lo_unlink(dbh, lobjId) >= 1) ? &PL_sv_yes : &PL_sv_no;
#line 1891 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_import); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_import)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, filename");
    {
	SV *	dbh = ST(0)
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
#line 483 "Pg.xs"
		const unsigned int ret = pg_db_lo_import(dbh, filename);
		ST(0) = (ret > 0) ? sv_2mortal(newSVuv(ret)) : &PL_sv_undef;
#line 1911 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_import_with_oid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_import_with_oid)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, filename, lobjId");
    {
	SV *	dbh = ST(0)
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(2))
;
#line 493 "Pg.xs"
		const unsigned int ret = (lobjId==0) ? pg_db_lo_import(dbh, filename)
			: pg_db_lo_import_with_oid(dbh, filename, lobjId);
		ST(0) = (ret > 0) ? sv_2mortal(newSVuv(ret)) : &PL_sv_undef;
#line 1934 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_lo_export); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_lo_export)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, lobjId, filename");
    {
	SV *	dbh = ST(0)
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(1))
;
	char *	filename = (char *)SvPV_nolen(ST(2))
;
#line 504 "Pg.xs"
		ST(0) = (pg_db_lo_export(dbh, lobjId, filename) >= 1) ? &PL_sv_yes : &PL_sv_no;
#line 1955 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_creat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_creat)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, mode");
    {
	SV *	dbh = ST(0)
;
	int	mode = (int)SvIV(ST(1))
;
#line 512 "Pg.xs"
		const unsigned int ret = pg_db_lo_creat(dbh, mode);
		ST(0) = (ret > 0) ? sv_2mortal(newSVuv(ret)) : &PL_sv_undef;
#line 1975 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_open)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, lobjId, mode");
    {
	SV *	dbh = ST(0)
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(1))
;
	int	mode = (int)SvIV(ST(2))
;
#line 521 "Pg.xs"
		const int ret = pg_db_lo_open(dbh, lobjId, mode);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 1997 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_write)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, fd, buf, len");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
	char *	buf = (char *)SvPV_nolen(ST(2))
;
	size_t	len = (size_t)SvUV(ST(3))
;
#line 532 "Pg.xs"
		const int ret = pg_db_lo_write(dbh, fd, buf, len);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 2021 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_read)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, fd, buf, len");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
	char *	buf = (char *)SvPV_nolen(ST(2))
;
	size_t	len = (size_t)SvUV(ST(3))
;
#line 543 "Pg.xs"
		SV * const bufsv = SvROK(ST(2)) ? SvRV(ST(2)) : ST(2);
		int ret;
#line 2045 "Pg.c"
#line 546 "Pg.xs"
		sv_setpvn(bufsv,"",0); /* Make sure we can grow it safely */
		buf = SvGROW(bufsv, len + 1);
		ret = pg_db_lo_read(dbh, fd, buf, len);
		if (ret > 0) {
			SvCUR_set(bufsv, ret);
			*SvEND(bufsv) = '\0';
			sv_setpvn(ST(2), buf, (unsigned)ret);
			SvSETMAGIC(ST(2));
		}
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 2057 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_lseek); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_lseek)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dbh, fd, offset, whence");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
	int	offset = (int)SvIV(ST(2))
;
	int	whence = (int)SvIV(ST(3))
;
#line 565 "Pg.xs"
		const int ret = pg_db_lo_lseek(dbh, fd, offset, whence);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 2081 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_tell); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_tell)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, fd");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
#line 574 "Pg.xs"
		const int ret = pg_db_lo_tell(dbh, fd);
		ST(0) = (ret >= 0) ? sv_2mortal(newSViv(ret)) : &PL_sv_undef;
#line 2101 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_close)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, fd");
    {
	SV *	dbh = ST(0)
;
	int	fd = (int)SvIV(ST(1))
;
#line 583 "Pg.xs"
		ST(0) = (pg_db_lo_close(dbh, fd) >= 0) ? &PL_sv_yes : &PL_sv_no;
#line 2120 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_unlink); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_unlink)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, lobjId");
    {
	SV *	dbh = ST(0)
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(1))
;
#line 591 "Pg.xs"
		ST(0) = (pg_db_lo_unlink(dbh, lobjId) >= 1) ? &PL_sv_yes : &PL_sv_no;
#line 2139 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_import); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_import)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, filename");
    {
	SV *	dbh = ST(0)
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
#line 599 "Pg.xs"
		const unsigned int ret = pg_db_lo_import(dbh, filename);
		ST(0) = (ret > 0) ? sv_2mortal(newSVuv(ret)) : &PL_sv_undef;
#line 2159 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_lo_export); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_lo_export)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, lobjId, filename");
    {
	SV *	dbh = ST(0)
;
	unsigned int	lobjId = (unsigned int)SvUV(ST(1))
;
	char *	filename = (char *)SvPV_nolen(ST(2))
;
#line 609 "Pg.xs"
		ST(0) = (pg_db_lo_export(dbh, lobjId, filename) >= 1) ? &PL_sv_yes : &PL_sv_no;
#line 2180 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_putline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_putline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, buf");
    {
	SV *	dbh = ST(0)
;
	char *	buf = (char *)SvPV_nolen(ST(1))
;
#line 617 "Pg.xs"
		ST(0) = (pg_db_putline(dbh, buf)!=0) ? &PL_sv_no : &PL_sv_yes;
#line 2199 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_putline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_putline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, buf");
    {
	SV *	dbh = ST(0)
;
	char *	buf = (char *)SvPV_nolen(ST(1))
;
#line 625 "Pg.xs"
		ST(0) = (pg_db_putline(dbh, buf)!=0) ? &PL_sv_no : &PL_sv_yes;
#line 2218 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_getline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_getline)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, buf, len");
    {
#line 631 "Pg.xs"
		SV *bufsv = SvROK(ST(1)) ? SvRV(ST(1)) : ST(1);
#line 2233 "Pg.c"
	SV *	dbh = ST(0)
;
	unsigned int	len = (unsigned int)SvUV(ST(2))
;
	char *	buf = (char *)SvPV_nolen(ST(1))
;
#line 637 "Pg.xs"
		int ret;
		bufsv = SvROK(ST(1)) ? SvRV(ST(1)) : ST(1);
		sv_setpvn(bufsv,"",0); /* Make sure we can grow it safely */
		buf = SvGROW(bufsv, 3);
		if (len > 3)
			buf = SvGROW(bufsv, len);
		ret = pg_db_getline(dbh, bufsv, (int)len);
		sv_setpv((SV*)ST(1), buf);
		SvSETMAGIC(ST(1));
		ST(0) = (-1 != ret) ? &PL_sv_yes : &PL_sv_no;
#line 2251 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_getcopydata); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_getcopydata)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, dataline");
    {
	SV *	dbh = ST(0)
;
	I32	RETVAL;
	dXSTARG;
#line 653 "Pg.xs"
		RETVAL = pg_db_getcopydata(dbh, SvROK(ST(1)) ? SvRV(ST(1)) : ST(1), 0);
#line 2270 "Pg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_getcopydata_async); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_getcopydata_async)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, dataline");
    {
	SV *	dbh = ST(0)
;
	I32	RETVAL;
	dXSTARG;
#line 662 "Pg.xs"
		RETVAL = pg_db_getcopydata(dbh, SvROK(ST(1)) ? SvRV(ST(1)) : ST(1), 1);
#line 2290 "Pg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_putcopydata); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_putcopydata)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, dataline");
    {
	SV *	dbh = ST(0)
;
	SV *	dataline = ST(1)
;
	I32	RETVAL;
	dXSTARG;
#line 672 "Pg.xs"
		RETVAL = pg_db_putcopydata(dbh, dataline);
#line 2312 "Pg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_putcopyend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_putcopyend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	I32	RETVAL;
	dXSTARG;
#line 681 "Pg.xs"
		RETVAL = pg_db_putcopyend(dbh);
#line 2332 "Pg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_getline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_getline)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, buf, len");
    {
#line 688 "Pg.xs"
		SV *bufsv = SvROK(ST(1)) ? SvRV(ST(1)) : ST(1);
#line 2348 "Pg.c"
	SV *	dbh = ST(0)
;
	unsigned int	len = (unsigned int)SvUV(ST(2))
;
	char *	buf = (char *)SvPV_nolen(ST(1))
;
#line 694 "Pg.xs"
		int ret;
		sv_setpvn(bufsv,"",0); /* Make sure we can grow it safely */
		buf = SvGROW(bufsv, 3);
		if (len > 3)
			buf = SvGROW(bufsv, len);
		ret = pg_db_getline(dbh, bufsv, (int)len);
		sv_setpv((SV*)ST(1), buf);
		SvSETMAGIC(ST(1));
		ST(0) = (-1 != ret) ? &PL_sv_yes : &PL_sv_no;
#line 2365 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_endcopy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_endcopy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 708 "Pg.xs"
		ST(0) = (-1 != pg_db_endcopy(dbh)) ? &PL_sv_yes : &PL_sv_no;
#line 2382 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_server_trace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_server_trace)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, fh");
    {
	SV *	dbh = ST(0)
;
	FILE *	fh = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
#line 715 "Pg.xs"
		pg_db_pg_server_trace(dbh,fh);
#line 2401 "Pg.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_DBD__Pg__db_pg_server_untrace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_server_untrace)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 721 "Pg.xs"
		pg_db_pg_server_untrace(dbh);
#line 2418 "Pg.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_DBD__Pg__db__pg_type_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db__pg_type_info)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "type_sv=Nullsv");
    {
	SV*	type_sv;

	if (items < 1)
	    type_sv = Nullsv;
	else {
	    type_sv = ST(0)
;
	}
#line 727 "Pg.xs"
	{
		int type_num = 0;

		if (type_sv && SvOK(type_sv)) {
			sql_type_info_t *type_info;
			if SvMAGICAL(type_sv)
				(void)mg_get(type_sv);
			type_info = pg_type_data(SvIV(type_sv));
			type_num = type_info ? type_info->type.sql : SQL_VARCHAR;
		}
		ST(0) = sv_2mortal( newSViv( type_num ) );
	}
#line 2452 "Pg.c"
    }
    XSRETURN(1);
}

#if PGLIBVERSION >= 80000
#define XSubPPtmpAAAJ 1


XS_EUPXS(XS_DBD__Pg__db_pg_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 746 "Pg.xs"
		int ret;
		D_imp_dbh(dbh);
		ret = pg_db_result(dbh, imp_dbh);
		if (ret == 0)
			XST_mPV(0, "0E0");
		else if (ret < -1)
			XST_mUNDEF(0);
		else
			XST_mIV(0, ret);
#line 2480 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 760 "Pg.xs"
		D_imp_dbh(dbh);
		ST(0) = sv_2mortal(newSViv(pg_db_ready(dbh, imp_dbh)));
#line 2498 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__db_pg_cancel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__db_pg_cancel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 767 "Pg.xs"
	D_imp_dbh(dbh);
	ST(0) = pg_db_cancel(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 2516 "Pg.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__Pg__st_state); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_state)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 784 "Pg.xs"
		D_imp_sth(sth);
		D_imp_dbh_from_sth;
		ST(0) = strEQ(imp_dbh->sqlstate,"00000") ? &PL_sv_no : newSVpv(imp_dbh->sqlstate, 5);
#line 2536 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_pg_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_pg_ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 792 "Pg.xs"
		D_imp_sth(sth);
		D_imp_dbh_from_sth;
		ST(0) = sv_2mortal(newSViv(pg_db_ready(sth, imp_dbh)));
#line 2555 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_pg_cancel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_pg_cancel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 800 "Pg.xs"
	D_imp_sth(sth);
	ST(0) = pg_db_cancel_sth(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#line 2573 "Pg.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__Pg__st_cancel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_cancel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 807 "Pg.xs"
	D_imp_sth(sth);
	ST(0) = dbd_st_cancel(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#line 2591 "Pg.c"
    }
    XSRETURN(1);
}

#if PGLIBVERSION >= 80000
#define XSubPPtmpAAAK 1


XS_EUPXS(XS_DBD__Pg__st_pg_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__Pg__st_pg_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 816 "Pg.xs"
		int ret;
		D_imp_sth(sth);
		D_imp_dbh_from_sth;
		ret = pg_db_result(sth, imp_dbh);
		if (ret == 0)
			XST_mPV(0, "0E0");
		else if (ret < -1)
			XST_mUNDEF(0);
		else
			XST_mIV(0, ret);
#line 2620 "Pg.c"
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_DBD__Pg); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_DBD__Pg)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        cv = newXSproto_portable("DBD::Pg::PG_TIDARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1010;
        cv = newXSproto_portable("DBD::Pg::PG_OID", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 26;
        cv = newXSproto_portable("DBD::Pg::PG_INTERVALARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1187;
        cv = newXSproto_portable("DBD::Pg::PG_MONEY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 790;
        cv = newXSproto_portable("DBD::Pg::PG_BPCHAR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1042;
        cv = newXSproto_portable("DBD::Pg::PG_TIMETZARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1270;
        cv = newXSproto_portable("DBD::Pg::PG_INT4", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 23;
        cv = newXSproto_portable("DBD::Pg::PG_CIDR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 650;
        cv = newXSproto_portable("DBD::Pg::PG_INT2VECTOR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 22;
        cv = newXSproto_portable("DBD::Pg::PG_BOOLARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1000;
        cv = newXSproto_portable("DBD::Pg::PG_LSEGARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1018;
        cv = newXSproto_portable("DBD::Pg::PG_TINTERVALARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1025;
        cv = newXSproto_portable("DBD::Pg::PG_CID", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 29;
        cv = newXSproto_portable("DBD::Pg::PG_VARBIT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1562;
        cv = newXSproto_portable("DBD::Pg::PG_BITARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1561;
        cv = newXSproto_portable("DBD::Pg::PG_TID", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 27;
        cv = newXSproto_portable("DBD::Pg::PG_XML", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 142;
        cv = newXSproto_portable("DBD::Pg::PG_REGPROCEDUREARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2207;
        cv = newXSproto_portable("DBD::Pg::PG_GTSVECTORARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3644;
        cv = newXSproto_portable("DBD::Pg::PG_REGCLASSARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2210;
        cv = newXSproto_portable("DBD::Pg::PG_RECORDARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2287;
        cv = newXSproto_portable("DBD::Pg::PG_VARCHAR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1043;
        cv = newXSproto_portable("DBD::Pg::PG_XIDARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1011;
        cv = newXSproto_portable("DBD::Pg::PG_ANYNONARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2776;
        cv = newXSproto_portable("DBD::Pg::PG_XID", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 28;
        cv = newXSproto_portable("DBD::Pg::PG_INT2ARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1005;
        cv = newXSproto_portable("DBD::Pg::PG_ABSTIMEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1023;
        cv = newXSproto_portable("DBD::Pg::PG_REFCURSORARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2201;
        cv = newXSproto_portable("DBD::Pg::PG_TIMETZ", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1266;
        cv = newXSproto_portable("DBD::Pg::PG_SMGR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 210;
        cv = newXSproto_portable("DBD::Pg::PG_PATHARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1019;
        cv = newXSproto_portable("DBD::Pg::PG_INTERVAL", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1186;
        cv = newXSproto_portable("DBD::Pg::PG_TIMESTAMPARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1115;
        cv = newXSproto_portable("DBD::Pg::PG_PATH", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 602;
        cv = newXSproto_portable("DBD::Pg::PG_TIMESTAMP", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1114;
        cv = newXSproto_portable("DBD::Pg::PG_POINT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 600;
        cv = newXSproto_portable("DBD::Pg::PG_PG_TYPE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 71;
        cv = newXSproto_portable("DBD::Pg::PG_PG_CLASS", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 83;
        cv = newXSproto_portable("DBD::Pg::PG_INETARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1041;
        cv = newXSproto_portable("DBD::Pg::PG_DATEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1182;
        cv = newXSproto_portable("DBD::Pg::PG_REGOPERARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2208;
        cv = newXSproto_portable("DBD::Pg::PG_CIDARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1012;
        cv = newXSproto_portable("DBD::Pg::PG_VOID", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2278;
        cv = newXSproto_portable("DBD::Pg::PG_POINTARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1017;
        cv = newXSproto_portable("DBD::Pg::PG_BOOL", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 16;
        cv = newXSproto_portable("DBD::Pg::PG_LANGUAGE_HANDLER", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2280;
        cv = newXSproto_portable("DBD::Pg::PG_TSVECTOR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3614;
        cv = newXSproto_portable("DBD::Pg::PG_TIMESTAMPTZARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1185;
        cv = newXSproto_portable("DBD::Pg::PG_NAME", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 19;
        cv = newXSproto_portable("DBD::Pg::PG_TXID_SNAPSHOTARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2949;
        cv = newXSproto_portable("DBD::Pg::PG_CHAR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 18;
        cv = newXSproto_portable("DBD::Pg::PG_OIDVECTORARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1013;
        cv = newXSproto_portable("DBD::Pg::PG_NUMERICARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1231;
        cv = newXSproto_portable("DBD::Pg::PG_TINTERVAL", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 704;
        cv = newXSproto_portable("DBD::Pg::PG_CIRCLE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 718;
        cv = newXSproto_portable("DBD::Pg::PG_UUID", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2950;
        cv = newXSproto_portable("DBD::Pg::PG_REGDICTIONARY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3769;
        cv = newXSproto_portable("DBD::Pg::PG_OLDQUERY_WAIT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 4;
        cv = newXSproto_portable("DBD::Pg::PG_OLDQUERY_CANCEL", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2;
        cv = newXSproto_portable("DBD::Pg::PG_REGPROCEDURE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2202;
        cv = newXSproto_portable("DBD::Pg::PG_REGOPERATOR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2204;
        cv = newXSproto_portable("DBD::Pg::PG_BYTEAARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1001;
        cv = newXSproto_portable("DBD::Pg::PG_TEXT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 25;
        cv = newXSproto_portable("DBD::Pg::PG_OPAQUE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2282;
        cv = newXSproto_portable("DBD::Pg::PG_MACADDRARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1040;
        cv = newXSproto_portable("DBD::Pg::PG_REGDICTIONARYARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3770;
        cv = newXSproto_portable("DBD::Pg::constant", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("DBD::Pg::PG_RECORD", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2249;
        cv = newXSproto_portable("DBD::Pg::PG_FLOAT4", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 700;
        cv = newXSproto_portable("DBD::Pg::PG_CSTRING", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2275;
        cv = newXSproto_portable("DBD::Pg::PG_INT4ARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1007;
        cv = newXSproto_portable("DBD::Pg::PG_OIDVECTOR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 30;
        cv = newXSproto_portable("DBD::Pg::PG_TIME", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1083;
        cv = newXSproto_portable("DBD::Pg::PG_BYTEA", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 17;
        cv = newXSproto_portable("DBD::Pg::PG_INT2VECTORARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1006;
        cv = newXSproto_portable("DBD::Pg::PG_INTERNAL", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2281;
        cv = newXSproto_portable("DBD::Pg::PG_LINE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 628;
        cv = newXSproto_portable("DBD::Pg::PG_TSQUERYARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3645;
        cv = newXSproto_portable("DBD::Pg::PG_FLOAT8", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 701;
        cv = newXSproto_portable("DBD::Pg::PG_BOX", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 603;
        cv = newXSproto_portable("DBD::Pg::PG_BOXARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1020;
        cv = newXSproto_portable("DBD::Pg::PG_INT8ARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1016;
        cv = newXSproto_portable("DBD::Pg::PG_OIDARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1028;
        cv = newXSproto_portable("DBD::Pg::PG_PG_ATTRIBUTE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 75;
        cv = newXSproto_portable("DBD::Pg::PG_POLYGON", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 604;
        cv = newXSproto_portable("DBD::Pg::PG_REGTYPE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2206;
        cv = newXSproto_portable("DBD::Pg::PG_CSTRINGARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1263;
        cv = newXSproto_portable("DBD::Pg::PG_REGOPER", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2203;
        cv = newXSproto_portable("DBD::Pg::PG_REGPROC", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 24;
        cv = newXSproto_portable("DBD::Pg::PG_TRIGGER", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2279;
        cv = newXSproto_portable("DBD::Pg::PG_NUMERIC", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1700;
        cv = newXSproto_portable("DBD::Pg::PG_XMLARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 143;
        cv = newXSproto_portable("DBD::Pg::PG_ABSTIME", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 702;
        cv = newXSproto_portable("DBD::Pg::PG_FLOAT4ARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1021;
        cv = newXSproto_portable("DBD::Pg::PG_INET", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 869;
        cv = newXSproto_portable("DBD::Pg::PG_REFCURSOR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1790;
        cv = newXSproto_portable("DBD::Pg::PG_ANYENUM", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3500;
        cv = newXSproto_portable("DBD::Pg::PG_BIT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1560;
        cv = newXSproto_portable("DBD::Pg::PG_BPCHARARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1014;
        cv = newXSproto_portable("DBD::Pg::PG_LINEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 629;
        cv = newXSproto_portable("DBD::Pg::PG_POLYGONARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1027;
        cv = newXSproto_portable("DBD::Pg::PG_TXID_SNAPSHOT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2970;
        cv = newXSproto_portable("DBD::Pg::PG_ACLITEM", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1033;
        cv = newXSproto_portable("DBD::Pg::PG_ANYELEMENT", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2283;
        cv = newXSproto_portable("DBD::Pg::PG_CIRCLEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 719;
        cv = newXSproto_portable("DBD::Pg::PG_NAMEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1003;
        cv = newXSproto_portable("DBD::Pg::PG_RELTIMEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1024;
        cv = newXSproto_portable("DBD::Pg::PG_TSVECTORARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3643;
        cv = newXSproto_portable("DBD::Pg::PG_RELTIME", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 703;
        cv = newXSproto_portable("DBD::Pg::PG_UNKNOWN", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 705;
        cv = newXSproto_portable("DBD::Pg::PG_FLOAT8ARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1022;
        cv = newXSproto_portable("DBD::Pg::PG_ANY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2276;
        cv = newXSproto_portable("DBD::Pg::PG_VARCHARARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1015;
        cv = newXSproto_portable("DBD::Pg::PG_ANYARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2277;
        cv = newXSproto_portable("DBD::Pg::PG_PG_PROC", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 81;
        cv = newXSproto_portable("DBD::Pg::PG_CIDRARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 651;
        cv = newXSproto_portable("DBD::Pg::PG_UUIDARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2951;
        cv = newXSproto_portable("DBD::Pg::PG_REGCLASS", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2205;
        cv = newXSproto_portable("DBD::Pg::PG_TIMESTAMPTZ", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1184;
        cv = newXSproto_portable("DBD::Pg::PG_REGCONFIGARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3735;
        cv = newXSproto_portable("DBD::Pg::PG_VARBITARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1563;
        cv = newXSproto_portable("DBD::Pg::PG_MACADDR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 829;
        cv = newXSproto_portable("DBD::Pg::PG_TEXTARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1009;
        cv = newXSproto_portable("DBD::Pg::PG_MONEYARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 791;
        cv = newXSproto_portable("DBD::Pg::PG_ACLITEMARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1034;
        cv = newXSproto_portable("DBD::Pg::PG_DATE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1082;
        cv = newXSproto_portable("DBD::Pg::PG_REGPROCARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1008;
        cv = newXSproto_portable("DBD::Pg::PG_INT2", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 21;
        cv = newXSproto_portable("DBD::Pg::PG_REGCONFIG", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3734;
        cv = newXSproto_portable("DBD::Pg::PG_ASYNC", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("DBD::Pg::PG_INT8", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 20;
        cv = newXSproto_portable("DBD::Pg::PG_TSQUERY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3615;
        cv = newXSproto_portable("DBD::Pg::PG_GTSVECTOR", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3642;
        cv = newXSproto_portable("DBD::Pg::PG_FDW_HANDLER", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 3115;
        cv = newXSproto_portable("DBD::Pg::PG_TIMEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1183;
        cv = newXSproto_portable("DBD::Pg::PG_CHARARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 1002;
        cv = newXSproto_portable("DBD::Pg::PG_REGOPERATORARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2209;
        cv = newXSproto_portable("DBD::Pg::PG_LSEG", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 601;
        cv = newXSproto_portable("DBD::Pg::PG_PG_NODE_TREE", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 194;
        cv = newXSproto_portable("DBD::Pg::PG_REGTYPEARRAY", XS_DBD__Pg_constant, file, "");
        XSANY.any_i32 = 2211;
        newXS("DBD::Pg::dr::dbixs_revision", XS_DBD__Pg__dr_dbixs_revision, file);
#if XSubPPtmpAAAA
        cv = newXS("DBD::Pg::dr::disconnect_all", XS_DBD__Pg__dr_discon_all_, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::Pg::dr::discon_all_", XS_DBD__Pg__dr_discon_all_, file);
        XSANY.any_i32 = 0;
#endif
#if XSubPPtmpAAAB
        newXS("DBD::Pg::dr::data_sources", XS_DBD__Pg__dr_data_sources, file);
#endif
        newXS("DBD::Pg::db::_login", XS_DBD__Pg__db__login, file);
        newXS("DBD::Pg::db::selectall_arrayref", XS_DBD__Pg__db_selectall_arrayref, file);
        cv = newXS("DBD::Pg::db::selectrow_arrayref", XS_DBD__Pg__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::Pg::db::selectrow_array", XS_DBD__Pg__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1;
#if XSubPPtmpAAAC
        newXS("DBD::Pg::db::dontdo", XS_DBD__Pg__db_dontdo, file);
#endif
#if XSubPPtmpAAAD
        newXS("DBD::Pg::db::last_insert_id", XS_DBD__Pg__db_last_insert_id, file);
#endif
        newXS("DBD::Pg::db::commit", XS_DBD__Pg__db_commit, file);
        newXS("DBD::Pg::db::rollback", XS_DBD__Pg__db_rollback, file);
        newXS("DBD::Pg::db::disconnect", XS_DBD__Pg__db_disconnect, file);
        newXS("DBD::Pg::db::STORE", XS_DBD__Pg__db_STORE, file);
        newXS("DBD::Pg::db::FETCH", XS_DBD__Pg__db_FETCH, file);
        newXS("DBD::Pg::db::DESTROY", XS_DBD__Pg__db_DESTROY, file);
#if XSubPPtmpAAAE
        newXS("DBD::Pg::db::take_imp_data", XS_DBD__Pg__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAF
        newXS("DBD::Pg::db::data_sources", XS_DBD__Pg__db_data_sources, file);
#endif
        newXS("DBD::Pg::st::_prepare", XS_DBD__Pg__st__prepare, file);
#if XSubPPtmpAAAG
        newXS("DBD::Pg::st::rows", XS_DBD__Pg__st_rows, file);
#endif
#if XSubPPtmpAAAH
        newXS("DBD::Pg::st::bind_col", XS_DBD__Pg__st_bind_col, file);
#endif
        newXS("DBD::Pg::st::bind_param", XS_DBD__Pg__st_bind_param, file);
        newXS("DBD::Pg::st::bind_param_inout", XS_DBD__Pg__st_bind_param_inout, file);
        newXS("DBD::Pg::st::execute", XS_DBD__Pg__st_execute, file);
#if XSubPPtmpAAAI
        newXS("DBD::Pg::st::execute_for_fetch", XS_DBD__Pg__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::Pg::st::fetch", XS_DBD__Pg__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::Pg::st::fetchrow_arrayref", XS_DBD__Pg__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::Pg::st::fetchrow_array", XS_DBD__Pg__st_fetchrow_array, file);
        XSANY.any_i32 = 0;
        cv = newXS("DBD::Pg::st::fetchrow", XS_DBD__Pg__st_fetchrow_array, file);
        XSANY.any_i32 = 1;
        newXS("DBD::Pg::st::fetchall_arrayref", XS_DBD__Pg__st_fetchall_arrayref, file);
        newXS("DBD::Pg::st::finish", XS_DBD__Pg__st_finish, file);
        newXS("DBD::Pg::st::blob_read", XS_DBD__Pg__st_blob_read, file);
        newXS("DBD::Pg::st::STORE", XS_DBD__Pg__st_STORE, file);
        cv = newXS("DBD::Pg::st::FETCH", XS_DBD__Pg__st_FETCH_attrib, file);
        XSANY.any_i32 = 1;
        cv = newXS("DBD::Pg::st::FETCH_attrib", XS_DBD__Pg__st_FETCH_attrib, file);
        XSANY.any_i32 = 0;
        newXS("DBD::Pg::st::DESTROY", XS_DBD__Pg__st_DESTROY, file);
        newXS("DBD::Pg::db::quote", XS_DBD__Pg__db_quote, file);
        newXS("DBD::Pg::db::state", XS_DBD__Pg__db_state, file);
        (void)newXSproto_portable("DBD::Pg::db::do", XS_DBD__Pg__db_do, file, "$$;$@");
        newXS("DBD::Pg::db::_ping", XS_DBD__Pg__db__ping, file);
        newXS("DBD::Pg::db::getfd", XS_DBD__Pg__db_getfd, file);
        newXS("DBD::Pg::db::pg_endcopy", XS_DBD__Pg__db_pg_endcopy, file);
        newXS("DBD::Pg::db::pg_notifies", XS_DBD__Pg__db_pg_notifies, file);
        newXS("DBD::Pg::db::pg_savepoint", XS_DBD__Pg__db_pg_savepoint, file);
        newXS("DBD::Pg::db::pg_rollback_to", XS_DBD__Pg__db_pg_rollback_to, file);
        newXS("DBD::Pg::db::pg_release", XS_DBD__Pg__db_pg_release, file);
        newXS("DBD::Pg::db::pg_lo_creat", XS_DBD__Pg__db_pg_lo_creat, file);
        newXS("DBD::Pg::db::pg_lo_open", XS_DBD__Pg__db_pg_lo_open, file);
        newXS("DBD::Pg::db::pg_lo_write", XS_DBD__Pg__db_pg_lo_write, file);
        newXS("DBD::Pg::db::pg_lo_read", XS_DBD__Pg__db_pg_lo_read, file);
        newXS("DBD::Pg::db::pg_lo_lseek", XS_DBD__Pg__db_pg_lo_lseek, file);
        newXS("DBD::Pg::db::pg_lo_tell", XS_DBD__Pg__db_pg_lo_tell, file);
        newXS("DBD::Pg::db::pg_lo_close", XS_DBD__Pg__db_pg_lo_close, file);
        newXS("DBD::Pg::db::pg_lo_unlink", XS_DBD__Pg__db_pg_lo_unlink, file);
        newXS("DBD::Pg::db::pg_lo_import", XS_DBD__Pg__db_pg_lo_import, file);
        newXS("DBD::Pg::db::pg_lo_import_with_oid", XS_DBD__Pg__db_pg_lo_import_with_oid, file);
        newXS("DBD::Pg::db::pg_lo_export", XS_DBD__Pg__db_pg_lo_export, file);
        newXS("DBD::Pg::db::lo_creat", XS_DBD__Pg__db_lo_creat, file);
        newXS("DBD::Pg::db::lo_open", XS_DBD__Pg__db_lo_open, file);
        newXS("DBD::Pg::db::lo_write", XS_DBD__Pg__db_lo_write, file);
        newXS("DBD::Pg::db::lo_read", XS_DBD__Pg__db_lo_read, file);
        newXS("DBD::Pg::db::lo_lseek", XS_DBD__Pg__db_lo_lseek, file);
        newXS("DBD::Pg::db::lo_tell", XS_DBD__Pg__db_lo_tell, file);
        newXS("DBD::Pg::db::lo_close", XS_DBD__Pg__db_lo_close, file);
        newXS("DBD::Pg::db::lo_unlink", XS_DBD__Pg__db_lo_unlink, file);
        newXS("DBD::Pg::db::lo_import", XS_DBD__Pg__db_lo_import, file);
        newXS("DBD::Pg::db::lo_export", XS_DBD__Pg__db_lo_export, file);
        newXS("DBD::Pg::db::pg_putline", XS_DBD__Pg__db_pg_putline, file);
        newXS("DBD::Pg::db::putline", XS_DBD__Pg__db_putline, file);
        newXS("DBD::Pg::db::pg_getline", XS_DBD__Pg__db_pg_getline, file);
        newXS("DBD::Pg::db::pg_getcopydata", XS_DBD__Pg__db_pg_getcopydata, file);
        newXS("DBD::Pg::db::pg_getcopydata_async", XS_DBD__Pg__db_pg_getcopydata_async, file);
        newXS("DBD::Pg::db::pg_putcopydata", XS_DBD__Pg__db_pg_putcopydata, file);
        newXS("DBD::Pg::db::pg_putcopyend", XS_DBD__Pg__db_pg_putcopyend, file);
        newXS("DBD::Pg::db::getline", XS_DBD__Pg__db_getline, file);
        newXS("DBD::Pg::db::endcopy", XS_DBD__Pg__db_endcopy, file);
        newXS("DBD::Pg::db::pg_server_trace", XS_DBD__Pg__db_pg_server_trace, file);
        newXS("DBD::Pg::db::pg_server_untrace", XS_DBD__Pg__db_pg_server_untrace, file);
        newXS("DBD::Pg::db::_pg_type_info", XS_DBD__Pg__db__pg_type_info, file);
#if XSubPPtmpAAAJ
        newXS("DBD::Pg::db::pg_result", XS_DBD__Pg__db_pg_result, file);
        newXS("DBD::Pg::db::pg_ready", XS_DBD__Pg__db_pg_ready, file);
        newXS("DBD::Pg::db::pg_cancel", XS_DBD__Pg__db_pg_cancel, file);
#endif
        newXS("DBD::Pg::st::state", XS_DBD__Pg__st_state, file);
        newXS("DBD::Pg::st::pg_ready", XS_DBD__Pg__st_pg_ready, file);
        newXS("DBD::Pg::st::pg_cancel", XS_DBD__Pg__st_pg_cancel, file);
        newXS("DBD::Pg::st::cancel", XS_DBD__Pg__st_cancel, file);
#if XSubPPtmpAAAK
        newXS("DBD::Pg::st::pg_result", XS_DBD__Pg__st_pg_result, file);
#endif
    }

    /* Initialisation Section */

#line 18 "./Pg.xsi"
    PERL_UNUSED_VAR(items);
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::Pg::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::Pg::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::Pg::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#line 3083 "Pg.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

