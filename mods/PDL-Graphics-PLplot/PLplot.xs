
/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif

#include <plplot.h>
#include <plplotP.h>
#include <plevent.h>
#include <stdio.h>
typedef struct pdl_pladv_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pladv_struct;

void pdl_pladv_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pladv_struct *__privtrans = (pdl_pladv_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * page_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * page_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"page"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::pladv";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pladv_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pladv_struct *__privtrans = (pdl_pladv_struct *) __tr;
	
	{
	    pdl_pladv_struct *__copy = malloc(sizeof(pdl_pladv_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pladv_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pladv_struct *__privtrans = (pdl_pladv_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * page_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * page_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];page_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_pladv((page_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 page_datap += __tinc0_0;

	 } page_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} page_datap -= __tinc1_0 *
     				  __tdims1;
 page_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pladv_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pladv_struct *__privtrans = (pdl_pladv_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_pladv_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pladv_vtable = {
		0,0, 1, 1, pdl_pladv_vtable_flags,
		pdl_pladv_redodims, pdl_pladv_readdata, NULL,
		pdl_pladv_free,NULL,NULL,pdl_pladv_copy,NULL,
		sizeof(pdl_pladv_struct),"pdl_pladv_vtable",
		NULL
	 };

typedef struct pdl_plaxes_pp_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		char  *xopt;char  *yopt;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plaxes_pp_struct;

void pdl_plaxes_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plaxes_pp_struct *__privtrans = (pdl_plaxes_pp_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xzero_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yzero_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xtick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xtick_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxsub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxsub_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * ytick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ytick_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nysub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nysub_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xzero","yzero","xtick","nxsub","ytick","nysub"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plaxes_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plaxes_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plaxes_pp_struct *__privtrans = (pdl_plaxes_pp_struct *) __tr;
	
	{
	    pdl_plaxes_pp_struct *__copy = malloc(sizeof(pdl_plaxes_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->xopt) = malloc(strlen(__privtrans->xopt)+1); strcpy(__copy->xopt,__privtrans->xopt);;(__copy->yopt) = malloc(strlen(__privtrans->yopt)+1); strcpy(__copy->yopt,__privtrans->yopt);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plaxes_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plaxes_pp_struct *__privtrans = (pdl_plaxes_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xzero_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yzero_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xtick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xtick_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxsub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxsub_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * ytick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ytick_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nysub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nysub_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xzero_datap += __offsp[0];
yzero_datap += __offsp[1];
xtick_datap += __offsp[2];
nxsub_datap += __offsp[3];
ytick_datap += __offsp[4];
nysub_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plaxes((xzero_datap)[0] PDL_COMMENT("ACCESS()") ,(yzero_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->xopt,(xtick_datap)[0] PDL_COMMENT("ACCESS()") ,(nxsub_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->yopt,(ytick_datap)[0] PDL_COMMENT("ACCESS()") ,(nysub_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xzero_datap += __tinc0_0;
yzero_datap += __tinc0_1;
xtick_datap += __tinc0_2;
nxsub_datap += __tinc0_3;
ytick_datap += __tinc0_4;
nysub_datap += __tinc0_5;

	 } xzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yzero_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xtick_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
nxsub_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ytick_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
nysub_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xzero_datap -= __tinc1_0 *
     				  __tdims1;yzero_datap -= __tinc1_1 *
     				  __tdims1;xtick_datap -= __tinc1_2 *
     				  __tdims1;nxsub_datap -= __tinc1_3 *
     				  __tdims1;ytick_datap -= __tinc1_4 *
     				  __tdims1;nysub_datap -= __tinc1_5 *
     				  __tdims1;
 xzero_datap -= __offsp[0];
yzero_datap -= __offsp[1];
xtick_datap -= __offsp[2];
nxsub_datap -= __offsp[3];
ytick_datap -= __offsp[4];
nysub_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plaxes_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plaxes_pp_struct *__privtrans = (pdl_plaxes_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->xopt);;free(__privtrans->yopt);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plaxes_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plaxes_pp_vtable = {
		0,0, 6, 6, pdl_plaxes_pp_vtable_flags,
		pdl_plaxes_pp_redodims, pdl_plaxes_pp_readdata, NULL,
		pdl_plaxes_pp_free,NULL,NULL,pdl_plaxes_pp_copy,NULL,
		sizeof(pdl_plaxes_pp_struct),"pdl_plaxes_pp_vtable",
		NULL
	 };

typedef struct pdl_plbin_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_dima;PDL_Long  __inc_y_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plbin_struct;

void pdl_plbin_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plbin_struct *__privtrans = (pdl_plbin_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nbin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nbin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * center_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * center_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_dima = __privtrans->__inc_y_dima;
register PDL_Long __inc_x_dima = __privtrans->__inc_x_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nbin","x","y","center"};
		static int __realdims[] = {0,1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plbin";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plbin:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plbin:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_x_dima = 0; else
		 __privtrans->__inc_x_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_y_dima = 0; else
		 __privtrans->__inc_y_dima = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plbin_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plbin_struct *__privtrans = (pdl_plbin_struct *) __tr;
	
	{
	    pdl_plbin_struct *__copy = malloc(sizeof(pdl_plbin_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_dima=__copy->__inc_x_dima;__privtrans->__inc_y_dima=__copy->__inc_y_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plbin_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plbin_struct *__privtrans = (pdl_plbin_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nbin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nbin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * center_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * center_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];nbin_datap += __offsp[0];
x_datap += __offsp[1];
y_datap += __offsp[2];
center_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_dima = __privtrans->__inc_y_dima;
register PDL_Long __inc_x_dima = __privtrans->__inc_x_dima;

c_plbin((nbin_datap)[0] PDL_COMMENT("ACCESS()") ,x_datap,y_datap,(center_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 nbin_datap += __tinc0_0;
x_datap += __tinc0_1;
y_datap += __tinc0_2;
center_datap += __tinc0_3;

	 } nbin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
x_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
y_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
center_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} nbin_datap -= __tinc1_0 *
     				  __tdims1;x_datap -= __tinc1_1 *
     				  __tdims1;y_datap -= __tinc1_2 *
     				  __tdims1;center_datap -= __tinc1_3 *
     				  __tdims1;
 nbin_datap -= __offsp[0];
x_datap -= __offsp[1];
y_datap -= __offsp[2];
center_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plbin_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plbin_struct *__privtrans = (pdl_plbin_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plbin_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plbin_vtable = {
		0,0, 4, 4, pdl_plbin_vtable_flags,
		pdl_plbin_redodims, pdl_plbin_readdata, NULL,
		pdl_plbin_free,NULL,NULL,pdl_plbin_copy,NULL,
		sizeof(pdl_plbin_struct),"pdl_plbin_vtable",
		NULL
	 };

typedef struct pdl_plbox_pp_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		char  *xopt;char  *yopt;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plbox_pp_struct;

void pdl_plbox_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox_pp_struct *__privtrans = (pdl_plbox_pp_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xtick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xtick_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * nxsub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nxsub_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * ytick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ytick_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nysub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nysub_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xtick","nxsub","ytick","nysub"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plbox_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plbox_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox_pp_struct *__privtrans = (pdl_plbox_pp_struct *) __tr;
	
	{
	    pdl_plbox_pp_struct *__copy = malloc(sizeof(pdl_plbox_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->xopt) = malloc(strlen(__privtrans->xopt)+1); strcpy(__copy->xopt,__privtrans->xopt);;(__copy->yopt) = malloc(strlen(__privtrans->yopt)+1); strcpy(__copy->yopt,__privtrans->yopt);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plbox_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox_pp_struct *__privtrans = (pdl_plbox_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xtick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xtick_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * nxsub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nxsub_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * ytick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ytick_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nysub_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nysub_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xtick_datap += __offsp[0];
nxsub_datap += __offsp[1];
ytick_datap += __offsp[2];
nysub_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plbox(__privtrans->xopt,(xtick_datap)[0] PDL_COMMENT("ACCESS()") ,(nxsub_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->yopt,(ytick_datap)[0] PDL_COMMENT("ACCESS()") ,(nysub_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xtick_datap += __tinc0_0;
nxsub_datap += __tinc0_1;
ytick_datap += __tinc0_2;
nysub_datap += __tinc0_3;

	 } xtick_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
nxsub_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ytick_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
nysub_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xtick_datap -= __tinc1_0 *
     				  __tdims1;nxsub_datap -= __tinc1_1 *
     				  __tdims1;ytick_datap -= __tinc1_2 *
     				  __tdims1;nysub_datap -= __tinc1_3 *
     				  __tdims1;
 xtick_datap -= __offsp[0];
nxsub_datap -= __offsp[1];
ytick_datap -= __offsp[2];
nysub_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plbox_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox_pp_struct *__privtrans = (pdl_plbox_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->xopt);;free(__privtrans->yopt);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plbox_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plbox_pp_vtable = {
		0,0, 4, 4, pdl_plbox_pp_vtable_flags,
		pdl_plbox_pp_redodims, pdl_plbox_pp_readdata, NULL,
		pdl_plbox_pp_free,NULL,NULL,pdl_plbox_pp_copy,NULL,
		sizeof(pdl_plbox_pp_struct),"pdl_plbox_pp_vtable",
		NULL
	 };

typedef struct pdl_plbox3_pp_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		char  *xopt;char  *xlabel;char  *yopt;char  *ylabel;char  *zopt;char  *zlabel;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plbox3_pp_struct;

void pdl_plbox3_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox3_pp_struct *__privtrans = (pdl_plbox3_pp_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xtick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xtick_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * nsubx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nsubx_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * ytick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ytick_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nsuby_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nsuby_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * ztick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ztick_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nsubz_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nsubz_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xtick","nsubx","ytick","nsuby","ztick","nsubz"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plbox3_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plbox3_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox3_pp_struct *__privtrans = (pdl_plbox3_pp_struct *) __tr;
	
	{
	    pdl_plbox3_pp_struct *__copy = malloc(sizeof(pdl_plbox3_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->xopt) = malloc(strlen(__privtrans->xopt)+1); strcpy(__copy->xopt,__privtrans->xopt);;(__copy->xlabel) = malloc(strlen(__privtrans->xlabel)+1); strcpy(__copy->xlabel,__privtrans->xlabel);;(__copy->yopt) = malloc(strlen(__privtrans->yopt)+1); strcpy(__copy->yopt,__privtrans->yopt);;(__copy->ylabel) = malloc(strlen(__privtrans->ylabel)+1); strcpy(__copy->ylabel,__privtrans->ylabel);;(__copy->zopt) = malloc(strlen(__privtrans->zopt)+1); strcpy(__copy->zopt,__privtrans->zopt);;(__copy->zlabel) = malloc(strlen(__privtrans->zlabel)+1); strcpy(__copy->zlabel,__privtrans->zlabel);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plbox3_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox3_pp_struct *__privtrans = (pdl_plbox3_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xtick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xtick_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * nsubx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nsubx_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * ytick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ytick_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nsuby_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nsuby_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * ztick_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ztick_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nsubz_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nsubz_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xtick_datap += __offsp[0];
nsubx_datap += __offsp[1];
ytick_datap += __offsp[2];
nsuby_datap += __offsp[3];
ztick_datap += __offsp[4];
nsubz_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plbox3(__privtrans->xopt,__privtrans->xlabel,(xtick_datap)[0] PDL_COMMENT("ACCESS()") ,(nsubx_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->yopt,__privtrans->ylabel,(ytick_datap)[0] PDL_COMMENT("ACCESS()") ,(nsuby_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->zopt,__privtrans->zlabel,(ztick_datap)[0] PDL_COMMENT("ACCESS()") ,(nsubz_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xtick_datap += __tinc0_0;
nsubx_datap += __tinc0_1;
ytick_datap += __tinc0_2;
nsuby_datap += __tinc0_3;
ztick_datap += __tinc0_4;
nsubz_datap += __tinc0_5;

	 } xtick_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
nsubx_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ytick_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
nsuby_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ztick_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
nsubz_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xtick_datap -= __tinc1_0 *
     				  __tdims1;nsubx_datap -= __tinc1_1 *
     				  __tdims1;ytick_datap -= __tinc1_2 *
     				  __tdims1;nsuby_datap -= __tinc1_3 *
     				  __tdims1;ztick_datap -= __tinc1_4 *
     				  __tdims1;nsubz_datap -= __tinc1_5 *
     				  __tdims1;
 xtick_datap -= __offsp[0];
nsubx_datap -= __offsp[1];
ytick_datap -= __offsp[2];
nsuby_datap -= __offsp[3];
ztick_datap -= __offsp[4];
nsubz_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plbox3_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plbox3_pp_struct *__privtrans = (pdl_plbox3_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->xopt);;free(__privtrans->xlabel);;free(__privtrans->yopt);;free(__privtrans->ylabel);;free(__privtrans->zopt);;free(__privtrans->zlabel);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plbox3_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plbox3_pp_vtable = {
		0,0, 6, 6, pdl_plbox3_pp_vtable_flags,
		pdl_plbox3_pp_redodims, pdl_plbox3_pp_readdata, NULL,
		pdl_plbox3_pp_free,NULL,NULL,pdl_plbox3_pp_copy,NULL,
		sizeof(pdl_plbox3_pp_struct),"pdl_plbox3_pp_vtable",
		NULL
	 };

typedef struct pdl_plcol0_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plcol0_struct;

void pdl_plcol0_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol0_struct *__privtrans = (pdl_plcol0_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"icolzero"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plcol0";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plcol0_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol0_struct *__privtrans = (pdl_plcol0_struct *) __tr;
	
	{
	    pdl_plcol0_struct *__copy = malloc(sizeof(pdl_plcol0_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plcol0_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol0_struct *__privtrans = (pdl_plcol0_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];icolzero_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plcol0_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol0_struct *__privtrans = (pdl_plcol0_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plcol0_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plcol0_vtable = {
		0,0, 1, 1, pdl_plcol0_vtable_flags,
		pdl_plcol0_redodims, pdl_plcol0_readdata, NULL,
		pdl_plcol0_free,NULL,NULL,pdl_plcol0_copy,NULL,
		sizeof(pdl_plcol0_struct),"pdl_plcol0_vtable",
		NULL
	 };

typedef struct pdl_plcol1_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plcol1_struct;

void pdl_plcol1_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol1_struct *__privtrans = (pdl_plcol1_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * colone_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * colone_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"colone"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plcol1";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plcol1_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol1_struct *__privtrans = (pdl_plcol1_struct *) __tr;
	
	{
	    pdl_plcol1_struct *__copy = malloc(sizeof(pdl_plcol1_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plcol1_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol1_struct *__privtrans = (pdl_plcol1_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * colone_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * colone_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];colone_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcol1((colone_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 colone_datap += __tinc0_0;

	 } colone_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} colone_datap -= __tinc1_0 *
     				  __tdims1;
 colone_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plcol1_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plcol1_struct *__privtrans = (pdl_plcol1_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plcol1_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plcol1_vtable = {
		0,0, 1, 1, pdl_plcol1_vtable_flags,
		pdl_plcol1_redodims, pdl_plcol1_readdata, NULL,
		pdl_plcol1_free,NULL,NULL,pdl_plcol1_copy,NULL,
		sizeof(pdl_plcol1_struct),"pdl_plcol1_vtable",
		NULL
	 };

typedef struct pdl_plcpstrm_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plcpstrm_struct;

void pdl_plcpstrm_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plcpstrm_struct *__privtrans = (pdl_plcpstrm_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * iplsr_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * iplsr_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * flags_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * flags_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"iplsr","flags"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plcpstrm";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plcpstrm_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plcpstrm_struct *__privtrans = (pdl_plcpstrm_struct *) __tr;
	
	{
	    pdl_plcpstrm_struct *__copy = malloc(sizeof(pdl_plcpstrm_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plcpstrm_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plcpstrm_struct *__privtrans = (pdl_plcpstrm_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * iplsr_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * iplsr_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * flags_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * flags_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];iplsr_datap += __offsp[0];
flags_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcpstrm((iplsr_datap)[0] PDL_COMMENT("ACCESS()") ,(flags_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 iplsr_datap += __tinc0_0;
flags_datap += __tinc0_1;

	 } iplsr_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
flags_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} iplsr_datap -= __tinc1_0 *
     				  __tdims1;flags_datap -= __tinc1_1 *
     				  __tdims1;
 iplsr_datap -= __offsp[0];
flags_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plcpstrm_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plcpstrm_struct *__privtrans = (pdl_plcpstrm_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plcpstrm_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plcpstrm_vtable = {
		0,0, 2, 2, pdl_plcpstrm_vtable_flags,
		pdl_plcpstrm_redodims, pdl_plcpstrm_readdata, NULL,
		pdl_plcpstrm_free,NULL,NULL,pdl_plcpstrm_copy,NULL,
		sizeof(pdl_plcpstrm_struct),"pdl_plcpstrm_vtable",
		NULL
	 };

typedef struct pdl_pldid2pc_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_xmin_dima;PDL_Long  __inc_ymin_dima;PDL_Long  __inc_xmax_dima;PDL_Long  __inc_ymax_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pldid2pc_struct;

void pdl_pldid2pc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pldid2pc_struct *__privtrans = (pdl_pldid2pc_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_ymax_dima = __privtrans->__inc_ymax_dima;
register PDL_Long __inc_ymin_dima = __privtrans->__inc_ymin_dima;
register PDL_Long __inc_xmax_dima = __privtrans->__inc_xmax_dima;
register PDL_Long __inc_xmin_dima = __privtrans->__inc_xmin_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","ymin","xmax","ymax"};
		static int __realdims[] = {1,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::pldid2pc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldid2pc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldid2pc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldid2pc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldid2pc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xmin_dima = 0; else
		 __privtrans->__inc_xmin_dima = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ymin_dima = 0; else
		 __privtrans->__inc_ymin_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_xmax_dima = 0; else
		 __privtrans->__inc_xmax_dima = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_ymax_dima = 0; else
		 __privtrans->__inc_ymax_dima = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pldid2pc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pldid2pc_struct *__privtrans = (pdl_pldid2pc_struct *) __tr;
	
	{
	    pdl_pldid2pc_struct *__copy = malloc(sizeof(pdl_pldid2pc_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xmin_dima=__copy->__inc_xmin_dima;__privtrans->__inc_ymin_dima=__copy->__inc_ymin_dima;__privtrans->__inc_xmax_dima=__copy->__inc_xmax_dima;__privtrans->__inc_ymax_dima=__copy->__inc_ymax_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pldid2pc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pldid2pc_struct *__privtrans = (pdl_pldid2pc_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
ymin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_ymax_dima = __privtrans->__inc_ymax_dima;
register PDL_Long __inc_ymin_dima = __privtrans->__inc_ymin_dima;
register PDL_Long __inc_xmax_dima = __privtrans->__inc_xmax_dima;
register PDL_Long __inc_xmin_dima = __privtrans->__inc_xmin_dima;

pldid2pc(xmin_datap,ymin_datap,xmax_datap,ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
ymin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ymin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;ymin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
ymin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pldid2pc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pldid2pc_struct *__privtrans = (pdl_pldid2pc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_pldid2pc_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_pldid2pc_vtable = {
		0,0, 4, 4, pdl_pldid2pc_vtable_flags,
		pdl_pldid2pc_redodims, pdl_pldid2pc_readdata, NULL,
		pdl_pldid2pc_free,NULL,NULL,pdl_pldid2pc_copy,NULL,
		sizeof(pdl_pldid2pc_struct),"pdl_pldid2pc_vtable",
		NULL
	 };

typedef struct pdl_pldip2dc_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_xmin_dima;PDL_Long  __inc_ymin_dima;PDL_Long  __inc_xmax_dima;PDL_Long  __inc_ymax_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pldip2dc_struct;

void pdl_pldip2dc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pldip2dc_struct *__privtrans = (pdl_pldip2dc_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_ymax_dima = __privtrans->__inc_ymax_dima;
register PDL_Long __inc_ymin_dima = __privtrans->__inc_ymin_dima;
register PDL_Long __inc_xmax_dima = __privtrans->__inc_xmax_dima;
register PDL_Long __inc_xmin_dima = __privtrans->__inc_xmin_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","ymin","xmax","ymax"};
		static int __realdims[] = {1,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::pldip2dc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldip2dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldip2dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldip2dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pldip2dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xmin_dima = 0; else
		 __privtrans->__inc_xmin_dima = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ymin_dima = 0; else
		 __privtrans->__inc_ymin_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_xmax_dima = 0; else
		 __privtrans->__inc_xmax_dima = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_ymax_dima = 0; else
		 __privtrans->__inc_ymax_dima = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pldip2dc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pldip2dc_struct *__privtrans = (pdl_pldip2dc_struct *) __tr;
	
	{
	    pdl_pldip2dc_struct *__copy = malloc(sizeof(pdl_pldip2dc_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xmin_dima=__copy->__inc_xmin_dima;__privtrans->__inc_ymin_dima=__copy->__inc_ymin_dima;__privtrans->__inc_xmax_dima=__copy->__inc_xmax_dima;__privtrans->__inc_ymax_dima=__copy->__inc_ymax_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pldip2dc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pldip2dc_struct *__privtrans = (pdl_pldip2dc_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
ymin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_ymax_dima = __privtrans->__inc_ymax_dima;
register PDL_Long __inc_ymin_dima = __privtrans->__inc_ymin_dima;
register PDL_Long __inc_xmax_dima = __privtrans->__inc_xmax_dima;
register PDL_Long __inc_xmin_dima = __privtrans->__inc_xmin_dima;

pldip2dc(xmin_datap,ymin_datap,xmax_datap,ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
ymin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ymin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;ymin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
ymin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pldip2dc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pldip2dc_struct *__privtrans = (pdl_pldip2dc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_pldip2dc_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_pldip2dc_vtable = {
		0,0, 4, 4, pdl_pldip2dc_vtable_flags,
		pdl_pldip2dc_redodims, pdl_pldip2dc_readdata, NULL,
		pdl_pldip2dc_free,NULL,NULL,pdl_pldip2dc_copy,NULL,
		sizeof(pdl_pldip2dc_struct),"pdl_pldip2dc_vtable",
		NULL
	 };

typedef struct pdl_plenv_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plenv_struct;

void pdl_plenv_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv_struct *__privtrans = (pdl_plenv_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * just_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * just_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * axis_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * axis_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax","just","axis"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plenv";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plenv_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv_struct *__privtrans = (pdl_plenv_struct *) __tr;
	
	{
	    pdl_plenv_struct *__copy = malloc(sizeof(pdl_plenv_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plenv_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv_struct *__privtrans = (pdl_plenv_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * just_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * just_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * axis_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * axis_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];
just_datap += __offsp[4];
axis_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plenv((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") ,(just_datap)[0] PDL_COMMENT("ACCESS()") ,(axis_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;
just_datap += __tinc0_4;
axis_datap += __tinc0_5;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
just_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
axis_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;just_datap -= __tinc1_4 *
     				  __tdims1;axis_datap -= __tinc1_5 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];
just_datap -= __offsp[4];
axis_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plenv_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv_struct *__privtrans = (pdl_plenv_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plenv_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plenv_vtable = {
		0,0, 6, 6, pdl_plenv_vtable_flags,
		pdl_plenv_redodims, pdl_plenv_readdata, NULL,
		pdl_plenv_free,NULL,NULL,pdl_plenv_copy,NULL,
		sizeof(pdl_plenv_struct),"pdl_plenv_vtable",
		NULL
	 };

typedef struct pdl_plenv0_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plenv0_struct;

void pdl_plenv0_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv0_struct *__privtrans = (pdl_plenv0_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * just_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * just_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * axis_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * axis_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax","just","axis"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plenv0";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plenv0_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv0_struct *__privtrans = (pdl_plenv0_struct *) __tr;
	
	{
	    pdl_plenv0_struct *__copy = malloc(sizeof(pdl_plenv0_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plenv0_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv0_struct *__privtrans = (pdl_plenv0_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * just_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * just_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * axis_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * axis_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];
just_datap += __offsp[4];
axis_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plenv0((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") ,(just_datap)[0] PDL_COMMENT("ACCESS()") ,(axis_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;
just_datap += __tinc0_4;
axis_datap += __tinc0_5;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
just_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
axis_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;just_datap -= __tinc1_4 *
     				  __tdims1;axis_datap -= __tinc1_5 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];
just_datap -= __offsp[4];
axis_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plenv0_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plenv0_struct *__privtrans = (pdl_plenv0_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plenv0_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plenv0_vtable = {
		0,0, 6, 6, pdl_plenv0_vtable_flags,
		pdl_plenv0_redodims, pdl_plenv0_readdata, NULL,
		pdl_plenv0_free,NULL,NULL,pdl_plenv0_copy,NULL,
		sizeof(pdl_plenv0_struct),"pdl_plenv0_vtable",
		NULL
	 };

typedef struct pdl_plerrx_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_xmin_dima;PDL_Long  __inc_xmax_dima;PDL_Long  __inc_y_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plerrx_struct;

void pdl_plerrx_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plerrx_struct *__privtrans = (pdl_plerrx_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * n_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * n_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_dima = __privtrans->__inc_y_dima;
register PDL_Long __inc_xmax_dima = __privtrans->__inc_xmax_dima;
register PDL_Long __inc_xmin_dima = __privtrans->__inc_xmin_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"n","xmin","xmax","y"};
		static int __realdims[] = {0,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plerrx";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plerrx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plerrx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plerrx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_xmin_dima = 0; else
		 __privtrans->__inc_xmin_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_xmax_dima = 0; else
		 __privtrans->__inc_xmax_dima = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_y_dima = 0; else
		 __privtrans->__inc_y_dima = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plerrx_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plerrx_struct *__privtrans = (pdl_plerrx_struct *) __tr;
	
	{
	    pdl_plerrx_struct *__copy = malloc(sizeof(pdl_plerrx_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xmin_dima=__copy->__inc_xmin_dima;__privtrans->__inc_xmax_dima=__copy->__inc_xmax_dima;__privtrans->__inc_y_dima=__copy->__inc_y_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plerrx_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plerrx_struct *__privtrans = (pdl_plerrx_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * n_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * n_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];n_datap += __offsp[0];
xmin_datap += __offsp[1];
xmax_datap += __offsp[2];
y_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_dima = __privtrans->__inc_y_dima;
register PDL_Long __inc_xmax_dima = __privtrans->__inc_xmax_dima;
register PDL_Long __inc_xmin_dima = __privtrans->__inc_xmin_dima;

c_plerrx((n_datap)[0] PDL_COMMENT("ACCESS()") ,xmin_datap,xmax_datap,y_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 n_datap += __tinc0_0;
xmin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
y_datap += __tinc0_3;

	 } n_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} n_datap -= __tinc1_0 *
     				  __tdims1;xmin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;y_datap -= __tinc1_3 *
     				  __tdims1;
 n_datap -= __offsp[0];
xmin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
y_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plerrx_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plerrx_struct *__privtrans = (pdl_plerrx_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plerrx_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_plerrx_vtable = {
		0,0, 4, 4, pdl_plerrx_vtable_flags,
		pdl_plerrx_redodims, pdl_plerrx_readdata, NULL,
		pdl_plerrx_free,NULL,NULL,pdl_plerrx_copy,NULL,
		sizeof(pdl_plerrx_struct),"pdl_plerrx_vtable",
		NULL
	 };

typedef struct pdl_plerry_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_dima;PDL_Long  __inc_ymin_dima;PDL_Long  __inc_ymax_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plerry_struct;

void pdl_plerry_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plerry_struct *__privtrans = (pdl_plerry_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * n_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * n_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_ymax_dima = __privtrans->__inc_ymax_dima;
register PDL_Long __inc_ymin_dima = __privtrans->__inc_ymin_dima;
register PDL_Long __inc_x_dima = __privtrans->__inc_x_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"n","x","ymin","ymax"};
		static int __realdims[] = {0,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plerry";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plerry:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plerry:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plerry:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_x_dima = 0; else
		 __privtrans->__inc_x_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_ymin_dima = 0; else
		 __privtrans->__inc_ymin_dima = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_ymax_dima = 0; else
		 __privtrans->__inc_ymax_dima = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plerry_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plerry_struct *__privtrans = (pdl_plerry_struct *) __tr;
	
	{
	    pdl_plerry_struct *__copy = malloc(sizeof(pdl_plerry_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_dima=__copy->__inc_x_dima;__privtrans->__inc_ymin_dima=__copy->__inc_ymin_dima;__privtrans->__inc_ymax_dima=__copy->__inc_ymax_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plerry_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plerry_struct *__privtrans = (pdl_plerry_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * n_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * n_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];n_datap += __offsp[0];
x_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_ymax_dima = __privtrans->__inc_ymax_dima;
register PDL_Long __inc_ymin_dima = __privtrans->__inc_ymin_dima;
register PDL_Long __inc_x_dima = __privtrans->__inc_x_dima;

c_plerry((n_datap)[0] PDL_COMMENT("ACCESS()") ,x_datap,ymin_datap,ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 n_datap += __tinc0_0;
x_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } n_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
x_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} n_datap -= __tinc1_0 *
     				  __tdims1;x_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 n_datap -= __offsp[0];
x_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plerry_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plerry_struct *__privtrans = (pdl_plerry_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plerry_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_plerry_vtable = {
		0,0, 4, 4, pdl_plerry_vtable_flags,
		pdl_plerry_redodims, pdl_plerry_readdata, NULL,
		pdl_plerry_free,NULL,NULL,pdl_plerry_copy,NULL,
		sizeof(pdl_plerry_struct),"pdl_plerry_vtable",
		NULL
	 };

typedef struct pdl_plfill3_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_dima;PDL_Long  __inc_y_dima;PDL_Long  __inc_z_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plfill3_struct;

void pdl_plfill3_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill3_struct *__privtrans = (pdl_plfill3_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * n_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * n_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_dima = __privtrans->__inc_y_dima;
register PDL_Long __inc_x_dima = __privtrans->__inc_x_dima;
register PDL_Long __inc_z_dima = __privtrans->__inc_z_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"n","x","y","z"};
		static int __realdims[] = {0,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plfill3";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plfill3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plfill3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plfill3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_x_dima = 0; else
		 __privtrans->__inc_x_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_y_dima = 0; else
		 __privtrans->__inc_y_dima = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_z_dima = 0; else
		 __privtrans->__inc_z_dima = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plfill3_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill3_struct *__privtrans = (pdl_plfill3_struct *) __tr;
	
	{
	    pdl_plfill3_struct *__copy = malloc(sizeof(pdl_plfill3_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_dima=__copy->__inc_x_dima;__privtrans->__inc_y_dima=__copy->__inc_y_dima;__privtrans->__inc_z_dima=__copy->__inc_z_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plfill3_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill3_struct *__privtrans = (pdl_plfill3_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * n_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * n_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];n_datap += __offsp[0];
x_datap += __offsp[1];
y_datap += __offsp[2];
z_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_dima = __privtrans->__inc_y_dima;
register PDL_Long __inc_x_dima = __privtrans->__inc_x_dima;
register PDL_Long __inc_z_dima = __privtrans->__inc_z_dima;

c_plfill3((n_datap)[0] PDL_COMMENT("ACCESS()") ,x_datap,y_datap,z_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 n_datap += __tinc0_0;
x_datap += __tinc0_1;
y_datap += __tinc0_2;
z_datap += __tinc0_3;

	 } n_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
x_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
y_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
z_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} n_datap -= __tinc1_0 *
     				  __tdims1;x_datap -= __tinc1_1 *
     				  __tdims1;y_datap -= __tinc1_2 *
     				  __tdims1;z_datap -= __tinc1_3 *
     				  __tdims1;
 n_datap -= __offsp[0];
x_datap -= __offsp[1];
y_datap -= __offsp[2];
z_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plfill3_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill3_struct *__privtrans = (pdl_plfill3_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plfill3_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_plfill3_vtable = {
		0,0, 4, 4, pdl_plfill3_vtable_flags,
		pdl_plfill3_redodims, pdl_plfill3_readdata, NULL,
		pdl_plfill3_free,NULL,NULL,pdl_plfill3_copy,NULL,
		sizeof(pdl_plfill3_struct),"pdl_plfill3_vtable",
		NULL
	 };

typedef struct pdl_plfont_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plfont_struct;

void pdl_plfont_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plfont_struct *__privtrans = (pdl_plfont_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ifont_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ifont_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ifont"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plfont";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plfont_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plfont_struct *__privtrans = (pdl_plfont_struct *) __tr;
	
	{
	    pdl_plfont_struct *__copy = malloc(sizeof(pdl_plfont_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plfont_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plfont_struct *__privtrans = (pdl_plfont_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ifont_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ifont_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];ifont_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plfont((ifont_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 ifont_datap += __tinc0_0;

	 } ifont_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} ifont_datap -= __tinc1_0 *
     				  __tdims1;
 ifont_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plfont_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plfont_struct *__privtrans = (pdl_plfont_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plfont_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plfont_vtable = {
		0,0, 1, 1, pdl_plfont_vtable_flags,
		pdl_plfont_redodims, pdl_plfont_readdata, NULL,
		pdl_plfont_free,NULL,NULL,pdl_plfont_copy,NULL,
		sizeof(pdl_plfont_struct),"pdl_plfont_vtable",
		NULL
	 };

typedef struct pdl_plfontld_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plfontld_struct;

void pdl_plfontld_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plfontld_struct *__privtrans = (pdl_plfontld_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * fnt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * fnt_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"fnt"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plfontld";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plfontld_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plfontld_struct *__privtrans = (pdl_plfontld_struct *) __tr;
	
	{
	    pdl_plfontld_struct *__copy = malloc(sizeof(pdl_plfontld_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plfontld_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plfontld_struct *__privtrans = (pdl_plfontld_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * fnt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * fnt_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];fnt_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plfontld((fnt_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 fnt_datap += __tinc0_0;

	 } fnt_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} fnt_datap -= __tinc1_0 *
     				  __tdims1;
 fnt_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plfontld_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plfontld_struct *__privtrans = (pdl_plfontld_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plfontld_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plfontld_vtable = {
		0,0, 1, 1, pdl_plfontld_vtable_flags,
		pdl_plfontld_redodims, pdl_plfontld_readdata, NULL,
		pdl_plfontld_free,NULL,NULL,pdl_plfontld_copy,NULL,
		sizeof(pdl_plfontld_struct),"pdl_plfontld_vtable",
		NULL
	 };

typedef struct pdl_plgchr_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgchr_struct;

void pdl_plgchr_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgchr_struct *__privtrans = (pdl_plgchr_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_ht_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_ht_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_def","p_ht"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgchr";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgchr_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgchr_struct *__privtrans = (pdl_plgchr_struct *) __tr;
	
	{
	    pdl_plgchr_struct *__copy = malloc(sizeof(pdl_plgchr_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgchr_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgchr_struct *__privtrans = (pdl_plgchr_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_ht_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_ht_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];p_def_datap += __offsp[0];
p_ht_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgchr(p_def_datap,p_ht_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_def_datap += __tinc0_0;
p_ht_datap += __tinc0_1;

	 } p_def_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_ht_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} p_def_datap -= __tinc1_0 *
     				  __tdims1;p_ht_datap -= __tinc1_1 *
     				  __tdims1;
 p_def_datap -= __offsp[0];
p_ht_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgchr_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgchr_struct *__privtrans = (pdl_plgchr_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgchr_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plgchr_vtable = {
		0,0, 0, 2, pdl_plgchr_vtable_flags,
		pdl_plgchr_redodims, pdl_plgchr_readdata, NULL,
		pdl_plgchr_free,NULL,NULL,pdl_plgchr_copy,NULL,
		sizeof(pdl_plgchr_struct),"pdl_plgchr_vtable",
		NULL
	 };

typedef struct pdl_plgcompression_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgcompression_struct;

void pdl_plgcompression_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcompression_struct *__privtrans = (pdl_plgcompression_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * compression_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * compression_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"compression"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgcompression";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgcompression_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcompression_struct *__privtrans = (pdl_plgcompression_struct *) __tr;
	
	{
	    pdl_plgcompression_struct *__copy = malloc(sizeof(pdl_plgcompression_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgcompression_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcompression_struct *__privtrans = (pdl_plgcompression_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * compression_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * compression_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];compression_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcompression(compression_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 compression_datap += __tinc0_0;

	 } compression_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} compression_datap -= __tinc1_0 *
     				  __tdims1;
 compression_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgcompression_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcompression_struct *__privtrans = (pdl_plgcompression_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgcompression_vtable_flags[] =
	 	{ 0};
	 pdl_transvtable pdl_plgcompression_vtable = {
		0,0, 0, 1, pdl_plgcompression_vtable_flags,
		pdl_plgcompression_redodims, pdl_plgcompression_readdata, NULL,
		pdl_plgcompression_free,NULL,NULL,pdl_plgcompression_copy,NULL,
		sizeof(pdl_plgcompression_struct),"pdl_plgcompression_vtable",
		NULL
	 };

typedef struct pdl_plgdidev_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgdidev_struct;

void pdl_plgdidev_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdidev_struct *__privtrans = (pdl_plgdidev_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_mar_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_mar_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_jx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_jx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_jy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_jy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_mar","p_aspect","p_jx","p_jy"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgdidev";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgdidev_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdidev_struct *__privtrans = (pdl_plgdidev_struct *) __tr;
	
	{
	    pdl_plgdidev_struct *__copy = malloc(sizeof(pdl_plgdidev_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgdidev_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdidev_struct *__privtrans = (pdl_plgdidev_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_mar_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_mar_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_jx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_jx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_jy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_jy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];p_mar_datap += __offsp[0];
p_aspect_datap += __offsp[1];
p_jx_datap += __offsp[2];
p_jy_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgdidev(p_mar_datap,p_aspect_datap,p_jx_datap,p_jy_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_mar_datap += __tinc0_0;
p_aspect_datap += __tinc0_1;
p_jx_datap += __tinc0_2;
p_jy_datap += __tinc0_3;

	 } p_mar_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_aspect_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_jx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
p_jy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} p_mar_datap -= __tinc1_0 *
     				  __tdims1;p_aspect_datap -= __tinc1_1 *
     				  __tdims1;p_jx_datap -= __tinc1_2 *
     				  __tdims1;p_jy_datap -= __tinc1_3 *
     				  __tdims1;
 p_mar_datap -= __offsp[0];
p_aspect_datap -= __offsp[1];
p_jx_datap -= __offsp[2];
p_jy_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgdidev_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdidev_struct *__privtrans = (pdl_plgdidev_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgdidev_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plgdidev_vtable = {
		0,0, 0, 4, pdl_plgdidev_vtable_flags,
		pdl_plgdidev_redodims, pdl_plgdidev_readdata, NULL,
		pdl_plgdidev_free,NULL,NULL,pdl_plgdidev_copy,NULL,
		sizeof(pdl_plgdidev_struct),"pdl_plgdidev_vtable",
		NULL
	 };

typedef struct pdl_plgdiori_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgdiori_struct;

void pdl_plgdiori_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiori_struct *__privtrans = (pdl_plgdiori_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_rot_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_rot_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_rot"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgdiori";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgdiori_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiori_struct *__privtrans = (pdl_plgdiori_struct *) __tr;
	
	{
	    pdl_plgdiori_struct *__copy = malloc(sizeof(pdl_plgdiori_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgdiori_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiori_struct *__privtrans = (pdl_plgdiori_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_rot_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_rot_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];p_rot_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgdiori(p_rot_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_rot_datap += __tinc0_0;

	 } p_rot_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} p_rot_datap -= __tinc1_0 *
     				  __tdims1;
 p_rot_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgdiori_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiori_struct *__privtrans = (pdl_plgdiori_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgdiori_vtable_flags[] =
	 	{ 0};
	 pdl_transvtable pdl_plgdiori_vtable = {
		0,0, 0, 1, pdl_plgdiori_vtable_flags,
		pdl_plgdiori_redodims, pdl_plgdiori_readdata, NULL,
		pdl_plgdiori_free,NULL,NULL,pdl_plgdiori_copy,NULL,
		sizeof(pdl_plgdiori_struct),"pdl_plgdiori_vtable",
		NULL
	 };

typedef struct pdl_plgdiplt_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgdiplt_struct;

void pdl_plgdiplt_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiplt_struct *__privtrans = (pdl_plgdiplt_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_xmin","p_ymin","p_xmax","p_ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgdiplt";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgdiplt_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiplt_struct *__privtrans = (pdl_plgdiplt_struct *) __tr;
	
	{
	    pdl_plgdiplt_struct *__copy = malloc(sizeof(pdl_plgdiplt_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgdiplt_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiplt_struct *__privtrans = (pdl_plgdiplt_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];p_xmin_datap += __offsp[0];
p_ymin_datap += __offsp[1];
p_xmax_datap += __offsp[2];
p_ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgdiplt(p_xmin_datap,p_ymin_datap,p_xmax_datap,p_ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_xmin_datap += __tinc0_0;
p_ymin_datap += __tinc0_1;
p_xmax_datap += __tinc0_2;
p_ymax_datap += __tinc0_3;

	 } p_xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_ymin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
p_ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} p_xmin_datap -= __tinc1_0 *
     				  __tdims1;p_ymin_datap -= __tinc1_1 *
     				  __tdims1;p_xmax_datap -= __tinc1_2 *
     				  __tdims1;p_ymax_datap -= __tinc1_3 *
     				  __tdims1;
 p_xmin_datap -= __offsp[0];
p_ymin_datap -= __offsp[1];
p_xmax_datap -= __offsp[2];
p_ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgdiplt_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgdiplt_struct *__privtrans = (pdl_plgdiplt_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgdiplt_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plgdiplt_vtable = {
		0,0, 0, 4, pdl_plgdiplt_vtable_flags,
		pdl_plgdiplt_redodims, pdl_plgdiplt_readdata, NULL,
		pdl_plgdiplt_free,NULL,NULL,pdl_plgdiplt_copy,NULL,
		sizeof(pdl_plgdiplt_struct),"pdl_plgdiplt_vtable",
		NULL
	 };

typedef struct pdl_plgfam_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgfam_struct;

void pdl_plgfam_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfam_struct *__privtrans = (pdl_plgfam_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_fam_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_fam_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_num_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_num_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_bmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_bmax_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_fam","p_num","p_bmax"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgfam";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgfam_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfam_struct *__privtrans = (pdl_plgfam_struct *) __tr;
	
	{
	    pdl_plgfam_struct *__copy = malloc(sizeof(pdl_plgfam_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgfam_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfam_struct *__privtrans = (pdl_plgfam_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_fam_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_fam_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_num_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_num_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_bmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_bmax_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_fam_datap += __offsp[0];
p_num_datap += __offsp[1];
p_bmax_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfam(p_fam_datap,p_num_datap,p_bmax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_fam_datap += __tinc0_0;
p_num_datap += __tinc0_1;
p_bmax_datap += __tinc0_2;

	 } p_fam_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_num_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_bmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_fam_datap -= __tinc1_0 *
     				  __tdims1;p_num_datap -= __tinc1_1 *
     				  __tdims1;p_bmax_datap -= __tinc1_2 *
     				  __tdims1;
 p_fam_datap -= __offsp[0];
p_num_datap -= __offsp[1];
p_bmax_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgfam_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfam_struct *__privtrans = (pdl_plgfam_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgfam_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plgfam_vtable = {
		0,0, 0, 3, pdl_plgfam_vtable_flags,
		pdl_plgfam_redodims, pdl_plgfam_readdata, NULL,
		pdl_plgfam_free,NULL,NULL,pdl_plgfam_copy,NULL,
		sizeof(pdl_plgfam_struct),"pdl_plgfam_vtable",
		NULL
	 };

typedef struct pdl_plglevel_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plglevel_struct;

void pdl_plglevel_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plglevel_struct *__privtrans = (pdl_plglevel_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_level_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_level_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_level"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plglevel";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plglevel_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plglevel_struct *__privtrans = (pdl_plglevel_struct *) __tr;
	
	{
	    pdl_plglevel_struct *__copy = malloc(sizeof(pdl_plglevel_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plglevel_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plglevel_struct *__privtrans = (pdl_plglevel_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_level_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_level_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];p_level_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plglevel(p_level_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_level_datap += __tinc0_0;

	 } p_level_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} p_level_datap -= __tinc1_0 *
     				  __tdims1;
 p_level_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plglevel_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plglevel_struct *__privtrans = (pdl_plglevel_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plglevel_vtable_flags[] =
	 	{ 0};
	 pdl_transvtable pdl_plglevel_vtable = {
		0,0, 0, 1, pdl_plglevel_vtable_flags,
		pdl_plglevel_redodims, pdl_plglevel_readdata, NULL,
		pdl_plglevel_free,NULL,NULL,pdl_plglevel_copy,NULL,
		sizeof(pdl_plglevel_struct),"pdl_plglevel_vtable",
		NULL
	 };

typedef struct pdl_plgpage_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgpage_struct;

void pdl_plgpage_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgpage_struct *__privtrans = (pdl_plgpage_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_yp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_yp_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * p_xleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_xleng_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * p_yleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * p_yleng_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * p_xoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * p_xoff_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * p_yoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * p_yoff_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_xp","p_yp","p_xleng","p_yleng","p_xoff","p_yoff"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgpage";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgpage_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgpage_struct *__privtrans = (pdl_plgpage_struct *) __tr;
	
	{
	    pdl_plgpage_struct *__copy = malloc(sizeof(pdl_plgpage_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgpage_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgpage_struct *__privtrans = (pdl_plgpage_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_yp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_yp_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * p_xleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_xleng_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * p_yleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * p_yleng_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * p_xoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * p_xoff_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * p_yoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * p_yoff_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];p_xp_datap += __offsp[0];
p_yp_datap += __offsp[1];
p_xleng_datap += __offsp[2];
p_yleng_datap += __offsp[3];
p_xoff_datap += __offsp[4];
p_yoff_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgpage(p_xp_datap,p_yp_datap,p_xleng_datap,p_yleng_datap,p_xoff_datap,p_yoff_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_xp_datap += __tinc0_0;
p_yp_datap += __tinc0_1;
p_xleng_datap += __tinc0_2;
p_yleng_datap += __tinc0_3;
p_xoff_datap += __tinc0_4;
p_yoff_datap += __tinc0_5;

	 } p_xp_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_yp_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_xleng_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
p_yleng_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
p_xoff_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
p_yoff_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} p_xp_datap -= __tinc1_0 *
     				  __tdims1;p_yp_datap -= __tinc1_1 *
     				  __tdims1;p_xleng_datap -= __tinc1_2 *
     				  __tdims1;p_yleng_datap -= __tinc1_3 *
     				  __tdims1;p_xoff_datap -= __tinc1_4 *
     				  __tdims1;p_yoff_datap -= __tinc1_5 *
     				  __tdims1;
 p_xp_datap -= __offsp[0];
p_yp_datap -= __offsp[1];
p_xleng_datap -= __offsp[2];
p_yleng_datap -= __offsp[3];
p_xoff_datap -= __offsp[4];
p_yoff_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgpage_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgpage_struct *__privtrans = (pdl_plgpage_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgpage_vtable_flags[] =
	 	{ 0,0,0,0,0,0};
	 pdl_transvtable pdl_plgpage_vtable = {
		0,0, 0, 6, pdl_plgpage_vtable_flags,
		pdl_plgpage_redodims, pdl_plgpage_readdata, NULL,
		pdl_plgpage_free,NULL,NULL,pdl_plgpage_copy,NULL,
		sizeof(pdl_plgpage_struct),"pdl_plgpage_vtable",
		NULL
	 };

typedef struct pdl_plgspa_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgspa_struct;

void pdl_plgspa_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgspa_struct *__privtrans = (pdl_plgspa_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgspa";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgspa_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgspa_struct *__privtrans = (pdl_plgspa_struct *) __tr;
	
	{
	    pdl_plgspa_struct *__copy = malloc(sizeof(pdl_plgspa_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgspa_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgspa_struct *__privtrans = (pdl_plgspa_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgspa(xmin_datap,xmax_datap,ymin_datap,ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgspa_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgspa_struct *__privtrans = (pdl_plgspa_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgspa_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plgspa_vtable = {
		0,0, 0, 4, pdl_plgspa_vtable_flags,
		pdl_plgspa_redodims, pdl_plgspa_readdata, NULL,
		pdl_plgspa_free,NULL,NULL,pdl_plgspa_copy,NULL,
		sizeof(pdl_plgspa_struct),"pdl_plgspa_vtable",
		NULL
	 };

typedef struct pdl_plgvpd_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgvpd_struct;

void pdl_plgvpd_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpd_struct *__privtrans = (pdl_plgvpd_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_xmin","p_xmax","p_ymin","p_ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgvpd";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgvpd_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpd_struct *__privtrans = (pdl_plgvpd_struct *) __tr;
	
	{
	    pdl_plgvpd_struct *__copy = malloc(sizeof(pdl_plgvpd_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgvpd_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpd_struct *__privtrans = (pdl_plgvpd_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];p_xmin_datap += __offsp[0];
p_xmax_datap += __offsp[1];
p_ymin_datap += __offsp[2];
p_ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgvpd(p_xmin_datap,p_xmax_datap,p_ymin_datap,p_ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_xmin_datap += __tinc0_0;
p_xmax_datap += __tinc0_1;
p_ymin_datap += __tinc0_2;
p_ymax_datap += __tinc0_3;

	 } p_xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
p_ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} p_xmin_datap -= __tinc1_0 *
     				  __tdims1;p_xmax_datap -= __tinc1_1 *
     				  __tdims1;p_ymin_datap -= __tinc1_2 *
     				  __tdims1;p_ymax_datap -= __tinc1_3 *
     				  __tdims1;
 p_xmin_datap -= __offsp[0];
p_xmax_datap -= __offsp[1];
p_ymin_datap -= __offsp[2];
p_ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgvpd_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpd_struct *__privtrans = (pdl_plgvpd_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgvpd_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plgvpd_vtable = {
		0,0, 0, 4, pdl_plgvpd_vtable_flags,
		pdl_plgvpd_redodims, pdl_plgvpd_readdata, NULL,
		pdl_plgvpd_free,NULL,NULL,pdl_plgvpd_copy,NULL,
		sizeof(pdl_plgvpd_struct),"pdl_plgvpd_vtable",
		NULL
	 };

typedef struct pdl_plgvpw_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgvpw_struct;

void pdl_plgvpw_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpw_struct *__privtrans = (pdl_plgvpw_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_xmin","p_xmax","p_ymin","p_ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgvpw";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgvpw_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpw_struct *__privtrans = (pdl_plgvpw_struct *) __tr;
	
	{
	    pdl_plgvpw_struct *__copy = malloc(sizeof(pdl_plgvpw_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgvpw_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpw_struct *__privtrans = (pdl_plgvpw_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * p_ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * p_ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];p_xmin_datap += __offsp[0];
p_xmax_datap += __offsp[1];
p_ymin_datap += __offsp[2];
p_ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgvpw(p_xmin_datap,p_xmax_datap,p_ymin_datap,p_ymax_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_xmin_datap += __tinc0_0;
p_xmax_datap += __tinc0_1;
p_ymin_datap += __tinc0_2;
p_ymax_datap += __tinc0_3;

	 } p_xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
p_ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} p_xmin_datap -= __tinc1_0 *
     				  __tdims1;p_xmax_datap -= __tinc1_1 *
     				  __tdims1;p_ymin_datap -= __tinc1_2 *
     				  __tdims1;p_ymax_datap -= __tinc1_3 *
     				  __tdims1;
 p_xmin_datap -= __offsp[0];
p_xmax_datap -= __offsp[1];
p_ymin_datap -= __offsp[2];
p_ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgvpw_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgvpw_struct *__privtrans = (pdl_plgvpw_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgvpw_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plgvpw_vtable = {
		0,0, 0, 4, pdl_plgvpw_vtable_flags,
		pdl_plgvpw_redodims, pdl_plgvpw_readdata, NULL,
		pdl_plgvpw_free,NULL,NULL,pdl_plgvpw_copy,NULL,
		sizeof(pdl_plgvpw_struct),"pdl_plgvpw_vtable",
		NULL
	 };

typedef struct pdl_plgxax_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgxax_struct;

void pdl_plgxax_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgxax_struct *__privtrans = (pdl_plgxax_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_digmax","p_digits"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgxax";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgxax_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgxax_struct *__privtrans = (pdl_plgxax_struct *) __tr;
	
	{
	    pdl_plgxax_struct *__copy = malloc(sizeof(pdl_plgxax_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgxax_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgxax_struct *__privtrans = (pdl_plgxax_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];p_digmax_datap += __offsp[0];
p_digits_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgxax(p_digmax_datap,p_digits_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_digmax_datap += __tinc0_0;
p_digits_datap += __tinc0_1;

	 } p_digmax_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_digits_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} p_digmax_datap -= __tinc1_0 *
     				  __tdims1;p_digits_datap -= __tinc1_1 *
     				  __tdims1;
 p_digmax_datap -= __offsp[0];
p_digits_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgxax_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgxax_struct *__privtrans = (pdl_plgxax_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgxax_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plgxax_vtable = {
		0,0, 0, 2, pdl_plgxax_vtable_flags,
		pdl_plgxax_redodims, pdl_plgxax_readdata, NULL,
		pdl_plgxax_free,NULL,NULL,pdl_plgxax_copy,NULL,
		sizeof(pdl_plgxax_struct),"pdl_plgxax_vtable",
		NULL
	 };

typedef struct pdl_plgyax_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgyax_struct;

void pdl_plgyax_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgyax_struct *__privtrans = (pdl_plgyax_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_digmax","p_digits"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgyax";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgyax_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgyax_struct *__privtrans = (pdl_plgyax_struct *) __tr;
	
	{
	    pdl_plgyax_struct *__copy = malloc(sizeof(pdl_plgyax_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgyax_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgyax_struct *__privtrans = (pdl_plgyax_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];p_digmax_datap += __offsp[0];
p_digits_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgyax(p_digmax_datap,p_digits_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_digmax_datap += __tinc0_0;
p_digits_datap += __tinc0_1;

	 } p_digmax_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_digits_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} p_digmax_datap -= __tinc1_0 *
     				  __tdims1;p_digits_datap -= __tinc1_1 *
     				  __tdims1;
 p_digmax_datap -= __offsp[0];
p_digits_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgyax_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgyax_struct *__privtrans = (pdl_plgyax_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgyax_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plgyax_vtable = {
		0,0, 0, 2, pdl_plgyax_vtable_flags,
		pdl_plgyax_redodims, pdl_plgyax_readdata, NULL,
		pdl_plgyax_free,NULL,NULL,pdl_plgyax_copy,NULL,
		sizeof(pdl_plgyax_struct),"pdl_plgyax_vtable",
		NULL
	 };

typedef struct pdl_plgzax_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgzax_struct;

void pdl_plgzax_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgzax_struct *__privtrans = (pdl_plgzax_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_digmax","p_digits"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgzax";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgzax_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgzax_struct *__privtrans = (pdl_plgzax_struct *) __tr;
	
	{
	    pdl_plgzax_struct *__copy = malloc(sizeof(pdl_plgzax_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgzax_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgzax_struct *__privtrans = (pdl_plgzax_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * p_digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];p_digmax_datap += __offsp[0];
p_digits_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgzax(p_digmax_datap,p_digits_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_digmax_datap += __tinc0_0;
p_digits_datap += __tinc0_1;

	 } p_digmax_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_digits_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} p_digmax_datap -= __tinc1_0 *
     				  __tdims1;p_digits_datap -= __tinc1_1 *
     				  __tdims1;
 p_digmax_datap -= __offsp[0];
p_digits_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgzax_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgzax_struct *__privtrans = (pdl_plgzax_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgzax_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plgzax_vtable = {
		0,0, 0, 2, pdl_plgzax_vtable_flags,
		pdl_plgzax_redodims, pdl_plgzax_readdata, NULL,
		pdl_plgzax_free,NULL,NULL,pdl_plgzax_copy,NULL,
		sizeof(pdl_plgzax_struct),"pdl_plgzax_vtable",
		NULL
	 };

typedef struct pdl_pljoin_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pljoin_struct;

void pdl_pljoin_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pljoin_struct *__privtrans = (pdl_pljoin_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xone_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xone_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yone_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yone_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xtwo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xtwo_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ytwo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ytwo_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xone","yone","xtwo","ytwo"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::pljoin";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pljoin_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pljoin_struct *__privtrans = (pdl_pljoin_struct *) __tr;
	
	{
	    pdl_pljoin_struct *__copy = malloc(sizeof(pdl_pljoin_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pljoin_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pljoin_struct *__privtrans = (pdl_pljoin_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xone_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xone_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yone_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yone_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xtwo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xtwo_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ytwo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ytwo_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xone_datap += __offsp[0];
yone_datap += __offsp[1];
xtwo_datap += __offsp[2];
ytwo_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_pljoin((xone_datap)[0] PDL_COMMENT("ACCESS()") ,(yone_datap)[0] PDL_COMMENT("ACCESS()") ,(xtwo_datap)[0] PDL_COMMENT("ACCESS()") ,(ytwo_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xone_datap += __tinc0_0;
yone_datap += __tinc0_1;
xtwo_datap += __tinc0_2;
ytwo_datap += __tinc0_3;

	 } xone_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yone_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xtwo_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ytwo_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xone_datap -= __tinc1_0 *
     				  __tdims1;yone_datap -= __tinc1_1 *
     				  __tdims1;xtwo_datap -= __tinc1_2 *
     				  __tdims1;ytwo_datap -= __tinc1_3 *
     				  __tdims1;
 xone_datap -= __offsp[0];
yone_datap -= __offsp[1];
xtwo_datap -= __offsp[2];
ytwo_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pljoin_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pljoin_struct *__privtrans = (pdl_pljoin_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_pljoin_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pljoin_vtable = {
		0,0, 4, 4, pdl_pljoin_vtable_flags,
		pdl_pljoin_redodims, pdl_pljoin_readdata, NULL,
		pdl_pljoin_free,NULL,NULL,pdl_pljoin_copy,NULL,
		sizeof(pdl_pljoin_struct),"pdl_pljoin_vtable",
		NULL
	 };

typedef struct pdl_pllightsource_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pllightsource_struct;

void pdl_pllightsource_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pllightsource_struct *__privtrans = (pdl_pllightsource_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::pllightsource";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pllightsource_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pllightsource_struct *__privtrans = (pdl_pllightsource_struct *) __tr;
	
	{
	    pdl_pllightsource_struct *__copy = malloc(sizeof(pdl_pllightsource_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pllightsource_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pllightsource_struct *__privtrans = (pdl_pllightsource_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_pllightsource((x_datap)[0] PDL_COMMENT("ACCESS()") ,(y_datap)[0] PDL_COMMENT("ACCESS()") ,(z_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pllightsource_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pllightsource_struct *__privtrans = (pdl_pllightsource_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_pllightsource_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pllightsource_vtable = {
		0,0, 3, 3, pdl_pllightsource_vtable_flags,
		pdl_pllightsource_redodims, pdl_pllightsource_readdata, NULL,
		pdl_pllightsource_free,NULL,NULL,pdl_pllightsource_copy,NULL,
		sizeof(pdl_pllightsource_struct),"pdl_pllightsource_vtable",
		NULL
	 };

typedef struct pdl_pllsty_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pllsty_struct;

void pdl_pllsty_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pllsty_struct *__privtrans = (pdl_pllsty_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * lin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * lin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"lin"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::pllsty";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pllsty_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pllsty_struct *__privtrans = (pdl_pllsty_struct *) __tr;
	
	{
	    pdl_pllsty_struct *__copy = malloc(sizeof(pdl_pllsty_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pllsty_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pllsty_struct *__privtrans = (pdl_pllsty_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * lin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * lin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];lin_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_pllsty((lin_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 lin_datap += __tinc0_0;

	 } lin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} lin_datap -= __tinc1_0 *
     				  __tdims1;
 lin_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pllsty_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pllsty_struct *__privtrans = (pdl_pllsty_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_pllsty_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pllsty_vtable = {
		0,0, 1, 1, pdl_pllsty_vtable_flags,
		pdl_pllsty_redodims, pdl_pllsty_readdata, NULL,
		pdl_pllsty_free,NULL,NULL,pdl_pllsty_copy,NULL,
		sizeof(pdl_pllsty_struct),"pdl_pllsty_vtable",
		NULL
	 };

typedef struct pdl_plmtex_pp_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		char  *side;char  *text;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plmtex_pp_struct;

void pdl_plmtex_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex_pp_struct *__privtrans = (pdl_plmtex_pp_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * disp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * disp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * pos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * pos_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"disp","pos","just"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plmtex_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plmtex_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex_pp_struct *__privtrans = (pdl_plmtex_pp_struct *) __tr;
	
	{
	    pdl_plmtex_pp_struct *__copy = malloc(sizeof(pdl_plmtex_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->side) = malloc(strlen(__privtrans->side)+1); strcpy(__copy->side,__privtrans->side);;(__copy->text) = malloc(strlen(__privtrans->text)+1); strcpy(__copy->text,__privtrans->text);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plmtex_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex_pp_struct *__privtrans = (pdl_plmtex_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * disp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * disp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * pos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * pos_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];disp_datap += __offsp[0];
pos_datap += __offsp[1];
just_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plmtex(__privtrans->side,(disp_datap)[0] PDL_COMMENT("ACCESS()") ,(pos_datap)[0] PDL_COMMENT("ACCESS()") ,(just_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->text);
}	PDL_COMMENT("THREADLOOPEND")
	 disp_datap += __tinc0_0;
pos_datap += __tinc0_1;
just_datap += __tinc0_2;

	 } disp_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
pos_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
just_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} disp_datap -= __tinc1_0 *
     				  __tdims1;pos_datap -= __tinc1_1 *
     				  __tdims1;just_datap -= __tinc1_2 *
     				  __tdims1;
 disp_datap -= __offsp[0];
pos_datap -= __offsp[1];
just_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plmtex_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex_pp_struct *__privtrans = (pdl_plmtex_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->side);;free(__privtrans->text);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plmtex_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plmtex_pp_vtable = {
		0,0, 3, 3, pdl_plmtex_pp_vtable_flags,
		pdl_plmtex_pp_redodims, pdl_plmtex_pp_readdata, NULL,
		pdl_plmtex_pp_free,NULL,NULL,pdl_plmtex_pp_copy,NULL,
		sizeof(pdl_plmtex_pp_struct),"pdl_plmtex_pp_vtable",
		NULL
	 };

typedef struct pdl_plmtex3_pp_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		char  *side;char  *text;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plmtex3_pp_struct;

void pdl_plmtex3_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex3_pp_struct *__privtrans = (pdl_plmtex3_pp_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * disp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * disp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * pos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * pos_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"disp","pos","just"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plmtex3_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plmtex3_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex3_pp_struct *__privtrans = (pdl_plmtex3_pp_struct *) __tr;
	
	{
	    pdl_plmtex3_pp_struct *__copy = malloc(sizeof(pdl_plmtex3_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->side) = malloc(strlen(__privtrans->side)+1); strcpy(__copy->side,__privtrans->side);;(__copy->text) = malloc(strlen(__privtrans->text)+1); strcpy(__copy->text,__privtrans->text);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plmtex3_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex3_pp_struct *__privtrans = (pdl_plmtex3_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * disp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * disp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * pos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * pos_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];disp_datap += __offsp[0];
pos_datap += __offsp[1];
just_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plmtex3(__privtrans->side,(disp_datap)[0] PDL_COMMENT("ACCESS()") ,(pos_datap)[0] PDL_COMMENT("ACCESS()") ,(just_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->text);
}	PDL_COMMENT("THREADLOOPEND")
	 disp_datap += __tinc0_0;
pos_datap += __tinc0_1;
just_datap += __tinc0_2;

	 } disp_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
pos_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
just_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} disp_datap -= __tinc1_0 *
     				  __tdims1;pos_datap -= __tinc1_1 *
     				  __tdims1;just_datap -= __tinc1_2 *
     				  __tdims1;
 disp_datap -= __offsp[0];
pos_datap -= __offsp[1];
just_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plmtex3_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plmtex3_pp_struct *__privtrans = (pdl_plmtex3_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->side);;free(__privtrans->text);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plmtex3_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plmtex3_pp_vtable = {
		0,0, 3, 3, pdl_plmtex3_pp_vtable_flags,
		pdl_plmtex3_pp_redodims, pdl_plmtex3_pp_readdata, NULL,
		pdl_plmtex3_pp_free,NULL,NULL,pdl_plmtex3_pp_copy,NULL,
		sizeof(pdl_plmtex3_pp_struct),"pdl_plmtex3_pp_vtable",
		NULL
	 };

typedef struct pdl_plpat_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_inc_dima;PDL_Long  __inc_del_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plpat_struct;

void pdl_plpat_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plpat_struct *__privtrans = (pdl_plpat_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nlin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nlin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * inc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * inc_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * del_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * del_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_del_dima = __privtrans->__inc_del_dima;
register PDL_Long __inc_inc_dima = __privtrans->__inc_inc_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nlin","inc","del"};
		static int __realdims[] = {0,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plpat";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_inc_dima = 0; else
		 __privtrans->__inc_inc_dima = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_del_dima = 0; else
		 __privtrans->__inc_del_dima = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plpat_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plpat_struct *__privtrans = (pdl_plpat_struct *) __tr;
	
	{
	    pdl_plpat_struct *__copy = malloc(sizeof(pdl_plpat_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_inc_dima=__copy->__inc_inc_dima;__privtrans->__inc_del_dima=__copy->__inc_del_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plpat_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plpat_struct *__privtrans = (pdl_plpat_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nlin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nlin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * inc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * inc_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * del_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * del_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];nlin_datap += __offsp[0];
inc_datap += __offsp[1];
del_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_del_dima = __privtrans->__inc_del_dima;
register PDL_Long __inc_inc_dima = __privtrans->__inc_inc_dima;

c_plpat((nlin_datap)[0] PDL_COMMENT("ACCESS()") ,inc_datap,del_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 nlin_datap += __tinc0_0;
inc_datap += __tinc0_1;
del_datap += __tinc0_2;

	 } nlin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
inc_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
del_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} nlin_datap -= __tinc1_0 *
     				  __tdims1;inc_datap -= __tinc1_1 *
     				  __tdims1;del_datap -= __tinc1_2 *
     				  __tdims1;
 nlin_datap -= __offsp[0];
inc_datap -= __offsp[1];
del_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plpat_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plpat_struct *__privtrans = (pdl_plpat_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plpat_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0};
	 pdl_transvtable pdl_plpat_vtable = {
		0,0, 3, 3, pdl_plpat_vtable_flags,
		pdl_plpat_redodims, pdl_plpat_readdata, NULL,
		pdl_plpat_free,NULL,NULL,pdl_plpat_copy,NULL,
		sizeof(pdl_plpat_struct),"pdl_plpat_vtable",
		NULL
	 };

typedef struct pdl_plprec_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plprec_struct;

void pdl_plprec_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plprec_struct *__privtrans = (pdl_plprec_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * setp_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * setp_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * prec_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * prec_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"setp","prec"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plprec";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plprec_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plprec_struct *__privtrans = (pdl_plprec_struct *) __tr;
	
	{
	    pdl_plprec_struct *__copy = malloc(sizeof(pdl_plprec_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plprec_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plprec_struct *__privtrans = (pdl_plprec_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * setp_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * setp_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * prec_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * prec_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];setp_datap += __offsp[0];
prec_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plprec((setp_datap)[0] PDL_COMMENT("ACCESS()") ,(prec_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 setp_datap += __tinc0_0;
prec_datap += __tinc0_1;

	 } setp_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
prec_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} setp_datap -= __tinc1_0 *
     				  __tdims1;prec_datap -= __tinc1_1 *
     				  __tdims1;
 setp_datap -= __offsp[0];
prec_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plprec_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plprec_struct *__privtrans = (pdl_plprec_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plprec_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plprec_vtable = {
		0,0, 2, 2, pdl_plprec_vtable_flags,
		pdl_plprec_redodims, pdl_plprec_readdata, NULL,
		pdl_plprec_free,NULL,NULL,pdl_plprec_copy,NULL,
		sizeof(pdl_plprec_struct),"pdl_plprec_vtable",
		NULL
	 };

typedef struct pdl_plpsty_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plpsty_struct;

void pdl_plpsty_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plpsty_struct *__privtrans = (pdl_plpsty_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * patt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * patt_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"patt"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plpsty";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plpsty_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plpsty_struct *__privtrans = (pdl_plpsty_struct *) __tr;
	
	{
	    pdl_plpsty_struct *__copy = malloc(sizeof(pdl_plpsty_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plpsty_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plpsty_struct *__privtrans = (pdl_plpsty_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * patt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * patt_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];patt_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plpsty((patt_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 patt_datap += __tinc0_0;

	 } patt_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} patt_datap -= __tinc1_0 *
     				  __tdims1;
 patt_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plpsty_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plpsty_struct *__privtrans = (pdl_plpsty_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plpsty_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plpsty_vtable = {
		0,0, 1, 1, pdl_plpsty_vtable_flags,
		pdl_plpsty_redodims, pdl_plpsty_readdata, NULL,
		pdl_plpsty_free,NULL,NULL,pdl_plpsty_copy,NULL,
		sizeof(pdl_plpsty_struct),"pdl_plpsty_vtable",
		NULL
	 };

typedef struct pdl_plptex_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;
		char  *text;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plptex_struct;

void pdl_plptex_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex_struct *__privtrans = (pdl_plptex_struct *) __tr;
	
	{
	    int __creating[5];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * dx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * dx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","dx","dy","just"};
		static int __realdims[] = {0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plptex";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plptex_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex_struct *__privtrans = (pdl_plptex_struct *) __tr;
	
	{
	    pdl_plptex_struct *__copy = malloc(sizeof(pdl_plptex_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->text) = malloc(strlen(__privtrans->text)+1); strcpy(__copy->text,__privtrans->text);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plptex_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex_struct *__privtrans = (pdl_plptex_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * dx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * dx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
y_datap += __offsp[1];
dx_datap += __offsp[2];
dy_datap += __offsp[3];
just_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plptex((x_datap)[0] PDL_COMMENT("ACCESS()") ,(y_datap)[0] PDL_COMMENT("ACCESS()") ,(dx_datap)[0] PDL_COMMENT("ACCESS()") ,(dy_datap)[0] PDL_COMMENT("ACCESS()") ,(just_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->text);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
dx_datap += __tinc0_2;
dy_datap += __tinc0_3;
just_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
dx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
dy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
just_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;dx_datap -= __tinc1_2 *
     				  __tdims1;dy_datap -= __tinc1_3 *
     				  __tdims1;just_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
dx_datap -= __offsp[2];
dy_datap -= __offsp[3];
just_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plptex_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex_struct *__privtrans = (pdl_plptex_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->text);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plptex_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plptex_vtable = {
		0,0, 5, 5, pdl_plptex_vtable_flags,
		pdl_plptex_redodims, pdl_plptex_readdata, NULL,
		pdl_plptex_free,NULL,NULL,pdl_plptex_copy,NULL,
		sizeof(pdl_plptex_struct),"pdl_plptex_vtable",
		NULL
	 };

typedef struct pdl_plptex3_struct {
		PDL_TRANS_START(10);
		pdl_thread  __pdlthread;
		char  *text;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plptex3_struct;

void pdl_plptex3_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex3_struct *__privtrans = (pdl_plptex3_struct *) __tr;
	
	{
	    int __creating[10];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dx_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * dy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * dy_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * dz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dz_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * sx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * sx_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * sy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * sy_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * sz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * sz_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","dx","dy","dz","sx","sy","sz","just"};
		static int __realdims[] = {0,0,0,0,0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plptex3";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 10
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,10,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plptex3_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex3_struct *__privtrans = (pdl_plptex3_struct *) __tr;
	
	{
	    pdl_plptex3_struct *__copy = malloc(sizeof(pdl_plptex3_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->text) = malloc(strlen(__privtrans->text)+1); strcpy(__copy->text,__privtrans->text);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plptex3_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex3_struct *__privtrans = (pdl_plptex3_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dx_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * dy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * dy_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * dz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dz_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * sx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * sx_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * sy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * sy_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * sz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * sz_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * just_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * just_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
dx_datap += __offsp[3];
dy_datap += __offsp[4];
dz_datap += __offsp[5];
sx_datap += __offsp[6];
sy_datap += __offsp[7];
sz_datap += __offsp[8];
just_datap += __offsp[9];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plptex3((x_datap)[0] PDL_COMMENT("ACCESS()") ,(y_datap)[0] PDL_COMMENT("ACCESS()") ,(z_datap)[0] PDL_COMMENT("ACCESS()") ,(dx_datap)[0] PDL_COMMENT("ACCESS()") ,(dy_datap)[0] PDL_COMMENT("ACCESS()") ,(dz_datap)[0] PDL_COMMENT("ACCESS()") ,(sx_datap)[0] PDL_COMMENT("ACCESS()") ,(sy_datap)[0] PDL_COMMENT("ACCESS()") ,(sz_datap)[0] PDL_COMMENT("ACCESS()") ,(just_datap)[0] PDL_COMMENT("ACCESS()") ,__privtrans->text);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
dx_datap += __tinc0_3;
dy_datap += __tinc0_4;
dz_datap += __tinc0_5;
sx_datap += __tinc0_6;
sy_datap += __tinc0_7;
sz_datap += __tinc0_8;
just_datap += __tinc0_9;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
dx_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
dy_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
dz_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
sx_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
sy_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
sz_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
just_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;dx_datap -= __tinc1_3 *
     				  __tdims1;dy_datap -= __tinc1_4 *
     				  __tdims1;dz_datap -= __tinc1_5 *
     				  __tdims1;sx_datap -= __tinc1_6 *
     				  __tdims1;sy_datap -= __tinc1_7 *
     				  __tdims1;sz_datap -= __tinc1_8 *
     				  __tdims1;just_datap -= __tinc1_9 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
dx_datap -= __offsp[3];
dy_datap -= __offsp[4];
dz_datap -= __offsp[5];
sx_datap -= __offsp[6];
sy_datap -= __offsp[7];
sz_datap -= __offsp[8];
just_datap -= __offsp[9];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plptex3_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plptex3_struct *__privtrans = (pdl_plptex3_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->text);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plptex3_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plptex3_vtable = {
		0,0, 10, 10, pdl_plptex3_vtable_flags,
		pdl_plptex3_redodims, pdl_plptex3_readdata, NULL,
		pdl_plptex3_free,NULL,NULL,pdl_plptex3_copy,NULL,
		sizeof(pdl_plptex3_struct),"pdl_plptex3_vtable",
		NULL
	 };

typedef struct pdl_plschr_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plschr_struct;

void pdl_plschr_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plschr_struct *__privtrans = (pdl_plschr_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"def","scale"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plschr";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plschr_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plschr_struct *__privtrans = (pdl_plschr_struct *) __tr;
	
	{
	    pdl_plschr_struct *__copy = malloc(sizeof(pdl_plschr_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plschr_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plschr_struct *__privtrans = (pdl_plschr_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];def_datap += __offsp[0];
scale_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plschr((def_datap)[0] PDL_COMMENT("ACCESS()") ,(scale_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 def_datap += __tinc0_0;
scale_datap += __tinc0_1;

	 } def_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scale_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} def_datap -= __tinc1_0 *
     				  __tdims1;scale_datap -= __tinc1_1 *
     				  __tdims1;
 def_datap -= __offsp[0];
scale_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plschr_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plschr_struct *__privtrans = (pdl_plschr_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plschr_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plschr_vtable = {
		0,0, 2, 2, pdl_plschr_vtable_flags,
		pdl_plschr_redodims, pdl_plschr_readdata, NULL,
		pdl_plschr_free,NULL,NULL,pdl_plschr_copy,NULL,
		sizeof(pdl_plschr_struct),"pdl_plschr_vtable",
		NULL
	 };

typedef struct pdl_plscmap0n_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap0n_struct;

void pdl_plscmap0n_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0n_struct *__privtrans = (pdl_plscmap0n_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ncolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ncolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ncolzero"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap0n";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap0n_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0n_struct *__privtrans = (pdl_plscmap0n_struct *) __tr;
	
	{
	    pdl_plscmap0n_struct *__copy = malloc(sizeof(pdl_plscmap0n_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap0n_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0n_struct *__privtrans = (pdl_plscmap0n_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ncolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ncolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];ncolzero_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscmap0n((ncolzero_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 ncolzero_datap += __tinc0_0;

	 } ncolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} ncolzero_datap -= __tinc1_0 *
     				  __tdims1;
 ncolzero_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap0n_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0n_struct *__privtrans = (pdl_plscmap0n_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscmap0n_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscmap0n_vtable = {
		0,0, 1, 1, pdl_plscmap0n_vtable_flags,
		pdl_plscmap0n_redodims, pdl_plscmap0n_readdata, NULL,
		pdl_plscmap0n_free,NULL,NULL,pdl_plscmap0n_copy,NULL,
		sizeof(pdl_plscmap0n_struct),"pdl_plscmap0n_vtable",
		NULL
	 };

typedef struct pdl_plscmap1n_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap1n_struct;

void pdl_plscmap1n_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1n_struct *__privtrans = (pdl_plscmap1n_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ncolone_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ncolone_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ncolone"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap1n";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap1n_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1n_struct *__privtrans = (pdl_plscmap1n_struct *) __tr;
	
	{
	    pdl_plscmap1n_struct *__copy = malloc(sizeof(pdl_plscmap1n_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap1n_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1n_struct *__privtrans = (pdl_plscmap1n_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ncolone_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ncolone_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];ncolone_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscmap1n((ncolone_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 ncolone_datap += __tinc0_0;

	 } ncolone_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} ncolone_datap -= __tinc1_0 *
     				  __tdims1;
 ncolone_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap1n_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1n_struct *__privtrans = (pdl_plscmap1n_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscmap1n_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscmap1n_vtable = {
		0,0, 1, 1, pdl_plscmap1n_vtable_flags,
		pdl_plscmap1n_redodims, pdl_plscmap1n_readdata, NULL,
		pdl_plscmap1n_free,NULL,NULL,pdl_plscmap1n_copy,NULL,
		sizeof(pdl_plscmap1n_struct),"pdl_plscmap1n_vtable",
		NULL
	 };

typedef struct pdl_plscol0_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscol0_struct;

void pdl_plscol0_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0_struct *__privtrans = (pdl_plscol0_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"icolzero","r","g","b"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscol0";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscol0_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0_struct *__privtrans = (pdl_plscol0_struct *) __tr;
	
	{
	    pdl_plscol0_struct *__copy = malloc(sizeof(pdl_plscol0_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscol0_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0_struct *__privtrans = (pdl_plscol0_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,(r_datap)[0] PDL_COMMENT("ACCESS()") ,(g_datap)[0] PDL_COMMENT("ACCESS()") ,(b_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscol0_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0_struct *__privtrans = (pdl_plscol0_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscol0_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscol0_vtable = {
		0,0, 4, 4, pdl_plscol0_vtable_flags,
		pdl_plscol0_redodims, pdl_plscol0_readdata, NULL,
		pdl_plscol0_free,NULL,NULL,pdl_plscol0_copy,NULL,
		sizeof(pdl_plscol0_struct),"pdl_plscol0_vtable",
		NULL
	 };

typedef struct pdl_plscolbg_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscolbg_struct;

void pdl_plscolbg_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbg_struct *__privtrans = (pdl_plscolbg_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscolbg";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscolbg_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbg_struct *__privtrans = (pdl_plscolbg_struct *) __tr;
	
	{
	    pdl_plscolbg_struct *__copy = malloc(sizeof(pdl_plscolbg_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscolbg_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbg_struct *__privtrans = (pdl_plscolbg_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscolbg((r_datap)[0] PDL_COMMENT("ACCESS()") ,(g_datap)[0] PDL_COMMENT("ACCESS()") ,(b_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscolbg_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbg_struct *__privtrans = (pdl_plscolbg_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscolbg_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscolbg_vtable = {
		0,0, 3, 3, pdl_plscolbg_vtable_flags,
		pdl_plscolbg_redodims, pdl_plscolbg_readdata, NULL,
		pdl_plscolbg_free,NULL,NULL,pdl_plscolbg_copy,NULL,
		sizeof(pdl_plscolbg_struct),"pdl_plscolbg_vtable",
		NULL
	 };

typedef struct pdl_plscolor_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscolor_struct;

void pdl_plscolor_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolor_struct *__privtrans = (pdl_plscolor_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"color"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscolor";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscolor_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolor_struct *__privtrans = (pdl_plscolor_struct *) __tr;
	
	{
	    pdl_plscolor_struct *__copy = malloc(sizeof(pdl_plscolor_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscolor_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolor_struct *__privtrans = (pdl_plscolor_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];color_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscolor((color_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 color_datap += __tinc0_0;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;
 color_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscolor_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolor_struct *__privtrans = (pdl_plscolor_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscolor_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscolor_vtable = {
		0,0, 1, 1, pdl_plscolor_vtable_flags,
		pdl_plscolor_redodims, pdl_plscolor_readdata, NULL,
		pdl_plscolor_free,NULL,NULL,pdl_plscolor_copy,NULL,
		sizeof(pdl_plscolor_struct),"pdl_plscolor_vtable",
		NULL
	 };

typedef struct pdl_plscompression_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscompression_struct;

void pdl_plscompression_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscompression_struct *__privtrans = (pdl_plscompression_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * compression_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * compression_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"compression"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscompression";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscompression_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscompression_struct *__privtrans = (pdl_plscompression_struct *) __tr;
	
	{
	    pdl_plscompression_struct *__copy = malloc(sizeof(pdl_plscompression_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscompression_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscompression_struct *__privtrans = (pdl_plscompression_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * compression_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * compression_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];compression_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscompression((compression_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 compression_datap += __tinc0_0;

	 } compression_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} compression_datap -= __tinc1_0 *
     				  __tdims1;
 compression_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscompression_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscompression_struct *__privtrans = (pdl_plscompression_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscompression_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscompression_vtable = {
		0,0, 1, 1, pdl_plscompression_vtable_flags,
		pdl_plscompression_redodims, pdl_plscompression_readdata, NULL,
		pdl_plscompression_free,NULL,NULL,pdl_plscompression_copy,NULL,
		sizeof(pdl_plscompression_struct),"pdl_plscompression_vtable",
		NULL
	 };

typedef struct pdl_plsdidev_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsdidev_struct;

void pdl_plsdidev_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdidev_struct *__privtrans = (pdl_plsdidev_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * mar_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * mar_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * jx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * jx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * jy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * jy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"mar","aspect","jx","jy"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsdidev";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsdidev_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdidev_struct *__privtrans = (pdl_plsdidev_struct *) __tr;
	
	{
	    pdl_plsdidev_struct *__copy = malloc(sizeof(pdl_plsdidev_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsdidev_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdidev_struct *__privtrans = (pdl_plsdidev_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * mar_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * mar_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * jx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * jx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * jy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * jy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];mar_datap += __offsp[0];
aspect_datap += __offsp[1];
jx_datap += __offsp[2];
jy_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsdidev((mar_datap)[0] PDL_COMMENT("ACCESS()") ,(aspect_datap)[0] PDL_COMMENT("ACCESS()") ,(jx_datap)[0] PDL_COMMENT("ACCESS()") ,(jy_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 mar_datap += __tinc0_0;
aspect_datap += __tinc0_1;
jx_datap += __tinc0_2;
jy_datap += __tinc0_3;

	 } mar_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
aspect_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
jx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
jy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} mar_datap -= __tinc1_0 *
     				  __tdims1;aspect_datap -= __tinc1_1 *
     				  __tdims1;jx_datap -= __tinc1_2 *
     				  __tdims1;jy_datap -= __tinc1_3 *
     				  __tdims1;
 mar_datap -= __offsp[0];
aspect_datap -= __offsp[1];
jx_datap -= __offsp[2];
jy_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsdidev_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdidev_struct *__privtrans = (pdl_plsdidev_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsdidev_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsdidev_vtable = {
		0,0, 4, 4, pdl_plsdidev_vtable_flags,
		pdl_plsdidev_redodims, pdl_plsdidev_readdata, NULL,
		pdl_plsdidev_free,NULL,NULL,pdl_plsdidev_copy,NULL,
		sizeof(pdl_plsdidev_struct),"pdl_plsdidev_vtable",
		NULL
	 };

typedef struct pdl_plsdimap_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsdimap_struct;

void pdl_plsdimap_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdimap_struct *__privtrans = (pdl_plsdimap_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * dimxmin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * dimxmin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * dimxmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * dimxmax_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * dimymin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * dimymin_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * dimymax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * dimymax_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * dimxpmm_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * dimxpmm_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * dimypmm_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dimypmm_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"dimxmin","dimxmax","dimymin","dimymax","dimxpmm","dimypmm"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsdimap";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsdimap_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdimap_struct *__privtrans = (pdl_plsdimap_struct *) __tr;
	
	{
	    pdl_plsdimap_struct *__copy = malloc(sizeof(pdl_plsdimap_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsdimap_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdimap_struct *__privtrans = (pdl_plsdimap_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * dimxmin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * dimxmin_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * dimxmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * dimxmax_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * dimymin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * dimymin_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * dimymax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * dimymax_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * dimxpmm_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * dimxpmm_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * dimypmm_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dimypmm_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];dimxmin_datap += __offsp[0];
dimxmax_datap += __offsp[1];
dimymin_datap += __offsp[2];
dimymax_datap += __offsp[3];
dimxpmm_datap += __offsp[4];
dimypmm_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsdimap((dimxmin_datap)[0] PDL_COMMENT("ACCESS()") ,(dimxmax_datap)[0] PDL_COMMENT("ACCESS()") ,(dimymin_datap)[0] PDL_COMMENT("ACCESS()") ,(dimymax_datap)[0] PDL_COMMENT("ACCESS()") ,(dimxpmm_datap)[0] PDL_COMMENT("ACCESS()") ,(dimypmm_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 dimxmin_datap += __tinc0_0;
dimxmax_datap += __tinc0_1;
dimymin_datap += __tinc0_2;
dimymax_datap += __tinc0_3;
dimxpmm_datap += __tinc0_4;
dimypmm_datap += __tinc0_5;

	 } dimxmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dimxmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
dimymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
dimymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
dimxpmm_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
dimypmm_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} dimxmin_datap -= __tinc1_0 *
     				  __tdims1;dimxmax_datap -= __tinc1_1 *
     				  __tdims1;dimymin_datap -= __tinc1_2 *
     				  __tdims1;dimymax_datap -= __tinc1_3 *
     				  __tdims1;dimxpmm_datap -= __tinc1_4 *
     				  __tdims1;dimypmm_datap -= __tinc1_5 *
     				  __tdims1;
 dimxmin_datap -= __offsp[0];
dimxmax_datap -= __offsp[1];
dimymin_datap -= __offsp[2];
dimymax_datap -= __offsp[3];
dimxpmm_datap -= __offsp[4];
dimypmm_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsdimap_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdimap_struct *__privtrans = (pdl_plsdimap_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsdimap_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsdimap_vtable = {
		0,0, 6, 6, pdl_plsdimap_vtable_flags,
		pdl_plsdimap_redodims, pdl_plsdimap_readdata, NULL,
		pdl_plsdimap_free,NULL,NULL,pdl_plsdimap_copy,NULL,
		sizeof(pdl_plsdimap_struct),"pdl_plsdimap_vtable",
		NULL
	 };

typedef struct pdl_plsdiori_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsdiori_struct;

void pdl_plsdiori_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiori_struct *__privtrans = (pdl_plsdiori_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * rot_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rot_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"rot"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsdiori";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsdiori_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiori_struct *__privtrans = (pdl_plsdiori_struct *) __tr;
	
	{
	    pdl_plsdiori_struct *__copy = malloc(sizeof(pdl_plsdiori_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsdiori_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiori_struct *__privtrans = (pdl_plsdiori_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * rot_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rot_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rot_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsdiori((rot_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 rot_datap += __tinc0_0;

	 } rot_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rot_datap -= __tinc1_0 *
     				  __tdims1;
 rot_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsdiori_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiori_struct *__privtrans = (pdl_plsdiori_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsdiori_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsdiori_vtable = {
		0,0, 1, 1, pdl_plsdiori_vtable_flags,
		pdl_plsdiori_redodims, pdl_plsdiori_readdata, NULL,
		pdl_plsdiori_free,NULL,NULL,pdl_plsdiori_copy,NULL,
		sizeof(pdl_plsdiori_struct),"pdl_plsdiori_vtable",
		NULL
	 };

typedef struct pdl_plsdiplt_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsdiplt_struct;

void pdl_plsdiplt_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplt_struct *__privtrans = (pdl_plsdiplt_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","ymin","xmax","ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsdiplt";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsdiplt_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplt_struct *__privtrans = (pdl_plsdiplt_struct *) __tr;
	
	{
	    pdl_plsdiplt_struct *__copy = malloc(sizeof(pdl_plsdiplt_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsdiplt_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplt_struct *__privtrans = (pdl_plsdiplt_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
ymin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsdiplt((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
ymin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ymin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;ymin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
ymin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsdiplt_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplt_struct *__privtrans = (pdl_plsdiplt_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsdiplt_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsdiplt_vtable = {
		0,0, 4, 4, pdl_plsdiplt_vtable_flags,
		pdl_plsdiplt_redodims, pdl_plsdiplt_readdata, NULL,
		pdl_plsdiplt_free,NULL,NULL,pdl_plsdiplt_copy,NULL,
		sizeof(pdl_plsdiplt_struct),"pdl_plsdiplt_vtable",
		NULL
	 };

typedef struct pdl_plsdiplz_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsdiplz_struct;

void pdl_plsdiplz_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplz_struct *__privtrans = (pdl_plsdiplz_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","ymin","xmax","ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsdiplz";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsdiplz_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplz_struct *__privtrans = (pdl_plsdiplz_struct *) __tr;
	
	{
	    pdl_plsdiplz_struct *__copy = malloc(sizeof(pdl_plsdiplz_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsdiplz_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplz_struct *__privtrans = (pdl_plsdiplz_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
ymin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsdiplz((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
ymin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ymin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;ymin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
ymin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsdiplz_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsdiplz_struct *__privtrans = (pdl_plsdiplz_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsdiplz_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsdiplz_vtable = {
		0,0, 4, 4, pdl_plsdiplz_vtable_flags,
		pdl_plsdiplz_redodims, pdl_plsdiplz_readdata, NULL,
		pdl_plsdiplz_free,NULL,NULL,pdl_plsdiplz_copy,NULL,
		sizeof(pdl_plsdiplz_struct),"pdl_plsdiplz_vtable",
		NULL
	 };

typedef struct pdl_pl_setcontlabelparam_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pl_setcontlabelparam_struct;

void pdl_pl_setcontlabelparam_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelparam_struct *__privtrans = (pdl_pl_setcontlabelparam_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * offset_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * offset_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * size_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * size_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * spacing_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * spacing_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * active_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * active_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"offset","size","spacing","active"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::pl_setcontlabelparam";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pl_setcontlabelparam_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelparam_struct *__privtrans = (pdl_pl_setcontlabelparam_struct *) __tr;
	
	{
	    pdl_pl_setcontlabelparam_struct *__copy = malloc(sizeof(pdl_pl_setcontlabelparam_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pl_setcontlabelparam_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelparam_struct *__privtrans = (pdl_pl_setcontlabelparam_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * offset_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * offset_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * size_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * size_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * spacing_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * spacing_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * active_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * active_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];offset_datap += __offsp[0];
size_datap += __offsp[1];
spacing_datap += __offsp[2];
active_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_pl_setcontlabelparam((offset_datap)[0] PDL_COMMENT("ACCESS()") ,(size_datap)[0] PDL_COMMENT("ACCESS()") ,(spacing_datap)[0] PDL_COMMENT("ACCESS()") ,(active_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 offset_datap += __tinc0_0;
size_datap += __tinc0_1;
spacing_datap += __tinc0_2;
active_datap += __tinc0_3;

	 } offset_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
size_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
spacing_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
active_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} offset_datap -= __tinc1_0 *
     				  __tdims1;size_datap -= __tinc1_1 *
     				  __tdims1;spacing_datap -= __tinc1_2 *
     				  __tdims1;active_datap -= __tinc1_3 *
     				  __tdims1;
 offset_datap -= __offsp[0];
size_datap -= __offsp[1];
spacing_datap -= __offsp[2];
active_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pl_setcontlabelparam_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelparam_struct *__privtrans = (pdl_pl_setcontlabelparam_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_pl_setcontlabelparam_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pl_setcontlabelparam_vtable = {
		0,0, 4, 4, pdl_pl_setcontlabelparam_vtable_flags,
		pdl_pl_setcontlabelparam_redodims, pdl_pl_setcontlabelparam_readdata, NULL,
		pdl_pl_setcontlabelparam_free,NULL,NULL,pdl_pl_setcontlabelparam_copy,NULL,
		sizeof(pdl_pl_setcontlabelparam_struct),"pdl_pl_setcontlabelparam_vtable",
		NULL
	 };

typedef struct pdl_pl_setcontlabelformat_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pl_setcontlabelformat_struct;

void pdl_pl_setcontlabelformat_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelformat_struct *__privtrans = (pdl_pl_setcontlabelformat_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * lexp_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * lexp_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * sigdig_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * sigdig_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"lexp","sigdig"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::pl_setcontlabelformat";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pl_setcontlabelformat_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelformat_struct *__privtrans = (pdl_pl_setcontlabelformat_struct *) __tr;
	
	{
	    pdl_pl_setcontlabelformat_struct *__copy = malloc(sizeof(pdl_pl_setcontlabelformat_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pl_setcontlabelformat_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelformat_struct *__privtrans = (pdl_pl_setcontlabelformat_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * lexp_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * lexp_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * sigdig_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * sigdig_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];lexp_datap += __offsp[0];
sigdig_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_pl_setcontlabelformat((lexp_datap)[0] PDL_COMMENT("ACCESS()") ,(sigdig_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 lexp_datap += __tinc0_0;
sigdig_datap += __tinc0_1;

	 } lexp_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
sigdig_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} lexp_datap -= __tinc1_0 *
     				  __tdims1;sigdig_datap -= __tinc1_1 *
     				  __tdims1;
 lexp_datap -= __offsp[0];
sigdig_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pl_setcontlabelformat_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pl_setcontlabelformat_struct *__privtrans = (pdl_pl_setcontlabelformat_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_pl_setcontlabelformat_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_pl_setcontlabelformat_vtable = {
		0,0, 2, 2, pdl_pl_setcontlabelformat_vtable_flags,
		pdl_pl_setcontlabelformat_redodims, pdl_pl_setcontlabelformat_readdata, NULL,
		pdl_pl_setcontlabelformat_free,NULL,NULL,pdl_pl_setcontlabelformat_copy,NULL,
		sizeof(pdl_pl_setcontlabelformat_struct),"pdl_pl_setcontlabelformat_vtable",
		NULL
	 };

typedef struct pdl_plsfam_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsfam_struct;

void pdl_plsfam_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfam_struct *__privtrans = (pdl_plsfam_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * fam_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * fam_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * num_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * num_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * bmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * bmax_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"fam","num","bmax"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsfam";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsfam_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfam_struct *__privtrans = (pdl_plsfam_struct *) __tr;
	
	{
	    pdl_plsfam_struct *__copy = malloc(sizeof(pdl_plsfam_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsfam_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfam_struct *__privtrans = (pdl_plsfam_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * fam_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * fam_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * num_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * num_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * bmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * bmax_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];fam_datap += __offsp[0];
num_datap += __offsp[1];
bmax_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfam((fam_datap)[0] PDL_COMMENT("ACCESS()") ,(num_datap)[0] PDL_COMMENT("ACCESS()") ,(bmax_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 fam_datap += __tinc0_0;
num_datap += __tinc0_1;
bmax_datap += __tinc0_2;

	 } fam_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
num_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
bmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} fam_datap -= __tinc1_0 *
     				  __tdims1;num_datap -= __tinc1_1 *
     				  __tdims1;bmax_datap -= __tinc1_2 *
     				  __tdims1;
 fam_datap -= __offsp[0];
num_datap -= __offsp[1];
bmax_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsfam_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfam_struct *__privtrans = (pdl_plsfam_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsfam_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsfam_vtable = {
		0,0, 3, 3, pdl_plsfam_vtable_flags,
		pdl_plsfam_redodims, pdl_plsfam_readdata, NULL,
		pdl_plsfam_free,NULL,NULL,pdl_plsfam_copy,NULL,
		sizeof(pdl_plsfam_struct),"pdl_plsfam_vtable",
		NULL
	 };

typedef struct pdl_plsmaj_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsmaj_struct;

void pdl_plsmaj_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmaj_struct *__privtrans = (pdl_plsmaj_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"def","scale"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsmaj";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsmaj_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmaj_struct *__privtrans = (pdl_plsmaj_struct *) __tr;
	
	{
	    pdl_plsmaj_struct *__copy = malloc(sizeof(pdl_plsmaj_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsmaj_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmaj_struct *__privtrans = (pdl_plsmaj_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];def_datap += __offsp[0];
scale_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsmaj((def_datap)[0] PDL_COMMENT("ACCESS()") ,(scale_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 def_datap += __tinc0_0;
scale_datap += __tinc0_1;

	 } def_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scale_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} def_datap -= __tinc1_0 *
     				  __tdims1;scale_datap -= __tinc1_1 *
     				  __tdims1;
 def_datap -= __offsp[0];
scale_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsmaj_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmaj_struct *__privtrans = (pdl_plsmaj_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsmaj_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsmaj_vtable = {
		0,0, 2, 2, pdl_plsmaj_vtable_flags,
		pdl_plsmaj_redodims, pdl_plsmaj_readdata, NULL,
		pdl_plsmaj_free,NULL,NULL,pdl_plsmaj_copy,NULL,
		sizeof(pdl_plsmaj_struct),"pdl_plsmaj_vtable",
		NULL
	 };

typedef struct pdl_plsmin_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsmin_struct;

void pdl_plsmin_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmin_struct *__privtrans = (pdl_plsmin_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"def","scale"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsmin";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsmin_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmin_struct *__privtrans = (pdl_plsmin_struct *) __tr;
	
	{
	    pdl_plsmin_struct *__copy = malloc(sizeof(pdl_plsmin_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsmin_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmin_struct *__privtrans = (pdl_plsmin_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];def_datap += __offsp[0];
scale_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsmin((def_datap)[0] PDL_COMMENT("ACCESS()") ,(scale_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 def_datap += __tinc0_0;
scale_datap += __tinc0_1;

	 } def_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scale_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} def_datap -= __tinc1_0 *
     				  __tdims1;scale_datap -= __tinc1_1 *
     				  __tdims1;
 def_datap -= __offsp[0];
scale_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsmin_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmin_struct *__privtrans = (pdl_plsmin_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsmin_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsmin_vtable = {
		0,0, 2, 2, pdl_plsmin_vtable_flags,
		pdl_plsmin_redodims, pdl_plsmin_readdata, NULL,
		pdl_plsmin_free,NULL,NULL,pdl_plsmin_copy,NULL,
		sizeof(pdl_plsmin_struct),"pdl_plsmin_vtable",
		NULL
	 };

typedef struct pdl_plsori_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsori_struct;

void pdl_plsori_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsori_struct *__privtrans = (pdl_plsori_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ori_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ori_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ori"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsori";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsori_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsori_struct *__privtrans = (pdl_plsori_struct *) __tr;
	
	{
	    pdl_plsori_struct *__copy = malloc(sizeof(pdl_plsori_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsori_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsori_struct *__privtrans = (pdl_plsori_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * ori_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ori_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];ori_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsori((ori_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 ori_datap += __tinc0_0;

	 } ori_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} ori_datap -= __tinc1_0 *
     				  __tdims1;
 ori_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsori_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsori_struct *__privtrans = (pdl_plsori_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsori_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsori_vtable = {
		0,0, 1, 1, pdl_plsori_vtable_flags,
		pdl_plsori_redodims, pdl_plsori_readdata, NULL,
		pdl_plsori_free,NULL,NULL,pdl_plsori_copy,NULL,
		sizeof(pdl_plsori_struct),"pdl_plsori_vtable",
		NULL
	 };

typedef struct pdl_plspage_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plspage_struct;

void pdl_plspage_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plspage_struct *__privtrans = (pdl_plspage_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yp_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * xleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * xleng_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * yleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * yleng_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * xoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * xoff_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * yoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * yoff_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xp","yp","xleng","yleng","xoff","yoff"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plspage";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plspage_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plspage_struct *__privtrans = (pdl_plspage_struct *) __tr;
	
	{
	    pdl_plspage_struct *__copy = malloc(sizeof(pdl_plspage_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plspage_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plspage_struct *__privtrans = (pdl_plspage_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xp_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yp_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yp_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * xleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * xleng_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * yleng_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * yleng_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * xoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * xoff_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * yoff_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * yoff_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xp_datap += __offsp[0];
yp_datap += __offsp[1];
xleng_datap += __offsp[2];
yleng_datap += __offsp[3];
xoff_datap += __offsp[4];
yoff_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plspage((xp_datap)[0] PDL_COMMENT("ACCESS()") ,(yp_datap)[0] PDL_COMMENT("ACCESS()") ,(xleng_datap)[0] PDL_COMMENT("ACCESS()") ,(yleng_datap)[0] PDL_COMMENT("ACCESS()") ,(xoff_datap)[0] PDL_COMMENT("ACCESS()") ,(yoff_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xp_datap += __tinc0_0;
yp_datap += __tinc0_1;
xleng_datap += __tinc0_2;
yleng_datap += __tinc0_3;
xoff_datap += __tinc0_4;
yoff_datap += __tinc0_5;

	 } xp_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yp_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xleng_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
yleng_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
xoff_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
yoff_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xp_datap -= __tinc1_0 *
     				  __tdims1;yp_datap -= __tinc1_1 *
     				  __tdims1;xleng_datap -= __tinc1_2 *
     				  __tdims1;yleng_datap -= __tinc1_3 *
     				  __tdims1;xoff_datap -= __tinc1_4 *
     				  __tdims1;yoff_datap -= __tinc1_5 *
     				  __tdims1;
 xp_datap -= __offsp[0];
yp_datap -= __offsp[1];
xleng_datap -= __offsp[2];
yleng_datap -= __offsp[3];
xoff_datap -= __offsp[4];
yoff_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plspage_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plspage_struct *__privtrans = (pdl_plspage_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plspage_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plspage_vtable = {
		0,0, 6, 6, pdl_plspage_vtable_flags,
		pdl_plspage_redodims, pdl_plspage_readdata, NULL,
		pdl_plspage_free,NULL,NULL,pdl_plspage_copy,NULL,
		sizeof(pdl_plspage_struct),"pdl_plspage_vtable",
		NULL
	 };

typedef struct pdl_plspause_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plspause_struct;

void pdl_plspause_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plspause_struct *__privtrans = (pdl_plspause_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * pause_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * pause_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"pause"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plspause";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plspause_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plspause_struct *__privtrans = (pdl_plspause_struct *) __tr;
	
	{
	    pdl_plspause_struct *__copy = malloc(sizeof(pdl_plspause_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plspause_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plspause_struct *__privtrans = (pdl_plspause_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * pause_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * pause_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];pause_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plspause((pause_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 pause_datap += __tinc0_0;

	 } pause_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} pause_datap -= __tinc1_0 *
     				  __tdims1;
 pause_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plspause_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plspause_struct *__privtrans = (pdl_plspause_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plspause_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plspause_vtable = {
		0,0, 1, 1, pdl_plspause_vtable_flags,
		pdl_plspause_redodims, pdl_plspause_readdata, NULL,
		pdl_plspause_free,NULL,NULL,pdl_plspause_copy,NULL,
		sizeof(pdl_plspause_struct),"pdl_plspause_vtable",
		NULL
	 };

typedef struct pdl_plsstrm_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsstrm_struct;

void pdl_plsstrm_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsstrm_struct *__privtrans = (pdl_plsstrm_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * strm_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * strm_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"strm"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsstrm";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsstrm_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsstrm_struct *__privtrans = (pdl_plsstrm_struct *) __tr;
	
	{
	    pdl_plsstrm_struct *__copy = malloc(sizeof(pdl_plsstrm_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsstrm_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsstrm_struct *__privtrans = (pdl_plsstrm_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * strm_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * strm_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];strm_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsstrm((strm_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 strm_datap += __tinc0_0;

	 } strm_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} strm_datap -= __tinc1_0 *
     				  __tdims1;
 strm_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsstrm_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsstrm_struct *__privtrans = (pdl_plsstrm_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsstrm_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsstrm_vtable = {
		0,0, 1, 1, pdl_plsstrm_vtable_flags,
		pdl_plsstrm_redodims, pdl_plsstrm_readdata, NULL,
		pdl_plsstrm_free,NULL,NULL,pdl_plsstrm_copy,NULL,
		sizeof(pdl_plsstrm_struct),"pdl_plsstrm_vtable",
		NULL
	 };

typedef struct pdl_plssub_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plssub_struct;

void pdl_plssub_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plssub_struct *__privtrans = (pdl_plssub_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * ny_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * ny_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nx","ny"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plssub";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plssub_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plssub_struct *__privtrans = (pdl_plssub_struct *) __tr;
	
	{
	    pdl_plssub_struct *__copy = malloc(sizeof(pdl_plssub_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plssub_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plssub_struct *__privtrans = (pdl_plssub_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * ny_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * ny_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];nx_datap += __offsp[0];
ny_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plssub((nx_datap)[0] PDL_COMMENT("ACCESS()") ,(ny_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 nx_datap += __tinc0_0;
ny_datap += __tinc0_1;

	 } nx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ny_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} nx_datap -= __tinc1_0 *
     				  __tdims1;ny_datap -= __tinc1_1 *
     				  __tdims1;
 nx_datap -= __offsp[0];
ny_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plssub_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plssub_struct *__privtrans = (pdl_plssub_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plssub_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plssub_vtable = {
		0,0, 2, 2, pdl_plssub_vtable_flags,
		pdl_plssub_redodims, pdl_plssub_readdata, NULL,
		pdl_plssub_free,NULL,NULL,pdl_plssub_copy,NULL,
		sizeof(pdl_plssub_struct),"pdl_plssub_vtable",
		NULL
	 };

typedef struct pdl_plssym_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plssym_struct;

void pdl_plssym_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plssym_struct *__privtrans = (pdl_plssym_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"def","scale"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plssym";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plssym_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plssym_struct *__privtrans = (pdl_plssym_struct *) __tr;
	
	{
	    pdl_plssym_struct *__copy = malloc(sizeof(pdl_plssym_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plssym_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plssym_struct *__privtrans = (pdl_plssym_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * def_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * def_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];def_datap += __offsp[0];
scale_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plssym((def_datap)[0] PDL_COMMENT("ACCESS()") ,(scale_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 def_datap += __tinc0_0;
scale_datap += __tinc0_1;

	 } def_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scale_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} def_datap -= __tinc1_0 *
     				  __tdims1;scale_datap -= __tinc1_1 *
     				  __tdims1;
 def_datap -= __offsp[0];
scale_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plssym_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plssym_struct *__privtrans = (pdl_plssym_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plssym_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plssym_vtable = {
		0,0, 2, 2, pdl_plssym_vtable_flags,
		pdl_plssym_redodims, pdl_plssym_readdata, NULL,
		pdl_plssym_free,NULL,NULL,pdl_plssym_copy,NULL,
		sizeof(pdl_plssym_struct),"pdl_plssym_vtable",
		NULL
	 };

typedef struct pdl_plstar_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstar_struct;

void pdl_plstar_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstar_struct *__privtrans = (pdl_plstar_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * ny_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * ny_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nx","ny"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plstar";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstar_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstar_struct *__privtrans = (pdl_plstar_struct *) __tr;
	
	{
	    pdl_plstar_struct *__copy = malloc(sizeof(pdl_plstar_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstar_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstar_struct *__privtrans = (pdl_plstar_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * ny_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * ny_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];nx_datap += __offsp[0];
ny_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plstar((nx_datap)[0] PDL_COMMENT("ACCESS()") ,(ny_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 nx_datap += __tinc0_0;
ny_datap += __tinc0_1;

	 } nx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ny_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} nx_datap -= __tinc1_0 *
     				  __tdims1;ny_datap -= __tinc1_1 *
     				  __tdims1;
 nx_datap -= __offsp[0];
ny_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstar_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstar_struct *__privtrans = (pdl_plstar_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plstar_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plstar_vtable = {
		0,0, 2, 2, pdl_plstar_vtable_flags,
		pdl_plstar_redodims, pdl_plstar_readdata, NULL,
		pdl_plstar_free,NULL,NULL,pdl_plstar_copy,NULL,
		sizeof(pdl_plstar_struct),"pdl_plstar_vtable",
		NULL
	 };

typedef struct pdl_plstart_pp_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		char  *devname;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstart_pp_struct;

void pdl_plstart_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstart_pp_struct *__privtrans = (pdl_plstart_pp_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * ny_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * ny_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nx","ny"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plstart_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstart_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstart_pp_struct *__privtrans = (pdl_plstart_pp_struct *) __tr;
	
	{
	    pdl_plstart_pp_struct *__copy = malloc(sizeof(pdl_plstart_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->devname) = malloc(strlen(__privtrans->devname)+1); strcpy(__copy->devname,__privtrans->devname);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstart_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstart_pp_struct *__privtrans = (pdl_plstart_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * nx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * ny_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * ny_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];nx_datap += __offsp[0];
ny_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plstart(__privtrans->devname,(nx_datap)[0] PDL_COMMENT("ACCESS()") ,(ny_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 nx_datap += __tinc0_0;
ny_datap += __tinc0_1;

	 } nx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ny_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} nx_datap -= __tinc1_0 *
     				  __tdims1;ny_datap -= __tinc1_1 *
     				  __tdims1;
 nx_datap -= __offsp[0];
ny_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstart_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstart_pp_struct *__privtrans = (pdl_plstart_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->devname);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plstart_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plstart_pp_vtable = {
		0,0, 2, 2, pdl_plstart_pp_vtable_flags,
		pdl_plstart_pp_redodims, pdl_plstart_pp_readdata, NULL,
		pdl_plstart_pp_free,NULL,NULL,pdl_plstart_pp_copy,NULL,
		sizeof(pdl_plstart_pp_struct),"pdl_plstart_pp_vtable",
		NULL
	 };

typedef struct pdl_plstripa_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstripa_struct;

void pdl_plstripa_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripa_struct *__privtrans = (pdl_plstripa_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * id_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * pen_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * pen_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"id","pen","x","y"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plstripa";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstripa_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripa_struct *__privtrans = (pdl_plstripa_struct *) __tr;
	
	{
	    pdl_plstripa_struct *__copy = malloc(sizeof(pdl_plstripa_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstripa_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripa_struct *__privtrans = (pdl_plstripa_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * id_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * pen_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * pen_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];id_datap += __offsp[0];
pen_datap += __offsp[1];
x_datap += __offsp[2];
y_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plstripa((id_datap)[0] PDL_COMMENT("ACCESS()") ,(pen_datap)[0] PDL_COMMENT("ACCESS()") ,(x_datap)[0] PDL_COMMENT("ACCESS()") ,(y_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 id_datap += __tinc0_0;
pen_datap += __tinc0_1;
x_datap += __tinc0_2;
y_datap += __tinc0_3;

	 } id_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
pen_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} id_datap -= __tinc1_0 *
     				  __tdims1;pen_datap -= __tinc1_1 *
     				  __tdims1;x_datap -= __tinc1_2 *
     				  __tdims1;y_datap -= __tinc1_3 *
     				  __tdims1;
 id_datap -= __offsp[0];
pen_datap -= __offsp[1];
x_datap -= __offsp[2];
y_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstripa_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripa_struct *__privtrans = (pdl_plstripa_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plstripa_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plstripa_vtable = {
		0,0, 4, 4, pdl_plstripa_vtable_flags,
		pdl_plstripa_redodims, pdl_plstripa_readdata, NULL,
		pdl_plstripa_free,NULL,NULL,pdl_plstripa_copy,NULL,
		sizeof(pdl_plstripa_struct),"pdl_plstripa_vtable",
		NULL
	 };

typedef struct pdl_plstripd_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstripd_struct;

void pdl_plstripd_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripd_struct *__privtrans = (pdl_plstripd_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * id_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"id"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plstripd";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstripd_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripd_struct *__privtrans = (pdl_plstripd_struct *) __tr;
	
	{
	    pdl_plstripd_struct *__copy = malloc(sizeof(pdl_plstripd_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstripd_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripd_struct *__privtrans = (pdl_plstripd_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * id_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];id_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plstripd((id_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 id_datap += __tinc0_0;

	 } id_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} id_datap -= __tinc1_0 *
     				  __tdims1;
 id_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstripd_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripd_struct *__privtrans = (pdl_plstripd_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plstripd_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plstripd_vtable = {
		0,0, 1, 1, pdl_plstripd_vtable_flags,
		pdl_plstripd_redodims, pdl_plstripd_readdata, NULL,
		pdl_plstripd_free,NULL,NULL,pdl_plstripd_copy,NULL,
		sizeof(pdl_plstripd_struct),"pdl_plstripd_vtable",
		NULL
	 };

typedef struct pdl_plsvpa_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsvpa_struct;

void pdl_plsvpa_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvpa_struct *__privtrans = (pdl_plsvpa_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsvpa";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsvpa_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvpa_struct *__privtrans = (pdl_plsvpa_struct *) __tr;
	
	{
	    pdl_plsvpa_struct *__copy = malloc(sizeof(pdl_plsvpa_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsvpa_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvpa_struct *__privtrans = (pdl_plsvpa_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsvpa((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsvpa_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvpa_struct *__privtrans = (pdl_plsvpa_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsvpa_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsvpa_vtable = {
		0,0, 4, 4, pdl_plsvpa_vtable_flags,
		pdl_plsvpa_redodims, pdl_plsvpa_readdata, NULL,
		pdl_plsvpa_free,NULL,NULL,pdl_plsvpa_copy,NULL,
		sizeof(pdl_plsvpa_struct),"pdl_plsvpa_vtable",
		NULL
	 };

typedef struct pdl_plsxax_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsxax_struct;

void pdl_plsxax_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxax_struct *__privtrans = (pdl_plsxax_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"digmax","digits"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsxax";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsxax_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxax_struct *__privtrans = (pdl_plsxax_struct *) __tr;
	
	{
	    pdl_plsxax_struct *__copy = malloc(sizeof(pdl_plsxax_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsxax_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxax_struct *__privtrans = (pdl_plsxax_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];digmax_datap += __offsp[0];
digits_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsxax((digmax_datap)[0] PDL_COMMENT("ACCESS()") ,(digits_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 digmax_datap += __tinc0_0;
digits_datap += __tinc0_1;

	 } digmax_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
digits_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} digmax_datap -= __tinc1_0 *
     				  __tdims1;digits_datap -= __tinc1_1 *
     				  __tdims1;
 digmax_datap -= __offsp[0];
digits_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsxax_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxax_struct *__privtrans = (pdl_plsxax_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsxax_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsxax_vtable = {
		0,0, 2, 2, pdl_plsxax_vtable_flags,
		pdl_plsxax_redodims, pdl_plsxax_readdata, NULL,
		pdl_plsxax_free,NULL,NULL,pdl_plsxax_copy,NULL,
		sizeof(pdl_plsxax_struct),"pdl_plsxax_vtable",
		NULL
	 };

typedef struct pdl_plsxwin_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsxwin_struct;

void pdl_plsxwin_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxwin_struct *__privtrans = (pdl_plsxwin_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * window_id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * window_id_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"window_id"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsxwin";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsxwin_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxwin_struct *__privtrans = (pdl_plsxwin_struct *) __tr;
	
	{
	    pdl_plsxwin_struct *__copy = malloc(sizeof(pdl_plsxwin_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsxwin_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxwin_struct *__privtrans = (pdl_plsxwin_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * window_id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * window_id_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];window_id_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
plsxwin((window_id_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 window_id_datap += __tinc0_0;

	 } window_id_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} window_id_datap -= __tinc1_0 *
     				  __tdims1;
 window_id_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsxwin_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsxwin_struct *__privtrans = (pdl_plsxwin_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsxwin_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsxwin_vtable = {
		0,0, 1, 1, pdl_plsxwin_vtable_flags,
		pdl_plsxwin_redodims, pdl_plsxwin_readdata, NULL,
		pdl_plsxwin_free,NULL,NULL,pdl_plsxwin_copy,NULL,
		sizeof(pdl_plsxwin_struct),"pdl_plsxwin_vtable",
		NULL
	 };

typedef struct pdl_plsyax_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsyax_struct;

void pdl_plsyax_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsyax_struct *__privtrans = (pdl_plsyax_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"digmax","digits"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsyax";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsyax_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsyax_struct *__privtrans = (pdl_plsyax_struct *) __tr;
	
	{
	    pdl_plsyax_struct *__copy = malloc(sizeof(pdl_plsyax_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsyax_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsyax_struct *__privtrans = (pdl_plsyax_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];digmax_datap += __offsp[0];
digits_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsyax((digmax_datap)[0] PDL_COMMENT("ACCESS()") ,(digits_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 digmax_datap += __tinc0_0;
digits_datap += __tinc0_1;

	 } digmax_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
digits_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} digmax_datap -= __tinc1_0 *
     				  __tdims1;digits_datap -= __tinc1_1 *
     				  __tdims1;
 digmax_datap -= __offsp[0];
digits_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsyax_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsyax_struct *__privtrans = (pdl_plsyax_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsyax_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsyax_vtable = {
		0,0, 2, 2, pdl_plsyax_vtable_flags,
		pdl_plsyax_redodims, pdl_plsyax_readdata, NULL,
		pdl_plsyax_free,NULL,NULL,pdl_plsyax_copy,NULL,
		sizeof(pdl_plsyax_struct),"pdl_plsyax_vtable",
		NULL
	 };

typedef struct pdl_plszax_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plszax_struct;

void pdl_plszax_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plszax_struct *__privtrans = (pdl_plszax_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"digmax","digits"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plszax";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plszax_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plszax_struct *__privtrans = (pdl_plszax_struct *) __tr;
	
	{
	    pdl_plszax_struct *__copy = malloc(sizeof(pdl_plszax_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plszax_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plszax_struct *__privtrans = (pdl_plszax_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * digmax_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * digmax_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * digits_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * digits_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];digmax_datap += __offsp[0];
digits_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plszax((digmax_datap)[0] PDL_COMMENT("ACCESS()") ,(digits_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 digmax_datap += __tinc0_0;
digits_datap += __tinc0_1;

	 } digmax_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
digits_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} digmax_datap -= __tinc1_0 *
     				  __tdims1;digits_datap -= __tinc1_1 *
     				  __tdims1;
 digmax_datap -= __offsp[0];
digits_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plszax_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plszax_struct *__privtrans = (pdl_plszax_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plszax_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plszax_vtable = {
		0,0, 2, 2, pdl_plszax_vtable_flags,
		pdl_plszax_redodims, pdl_plszax_readdata, NULL,
		pdl_plszax_free,NULL,NULL,pdl_plszax_copy,NULL,
		sizeof(pdl_plszax_struct),"pdl_plszax_vtable",
		NULL
	 };

typedef struct pdl_plvasp_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plvasp_struct;

void pdl_plvasp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plvasp_struct *__privtrans = (pdl_plvasp_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"aspect"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plvasp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plvasp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plvasp_struct *__privtrans = (pdl_plvasp_struct *) __tr;
	
	{
	    pdl_plvasp_struct *__copy = malloc(sizeof(pdl_plvasp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plvasp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plvasp_struct *__privtrans = (pdl_plvasp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];aspect_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plvasp((aspect_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 aspect_datap += __tinc0_0;

	 } aspect_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} aspect_datap -= __tinc1_0 *
     				  __tdims1;
 aspect_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plvasp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plvasp_struct *__privtrans = (pdl_plvasp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plvasp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plvasp_vtable = {
		0,0, 1, 1, pdl_plvasp_vtable_flags,
		pdl_plvasp_redodims, pdl_plvasp_readdata, NULL,
		pdl_plvasp_free,NULL,NULL,pdl_plvasp_copy,NULL,
		sizeof(pdl_plvasp_struct),"pdl_plvasp_vtable",
		NULL
	 };

typedef struct pdl_plvpas_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plvpas_struct;

void pdl_plvpas_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpas_struct *__privtrans = (pdl_plvpas_struct *) __tr;
	
	{
	    int __creating[5];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax","aspect"};
		static int __realdims[] = {0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plvpas";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plvpas_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpas_struct *__privtrans = (pdl_plvpas_struct *) __tr;
	
	{
	    pdl_plvpas_struct *__copy = malloc(sizeof(pdl_plvpas_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plvpas_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpas_struct *__privtrans = (pdl_plvpas_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * aspect_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * aspect_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];
aspect_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plvpas((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") ,(aspect_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;
aspect_datap += __tinc0_4;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
aspect_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;aspect_datap -= __tinc1_4 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];
aspect_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plvpas_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpas_struct *__privtrans = (pdl_plvpas_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plvpas_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plvpas_vtable = {
		0,0, 5, 5, pdl_plvpas_vtable_flags,
		pdl_plvpas_redodims, pdl_plvpas_readdata, NULL,
		pdl_plvpas_free,NULL,NULL,pdl_plvpas_copy,NULL,
		sizeof(pdl_plvpas_struct),"pdl_plvpas_vtable",
		NULL
	 };

typedef struct pdl_plvpor_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plvpor_struct;

void pdl_plvpor_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpor_struct *__privtrans = (pdl_plvpor_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plvpor";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plvpor_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpor_struct *__privtrans = (pdl_plvpor_struct *) __tr;
	
	{
	    pdl_plvpor_struct *__copy = malloc(sizeof(pdl_plvpor_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plvpor_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpor_struct *__privtrans = (pdl_plvpor_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plvpor((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plvpor_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plvpor_struct *__privtrans = (pdl_plvpor_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plvpor_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plvpor_vtable = {
		0,0, 4, 4, pdl_plvpor_vtable_flags,
		pdl_plvpor_redodims, pdl_plvpor_readdata, NULL,
		pdl_plvpor_free,NULL,NULL,pdl_plvpor_copy,NULL,
		sizeof(pdl_plvpor_struct),"pdl_plvpor_vtable",
		NULL
	 };

typedef struct pdl_plw3d_struct {
		PDL_TRANS_START(11);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plw3d_struct;

void pdl_plw3d_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plw3d_struct *__privtrans = (pdl_plw3d_struct *) __tr;
	
	{
	    int __creating[11];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
__creating[10] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * basex_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * basex_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * basey_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * basey_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * height_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * height_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * xminzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * xminzero_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * xmaxzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * xmaxzero_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * yminzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * yminzero_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * ymaxzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * ymaxzero_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * zminzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * zminzero_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * zmaxzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * zmaxzero_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * alt_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * alt_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_Double * az_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * az_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"basex","basey","height","xminzero","xmaxzero","yminzero","ymaxzero","zminzero","zmaxzero","alt","az"};
		static int __realdims[] = {0,0,0,0,0,0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plw3d";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 11
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,11,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[10]->hdrsv &&
	 (__privtrans->pdls[10]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[10]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[10]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plw3d_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plw3d_struct *__privtrans = (pdl_plw3d_struct *) __tr;
	
	{
	    pdl_plw3d_struct *__copy = malloc(sizeof(pdl_plw3d_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plw3d_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plw3d_struct *__privtrans = (pdl_plw3d_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * basex_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * basex_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * basey_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * basey_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * height_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * height_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * xminzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * xminzero_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * xmaxzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * xmaxzero_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * yminzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * yminzero_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * ymaxzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * ymaxzero_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * zminzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * zminzero_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * zmaxzero_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * zmaxzero_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * alt_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * alt_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_Double * az_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * az_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];basex_datap += __offsp[0];
basey_datap += __offsp[1];
height_datap += __offsp[2];
xminzero_datap += __offsp[3];
xmaxzero_datap += __offsp[4];
yminzero_datap += __offsp[5];
ymaxzero_datap += __offsp[6];
zminzero_datap += __offsp[7];
zmaxzero_datap += __offsp[8];
alt_datap += __offsp[9];
az_datap += __offsp[10];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plw3d((basex_datap)[0] PDL_COMMENT("ACCESS()") ,(basey_datap)[0] PDL_COMMENT("ACCESS()") ,(height_datap)[0] PDL_COMMENT("ACCESS()") ,(xminzero_datap)[0] PDL_COMMENT("ACCESS()") ,(xmaxzero_datap)[0] PDL_COMMENT("ACCESS()") ,(yminzero_datap)[0] PDL_COMMENT("ACCESS()") ,(ymaxzero_datap)[0] PDL_COMMENT("ACCESS()") ,(zminzero_datap)[0] PDL_COMMENT("ACCESS()") ,(zmaxzero_datap)[0] PDL_COMMENT("ACCESS()") ,(alt_datap)[0] PDL_COMMENT("ACCESS()") ,(az_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 basex_datap += __tinc0_0;
basey_datap += __tinc0_1;
height_datap += __tinc0_2;
xminzero_datap += __tinc0_3;
xmaxzero_datap += __tinc0_4;
yminzero_datap += __tinc0_5;
ymaxzero_datap += __tinc0_6;
zminzero_datap += __tinc0_7;
zmaxzero_datap += __tinc0_8;
alt_datap += __tinc0_9;
az_datap += __tinc0_10;

	 } basex_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
basey_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
height_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
xminzero_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
xmaxzero_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
yminzero_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
ymaxzero_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
zminzero_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
zmaxzero_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
alt_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
az_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;

	} basex_datap -= __tinc1_0 *
     				  __tdims1;basey_datap -= __tinc1_1 *
     				  __tdims1;height_datap -= __tinc1_2 *
     				  __tdims1;xminzero_datap -= __tinc1_3 *
     				  __tdims1;xmaxzero_datap -= __tinc1_4 *
     				  __tdims1;yminzero_datap -= __tinc1_5 *
     				  __tdims1;ymaxzero_datap -= __tinc1_6 *
     				  __tdims1;zminzero_datap -= __tinc1_7 *
     				  __tdims1;zmaxzero_datap -= __tinc1_8 *
     				  __tdims1;alt_datap -= __tinc1_9 *
     				  __tdims1;az_datap -= __tinc1_10 *
     				  __tdims1;
 basex_datap -= __offsp[0];
basey_datap -= __offsp[1];
height_datap -= __offsp[2];
xminzero_datap -= __offsp[3];
xmaxzero_datap -= __offsp[4];
yminzero_datap -= __offsp[5];
ymaxzero_datap -= __offsp[6];
zminzero_datap -= __offsp[7];
zmaxzero_datap -= __offsp[8];
alt_datap -= __offsp[9];
az_datap -= __offsp[10];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plw3d_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plw3d_struct *__privtrans = (pdl_plw3d_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plw3d_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plw3d_vtable = {
		0,0, 11, 11, pdl_plw3d_vtable_flags,
		pdl_plw3d_redodims, pdl_plw3d_readdata, NULL,
		pdl_plw3d_free,NULL,NULL,pdl_plw3d_copy,NULL,
		sizeof(pdl_plw3d_struct),"pdl_plw3d_vtable",
		NULL
	 };

typedef struct pdl_plwid_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plwid_struct;

void pdl_plwid_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plwid_struct *__privtrans = (pdl_plwid_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * width_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * width_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"width"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plwid";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plwid_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plwid_struct *__privtrans = (pdl_plwid_struct *) __tr;
	
	{
	    pdl_plwid_struct *__copy = malloc(sizeof(pdl_plwid_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plwid_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plwid_struct *__privtrans = (pdl_plwid_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * width_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * width_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];width_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plwid((width_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 width_datap += __tinc0_0;

	 } width_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} width_datap -= __tinc1_0 *
     				  __tdims1;
 width_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plwid_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plwid_struct *__privtrans = (pdl_plwid_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plwid_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plwid_vtable = {
		0,0, 1, 1, pdl_plwid_vtable_flags,
		pdl_plwid_redodims, pdl_plwid_readdata, NULL,
		pdl_plwid_free,NULL,NULL,pdl_plwid_copy,NULL,
		sizeof(pdl_plwid_struct),"pdl_plwid_vtable",
		NULL
	 };

typedef struct pdl_plwind_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plwind_struct;

void pdl_plwind_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plwind_struct *__privtrans = (pdl_plwind_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","ymin","ymax"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plwind";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plwind_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plwind_struct *__privtrans = (pdl_plwind_struct *) __tr;
	
	{
	    pdl_plwind_struct *__copy = malloc(sizeof(pdl_plwind_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plwind_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plwind_struct *__privtrans = (pdl_plwind_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
ymin_datap += __offsp[2];
ymax_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plwind((xmin_datap)[0] PDL_COMMENT("ACCESS()") ,(xmax_datap)[0] PDL_COMMENT("ACCESS()") ,(ymin_datap)[0] PDL_COMMENT("ACCESS()") ,(ymax_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
ymin_datap += __tinc0_2;
ymax_datap += __tinc0_3;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
ymin_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymax_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;ymin_datap -= __tinc1_2 *
     				  __tdims1;ymax_datap -= __tinc1_3 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
ymin_datap -= __offsp[2];
ymax_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plwind_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plwind_struct *__privtrans = (pdl_plwind_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plwind_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plwind_vtable = {
		0,0, 4, 4, pdl_plwind_vtable_flags,
		pdl_plwind_redodims, pdl_plwind_readdata, NULL,
		pdl_plwind_free,NULL,NULL,pdl_plwind_copy,NULL,
		sizeof(pdl_plwind_struct),"pdl_plwind_vtable",
		NULL
	 };

typedef struct pdl_plP_gpixmm_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_p_x_dima;PDL_Long  __inc_p_y_dima;PDL_Long  __dima_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plP_gpixmm_struct;

void pdl_plP_gpixmm_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plP_gpixmm_struct *__privtrans = (pdl_plP_gpixmm_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__dima_size = -1;
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_p_x_dima = __privtrans->__inc_p_x_dima;
register PDL_Long __inc_p_y_dima = __privtrans->__inc_p_y_dima;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_x","p_y"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plP_gpixmm";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plP_gpixmm:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__dima_size <= 1) __privtrans->__dima_size = 1;
   }
   if(__privtrans->__dima_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size == 1)) {
      __privtrans->__dima_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__dima_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plP_gpixmm:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_p_x_dima = 0; else
		 __privtrans->__inc_p_x_dima = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_p_y_dima = 0; else
		 __privtrans->__inc_p_y_dima = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plP_gpixmm_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plP_gpixmm_struct *__privtrans = (pdl_plP_gpixmm_struct *) __tr;
	
	{
	    pdl_plP_gpixmm_struct *__copy = malloc(sizeof(pdl_plP_gpixmm_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_p_x_dima=__copy->__inc_p_x_dima;__privtrans->__inc_p_y_dima=__copy->__inc_p_y_dima;__copy->__dima_size=__privtrans->__dima_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plP_gpixmm_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plP_gpixmm_struct *__privtrans = (pdl_plP_gpixmm_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * p_x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * p_x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * p_y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * p_y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];p_x_datap += __offsp[0];
p_y_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_p_x_dima = __privtrans->__inc_p_x_dima;
register PDL_Long __inc_p_y_dima = __privtrans->__inc_p_y_dima;

plP_gpixmm(p_x_datap,p_y_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_x_datap += __tinc0_0;
p_y_datap += __tinc0_1;

	 } p_x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} p_x_datap -= __tinc1_0 *
     				  __tdims1;p_y_datap -= __tinc1_1 *
     				  __tdims1;
 p_x_datap -= __offsp[0];
p_y_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plP_gpixmm_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plP_gpixmm_struct *__privtrans = (pdl_plP_gpixmm_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plP_gpixmm_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plP_gpixmm_vtable = {
		0,0, 2, 2, pdl_plP_gpixmm_vtable_flags,
		pdl_plP_gpixmm_redodims, pdl_plP_gpixmm_readdata, NULL,
		pdl_plP_gpixmm_free,NULL,NULL,pdl_plP_gpixmm_copy,NULL,
		sizeof(pdl_plP_gpixmm_struct),"pdl_plP_gpixmm_vtable",
		NULL
	 };

typedef struct pdl_plscolbga_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscolbga_struct;

void pdl_plscolbga_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbga_struct *__privtrans = (pdl_plscolbga_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b","a"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscolbga";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscolbga_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbga_struct *__privtrans = (pdl_plscolbga_struct *) __tr;
	
	{
	    pdl_plscolbga_struct *__copy = malloc(sizeof(pdl_plscolbga_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscolbga_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbga_struct *__privtrans = (pdl_plscolbga_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscolbga((r_datap)[0] PDL_COMMENT("ACCESS()") ,(g_datap)[0] PDL_COMMENT("ACCESS()") ,(b_datap)[0] PDL_COMMENT("ACCESS()") ,(a_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscolbga_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscolbga_struct *__privtrans = (pdl_plscolbga_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscolbga_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscolbga_vtable = {
		0,0, 4, 4, pdl_plscolbga_vtable_flags,
		pdl_plscolbga_redodims, pdl_plscolbga_readdata, NULL,
		pdl_plscolbga_free,NULL,NULL,pdl_plscolbga_copy,NULL,
		sizeof(pdl_plscolbga_struct),"pdl_plscolbga_vtable",
		NULL
	 };

typedef struct pdl_plscol0a_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscol0a_struct;

void pdl_plscol0a_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0a_struct *__privtrans = (pdl_plscol0a_struct *) __tr;
	
	{
	    int __creating[5];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"icolzero","r","g","b","a"};
		static int __realdims[] = {0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plscol0a";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscol0a_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0a_struct *__privtrans = (pdl_plscol0a_struct *) __tr;
	
	{
	    pdl_plscol0a_struct *__copy = malloc(sizeof(pdl_plscol0a_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscol0a_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0a_struct *__privtrans = (pdl_plscol0a_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plscol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,(r_datap)[0] PDL_COMMENT("ACCESS()") ,(g_datap)[0] PDL_COMMENT("ACCESS()") ,(b_datap)[0] PDL_COMMENT("ACCESS()") ,(a_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscol0a_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscol0a_struct *__privtrans = (pdl_plscol0a_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plscol0a_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plscol0a_vtable = {
		0,0, 5, 5, pdl_plscol0a_vtable_flags,
		pdl_plscol0a_redodims, pdl_plscol0a_readdata, NULL,
		pdl_plscol0a_free,NULL,NULL,pdl_plscol0a_copy,NULL,
		sizeof(pdl_plscol0a_struct),"pdl_plscol0a_vtable",
		NULL
	 };

typedef struct pdl_plline_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plline_struct;

void pdl_plline_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plline_struct *__privtrans = (pdl_plline_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	PDL_Double   y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plline";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plline:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plline:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plline_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plline_struct *__privtrans = (pdl_plline_struct *) __tr;
	
	{
	    pdl_plline_struct *__copy = malloc(sizeof(pdl_plline_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plline_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plline_struct *__privtrans = (pdl_plline_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	PDL_Double   y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { PDL_COMMENT("** do 'bad' Code **")
	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];x_datap += __offsp[0];
y_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

int i;
                     int j;
                     for (i=1;i<__privtrans->__n_size;i++) {
                       j = i-1;	/* PP does not like using i-1 in a PDL ref.  Use j instead. */
                       if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()")  != x_badval && (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, j))] PDL_COMMENT("ACCESS()")  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()")  != y_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, j))] PDL_COMMENT("ACCESS()")  != y_badval) {
                         c_pljoin ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, j))] PDL_COMMENT("ACCESS()") , (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, j))] PDL_COMMENT("ACCESS()") , (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()") , (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()") );
                       }
                     }
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { PDL_COMMENT("** else do 'good' Code **")
	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];x_datap += __offsp[0];
y_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

c_plline(__privtrans->__n_size,x_datap,y_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plline_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plline_struct *__privtrans = (pdl_plline_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plline_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plline_vtable = {
		0,0, 2, 2, pdl_plline_vtable_flags,
		pdl_plline_redodims, pdl_plline_readdata, NULL,
		pdl_plline_free,NULL,NULL,pdl_plline_copy,NULL,
		sizeof(pdl_plline_struct),"pdl_plline_vtable",
		NULL
	 };

typedef struct pdl_plcolorpoints_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __inc_z_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plcolorpoints_struct;

void pdl_plcolorpoints_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plcolorpoints_struct *__privtrans = (pdl_plcolorpoints_struct *) __tr;
	
	{
	    int __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	PDL_Double   y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	PDL_Double   z_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * sym_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * sym_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   sym_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Double * minz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * minz_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	PDL_Double   minz_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Double * maxz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * maxz_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));
	PDL_Double   maxz_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","sym","minz","maxz"};
		static int __realdims[] = {1,1,1,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plcolorpoints";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plcolorpoints:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plcolorpoints:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plcolorpoints:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_n = 0; else
		 __privtrans->__inc_z_n = PDL_REPRINC(__privtrans->pdls[2],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plcolorpoints_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plcolorpoints_struct *__privtrans = (pdl_plcolorpoints_struct *) __tr;
	
	{
	    pdl_plcolorpoints_struct *__copy = malloc(sizeof(pdl_plcolorpoints_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_z_n=__copy->__inc_z_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plcolorpoints_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plcolorpoints_struct *__privtrans = (pdl_plcolorpoints_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	PDL_Double   y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	PDL_Double   z_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * sym_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * sym_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   sym_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Double * minz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * minz_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	PDL_Double   minz_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Double * maxz_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * maxz_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));
	PDL_Double   maxz_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { PDL_COMMENT("** do 'bad' Code **")
	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
sym_datap += __offsp[3];
minz_datap += __offsp[4];
maxz_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

int i;
                  int j;
                  int ns = __privtrans->__n_size;
                  PLFLT zrange, ci;

                  zrange  = (maxz_datap)[0] PDL_COMMENT("ACCESS()")   - (minz_datap)[0] PDL_COMMENT("ACCESS()") ;

                  for (i=0;i<ns;i++) {
                    if ((z_datap)[0+(__inc_z_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()")  == z_badval) continue;
                    ci = (zrange == 0.0) ? 0.5 : ((z_datap)[0+(__inc_z_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()")  - (minz_datap)[0] PDL_COMMENT("ACCESS()") ) / zrange;  /* get color idx in 0-1 range */
                    if (ci < 0) ci = 0; /* enforce bounds */
                    if (ci > 1) ci = 1;
                    c_plcol1 (ci); /* set current color */
                    c_plsym (1, &(x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()") , &(y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()") , (sym_datap)[0] PDL_COMMENT("ACCESS()") ); /* plot it */

                  }
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
sym_datap += __tinc0_3;
minz_datap += __tinc0_4;
maxz_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
sym_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
minz_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
maxz_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;sym_datap -= __tinc1_3 *
     				  __tdims1;minz_datap -= __tinc1_4 *
     				  __tdims1;maxz_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
sym_datap -= __offsp[3];
minz_datap -= __offsp[4];
maxz_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { PDL_COMMENT("** else do 'good' Code **")
	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
sym_datap += __offsp[3];
minz_datap += __offsp[4];
maxz_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

int i;
                  int j;
                  int ns = __privtrans->__n_size;
                  PLFLT zrange, ci;

                  zrange  = (maxz_datap)[0] PDL_COMMENT("ACCESS()")  - (minz_datap)[0] PDL_COMMENT("ACCESS()") ;

                  for (i=0;i<ns;i++) {
                    ci = (zrange == 0.0) ? 0.5 : ((z_datap)[0+(__inc_z_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()")  - (minz_datap)[0] PDL_COMMENT("ACCESS()") ) / zrange;  /* get color idx in 0-1 range */
                    if (ci < 0) ci = 0; /* enforce bounds */
                    if (ci > 1) ci = 1;
                    c_plcol1 (ci); /* set current color */
                    c_plsym (1, &(x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()") , &(y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] PDL_COMMENT("ACCESS()") , (sym_datap)[0] PDL_COMMENT("ACCESS()") ); /* plot it */
                  }
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
sym_datap += __tinc0_3;
minz_datap += __tinc0_4;
maxz_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
sym_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
minz_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
maxz_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;sym_datap -= __tinc1_3 *
     				  __tdims1;minz_datap -= __tinc1_4 *
     				  __tdims1;maxz_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
sym_datap -= __offsp[3];
minz_datap -= __offsp[4];
maxz_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plcolorpoints_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plcolorpoints_struct *__privtrans = (pdl_plcolorpoints_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plcolorpoints_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plcolorpoints_vtable = {
		0,0, 6, 6, pdl_plcolorpoints_vtable_flags,
		pdl_plcolorpoints_redodims, pdl_plcolorpoints_readdata, NULL,
		pdl_plcolorpoints_free,NULL,NULL,pdl_plcolorpoints_copy,NULL,
		sizeof(pdl_plcolorpoints_struct),"pdl_plcolorpoints_vtable",
		NULL
	 };

typedef struct pdl_plsmem_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_image_3;PDL_Long  __inc_image_x;PDL_Long  __inc_image_y;PDL_Long  __y_size;PDL_Long  __3_size;PDL_Long  __x_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsmem_struct;

void pdl_plsmem_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmem_struct *__privtrans = (pdl_plsmem_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__y_size = -1;
__privtrans->__3_size = -1;
__privtrans->__x_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * maxx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * maxx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * maxy_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * maxy_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Byte * image_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * image_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_image_3 = __privtrans->__inc_image_3;
register PDL_Long __inc_image_x = __privtrans->__inc_image_x;
register PDL_Long __inc_image_y = __privtrans->__inc_image_y;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"maxx","maxy","image"};
		static int __realdims[] = {0,0,3};
		static char __funcname[] = "PDL::Graphics::PLplot::plsmem";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[2]))->ndims < 3) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__3_size <= 1) __privtrans->__3_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__x_size <= 1) __privtrans->__x_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 3 && __privtrans->__y_size <= 1) __privtrans->__y_size = 1;
   }
   if(__privtrans->__3_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__3_size == 1)) {
      __privtrans->__3_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__3_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsmem:" "Wrong dims\n");
      }
   }
   if(__privtrans->__x_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__x_size == 1)) {
      __privtrans->__x_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__x_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plsmem:" "Wrong dims\n");
      }
   }
   if(__privtrans->__y_size == -1 || (((__privtrans->pdls[2]))->ndims > 2 && __privtrans->__y_size == 1)) {
      __privtrans->__y_size = ((__privtrans->pdls[2]))->dims[2];
   } else if(((__privtrans->pdls[2]))->ndims > 2 && __privtrans->__y_size != ((__privtrans->pdls[2]))->dims[2]) {
      if(((__privtrans->pdls[2]))->dims[2] != 1) {
         PDL->pdl_barf("Error in plsmem:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_image_3 = 0; else
		 __privtrans->__inc_image_3 = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_image_x = 0; else
		 __privtrans->__inc_image_x = __privtrans->pdls[2]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 2 || __privtrans->pdls[2]->dims[2] <= 1)
		  __privtrans->__inc_image_y = 0; else
		 __privtrans->__inc_image_y = __privtrans->pdls[2]->dimincs[2]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsmem_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmem_struct *__privtrans = (pdl_plsmem_struct *) __tr;
	
	{
	    pdl_plsmem_struct *__copy = malloc(sizeof(pdl_plsmem_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_image_3=__copy->__inc_image_3;__privtrans->__inc_image_x=__copy->__inc_image_x;__privtrans->__inc_image_y=__copy->__inc_image_y;__copy->__y_size=__privtrans->__y_size;__copy->__3_size=__privtrans->__3_size;__copy->__x_size=__privtrans->__x_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsmem_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmem_struct *__privtrans = (pdl_plsmem_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * maxx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * maxx_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * maxy_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * maxy_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Byte * image_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * image_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];maxx_datap += __offsp[0];
maxy_datap += __offsp[1];
image_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_image_3 = __privtrans->__inc_image_3;
register PDL_Long __inc_image_x = __privtrans->__inc_image_x;
register PDL_Long __inc_image_y = __privtrans->__inc_image_y;

c_plsmem((maxx_datap)[0] PDL_COMMENT("ACCESS()") ,(maxy_datap)[0] PDL_COMMENT("ACCESS()") ,image_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 maxx_datap += __tinc0_0;
maxy_datap += __tinc0_1;
image_datap += __tinc0_2;

	 } maxx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
maxy_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
image_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} maxx_datap -= __tinc1_0 *
     				  __tdims1;maxy_datap -= __tinc1_1 *
     				  __tdims1;image_datap -= __tinc1_2 *
     				  __tdims1;
 maxx_datap -= __offsp[0];
maxy_datap -= __offsp[1];
image_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsmem_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsmem_struct *__privtrans = (pdl_plsmem_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plsmem_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_plsmem_vtable = {
		0,0, 3, 3, pdl_plsmem_vtable_flags,
		pdl_plsmem_redodims, pdl_plsmem_readdata, NULL,
		pdl_plsmem_free,NULL,NULL,pdl_plsmem_copy,NULL,
		sizeof(pdl_plsmem_struct),"pdl_plsmem_vtable",
		NULL
	 };

typedef struct pdl_plfbox_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plfbox_struct;

void pdl_plfbox_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plfbox_struct *__privtrans = (pdl_plfbox_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xo_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yo_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xo","yo"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plfbox";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plfbox_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plfbox_struct *__privtrans = (pdl_plfbox_struct *) __tr;
	
	{
	    pdl_plfbox_struct *__copy = malloc(sizeof(pdl_plfbox_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plfbox_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plfbox_struct *__privtrans = (pdl_plfbox_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xo_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yo_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];xo_datap += __offsp[0];
yo_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
PLFLT x[4], y[4];
                  x[0] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  - 0.5;
                  y[0] = 0.;
                  x[1] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  - 0.5;
                  y[1] = (yo_datap)[0] PDL_COMMENT("ACCESS()") ;
                  x[2] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  + 0.5;
                  y[2] = (yo_datap)[0] PDL_COMMENT("ACCESS()") ;
                  x[3] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  + 0.5;
                  y[3] = 0.;
                  plfill(4, x, y);
}	PDL_COMMENT("THREADLOOPEND")
	 xo_datap += __tinc0_0;
yo_datap += __tinc0_1;

	 } xo_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yo_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} xo_datap -= __tinc1_0 *
     				  __tdims1;yo_datap -= __tinc1_1 *
     				  __tdims1;
 xo_datap -= __offsp[0];
yo_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plfbox_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plfbox_struct *__privtrans = (pdl_plfbox_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plfbox_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plfbox_vtable = {
		0,0, 2, 2, pdl_plfbox_vtable_flags,
		pdl_plfbox_redodims, pdl_plfbox_readdata, NULL,
		pdl_plfbox_free,NULL,NULL,pdl_plfbox_copy,NULL,
		sizeof(pdl_plfbox_struct),"pdl_plfbox_vtable",
		NULL
	 };

typedef struct pdl_plunfbox_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plunfbox_struct;

void pdl_plunfbox_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plunfbox_struct *__privtrans = (pdl_plunfbox_struct *) __tr;
	
	{
	    int __creating[2];
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xo_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yo_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xo","yo"};
		static int __realdims[] = {0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plunfbox";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plunfbox_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plunfbox_struct *__privtrans = (pdl_plunfbox_struct *) __tr;
	
	{
	    pdl_plunfbox_struct *__copy = malloc(sizeof(pdl_plunfbox_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plunfbox_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plunfbox_struct *__privtrans = (pdl_plunfbox_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xo_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yo_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yo_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];xo_datap += __offsp[0];
yo_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
PLFLT x[4], y[4];
                  x[0] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  - 0.5;
                  y[0] = 0.;
                  x[1] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  - 0.5;
                  y[1] = (yo_datap)[0] PDL_COMMENT("ACCESS()") ;
                  x[2] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  + 0.5;
                  y[2] = (yo_datap)[0] PDL_COMMENT("ACCESS()") ;
                  x[3] = (xo_datap)[0] PDL_COMMENT("ACCESS()")  + 0.5;
                  y[3] = 0.;
                  plline(4, x, y);
}	PDL_COMMENT("THREADLOOPEND")
	 xo_datap += __tinc0_0;
yo_datap += __tinc0_1;

	 } xo_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yo_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} xo_datap -= __tinc1_0 *
     				  __tdims1;yo_datap -= __tinc1_1 *
     				  __tdims1;
 xo_datap -= __offsp[0];
yo_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plunfbox_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plunfbox_struct *__privtrans = (pdl_plunfbox_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plunfbox_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plunfbox_vtable = {
		0,0, 2, 2, pdl_plunfbox_vtable_flags,
		pdl_plunfbox_redodims, pdl_plunfbox_readdata, NULL,
		pdl_plunfbox_free,NULL,NULL,pdl_plunfbox_copy,NULL,
		sizeof(pdl_plunfbox_struct),"pdl_plunfbox_vtable",
		NULL
	 };

typedef struct pdl_plParseOpts_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		SV *argv;int  mode;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plParseOpts_struct;

void pdl_plParseOpts_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plParseOpts_struct *__privtrans = (pdl_plParseOpts_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * retval_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * retval_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"retval"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plParseOpts";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plParseOpts_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plParseOpts_struct *__privtrans = (pdl_plParseOpts_struct *) __tr;
	
	{
	    pdl_plParseOpts_struct *__copy = malloc(sizeof(pdl_plParseOpts_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->argv) = newSVsv(__privtrans->argv);;(__copy->mode) = (__privtrans->mode);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plParseOpts_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plParseOpts_struct *__privtrans = (pdl_plParseOpts_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * retval_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * retval_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];retval_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{

                SV* sv = __privtrans->argv;
                SV* dummy;
                AV* arr;
                int argc, newargc, i, retval;
                char** args;

                if ( !(SvROK (sv) && SvTYPE (SvRV (sv)) == SVt_PVAV)) {
                        barf("plParseOpts requires an array ref");
                }

                arr = (AV*) SvRV (sv);
                newargc = argc = av_len (arr) + 1;
                if (argc > 0) {
                  New(1, args, argc, char *);
                  if(args == NULL) croak("Failed to allocate memory in plParseOpts");

                  for (i = 0; i < argc; i++) {
                          STRLEN len;
                          args[i] = SvPV (* av_fetch (arr, i, 0), len);
                  }

                  (retval_datap)[0] PDL_COMMENT("ACCESS()")  = c_plparseopts (&newargc, (const char **)args, __privtrans->mode);

                  for (i = 0; i < newargc; i++)
                          av_push (arr, newSVpv (args[i], 0));

                  for (i = 0; i < argc; i++)
                          dummy = av_shift (arr); /* assign to dummy to suppress compile warning */

                  Safefree (args);
                }
        
}	PDL_COMMENT("THREADLOOPEND")
	 retval_datap += __tinc0_0;

	 } retval_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} retval_datap -= __tinc1_0 *
     				  __tdims1;
 retval_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plParseOpts_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plParseOpts_struct *__privtrans = (pdl_plParseOpts_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->argv);;;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plParseOpts_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plParseOpts_vtable = {
		0,0, 0, 1, pdl_plParseOpts_vtable_flags,
		pdl_plParseOpts_redodims, pdl_plParseOpts_readdata, NULL,
		pdl_plParseOpts_free,NULL,NULL,pdl_plParseOpts_copy,NULL,
		sizeof(pdl_plParseOpts_struct),"pdl_plParseOpts_vtable",
		NULL
	 };

typedef struct pdl_plpoin_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plpoin_struct;

void pdl_plpoin_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin_struct *__privtrans = (pdl_plpoin_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * code_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * code_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","code"};
		static int __realdims[] = {1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plpoin";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoin:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoin:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plpoin_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin_struct *__privtrans = (pdl_plpoin_struct *) __tr;
	
	{
	    pdl_plpoin_struct *__copy = malloc(sizeof(pdl_plpoin_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plpoin_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin_struct *__privtrans = (pdl_plpoin_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * code_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * code_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];x_datap += __offsp[0];
y_datap += __offsp[1];
code_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

c_plpoin(__privtrans->__n_size,x_datap,y_datap,(code_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
code_datap += __tinc0_2;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
code_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;code_datap -= __tinc1_2 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
code_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plpoin_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin_struct *__privtrans = (pdl_plpoin_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plpoin_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plpoin_vtable = {
		0,0, 3, 3, pdl_plpoin_vtable_flags,
		pdl_plpoin_redodims, pdl_plpoin_readdata, NULL,
		pdl_plpoin_free,NULL,NULL,pdl_plpoin_copy,NULL,
		sizeof(pdl_plpoin_struct),"pdl_plpoin_vtable",
		NULL
	 };

typedef struct pdl_plpoin3_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __inc_z_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plpoin3_struct;

void pdl_plpoin3_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin3_struct *__privtrans = (pdl_plpoin3_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * code_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * code_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","code"};
		static int __realdims[] = {1,1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plpoin3";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoin3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoin3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoin3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_n = 0; else
		 __privtrans->__inc_z_n = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plpoin3_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin3_struct *__privtrans = (pdl_plpoin3_struct *) __tr;
	
	{
	    pdl_plpoin3_struct *__copy = malloc(sizeof(pdl_plpoin3_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_z_n=__copy->__inc_z_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plpoin3_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin3_struct *__privtrans = (pdl_plpoin3_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * code_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * code_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
code_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

c_plpoin3(__privtrans->__n_size,x_datap,y_datap,z_datap,(code_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
code_datap += __tinc0_3;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
code_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;code_datap -= __tinc1_3 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
code_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plpoin3_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoin3_struct *__privtrans = (pdl_plpoin3_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plpoin3_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plpoin3_vtable = {
		0,0, 4, 4, pdl_plpoin3_vtable_flags,
		pdl_plpoin3_redodims, pdl_plpoin3_readdata, NULL,
		pdl_plpoin3_free,NULL,NULL,pdl_plpoin3_copy,NULL,
		sizeof(pdl_plpoin3_struct),"pdl_plpoin3_vtable",
		NULL
	 };

typedef struct pdl_plline3_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __inc_z_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plline3_struct;

void pdl_plline3_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plline3_struct *__privtrans = (pdl_plline3_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z"};
		static int __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plline3";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plline3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plline3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plline3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_n = 0; else
		 __privtrans->__inc_z_n = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plline3_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plline3_struct *__privtrans = (pdl_plline3_struct *) __tr;
	
	{
	    pdl_plline3_struct *__copy = malloc(sizeof(pdl_plline3_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_z_n=__copy->__inc_z_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plline3_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plline3_struct *__privtrans = (pdl_plline3_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

c_plline3(__privtrans->__n_size,x_datap,y_datap,z_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plline3_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plline3_struct *__privtrans = (pdl_plline3_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plline3_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plline3_vtable = {
		0,0, 3, 3, pdl_plline3_vtable_flags,
		pdl_plline3_redodims, pdl_plline3_readdata, NULL,
		pdl_plline3_free,NULL,NULL,pdl_plline3_copy,NULL,
		sizeof(pdl_plline3_struct),"pdl_plline3_vtable",
		NULL
	 };

typedef struct pdl_plpoly3_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __inc_z_n;PDL_Long  __inc_draw_m;PDL_Long  __n_size;PDL_Long  __m_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plpoly3_struct;

void pdl_plpoly3_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoly3_struct *__privtrans = (pdl_plpoly3_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__n_size = -1;
__privtrans->__m_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * draw_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * draw_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * ifcc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * ifcc_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_draw_m = __privtrans->__inc_draw_m;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","draw","ifcc"};
		static int __realdims[] = {1,1,1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plpoly3";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoly3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoly3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoly3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__m_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plpoly3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_n = 0; else
		 __privtrans->__inc_z_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_draw_m = 0; else
		 __privtrans->__inc_draw_m = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plpoly3_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoly3_struct *__privtrans = (pdl_plpoly3_struct *) __tr;
	
	{
	    pdl_plpoly3_struct *__copy = malloc(sizeof(pdl_plpoly3_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_z_n=__copy->__inc_z_n;__privtrans->__inc_draw_m=__copy->__inc_draw_m;__copy->__n_size=__privtrans->__n_size;__copy->__m_size=__privtrans->__m_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plpoly3_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoly3_struct *__privtrans = (pdl_plpoly3_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * draw_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * draw_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * ifcc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * ifcc_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
draw_datap += __offsp[3];
ifcc_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_draw_m = __privtrans->__inc_draw_m;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;
register PDL_Long __inc_z_n = __privtrans->__inc_z_n;

c_plpoly3(__privtrans->__n_size,x_datap,y_datap,z_datap,draw_datap,(ifcc_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
draw_datap += __tinc0_3;
ifcc_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
draw_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ifcc_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;draw_datap -= __tinc1_3 *
     				  __tdims1;ifcc_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
draw_datap -= __offsp[3];
ifcc_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plpoly3_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plpoly3_struct *__privtrans = (pdl_plpoly3_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plpoly3_vtable_flags[] =
	 	{ 0,0,0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plpoly3_vtable = {
		0,0, 5, 5, pdl_plpoly3_vtable_flags,
		pdl_plpoly3_redodims, pdl_plpoly3_readdata, NULL,
		pdl_plpoly3_free,NULL,NULL,pdl_plpoly3_copy,NULL,
		sizeof(pdl_plpoly3_struct),"pdl_plpoly3_vtable",
		NULL
	 };

typedef struct pdl_plhist_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_data_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plhist_struct;

void pdl_plhist_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plhist_struct *__privtrans = (pdl_plhist_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * datmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * datmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * datmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * datmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nbin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nbin_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * oldwin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * oldwin_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","datmin","datmax","nbin","oldwin"};
		static int __realdims[] = {1,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plhist";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plhist:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plhist_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plhist_struct *__privtrans = (pdl_plhist_struct *) __tr;
	
	{
	    pdl_plhist_struct *__copy = malloc(sizeof(pdl_plhist_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_n=__copy->__inc_data_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plhist_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plhist_struct *__privtrans = (pdl_plhist_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * datmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * datmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * datmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * datmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nbin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nbin_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * oldwin_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * oldwin_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];data_datap += __offsp[0];
datmin_datap += __offsp[1];
datmax_datap += __offsp[2];
nbin_datap += __offsp[3];
oldwin_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_data_n = __privtrans->__inc_data_n;

c_plhist(__privtrans->__n_size,data_datap,(datmin_datap)[0] PDL_COMMENT("ACCESS()") ,(datmax_datap)[0] PDL_COMMENT("ACCESS()") ,(nbin_datap)[0] PDL_COMMENT("ACCESS()") ,(oldwin_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 data_datap += __tinc0_0;
datmin_datap += __tinc0_1;
datmax_datap += __tinc0_2;
nbin_datap += __tinc0_3;
oldwin_datap += __tinc0_4;

	 } data_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
datmin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
datmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
nbin_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
oldwin_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} data_datap -= __tinc1_0 *
     				  __tdims1;datmin_datap -= __tinc1_1 *
     				  __tdims1;datmax_datap -= __tinc1_2 *
     				  __tdims1;nbin_datap -= __tinc1_3 *
     				  __tdims1;oldwin_datap -= __tinc1_4 *
     				  __tdims1;
 data_datap -= __offsp[0];
datmin_datap -= __offsp[1];
datmax_datap -= __offsp[2];
nbin_datap -= __offsp[3];
oldwin_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plhist_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plhist_struct *__privtrans = (pdl_plhist_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_plhist_vtable_flags[] =
	 	{ 0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plhist_vtable = {
		0,0, 5, 5, pdl_plhist_vtable_flags,
		pdl_plhist_redodims, pdl_plhist_readdata, NULL,
		pdl_plhist_free,NULL,NULL,pdl_plhist_copy,NULL,
		sizeof(pdl_plhist_struct),"pdl_plhist_vtable",
		NULL
	 };

typedef struct pdl_plfill_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plfill_struct;

void pdl_plfill_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill_struct *__privtrans = (pdl_plfill_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plfill";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plfill:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plfill:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plfill_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill_struct *__privtrans = (pdl_plfill_struct *) __tr;
	
	{
	    pdl_plfill_struct *__copy = malloc(sizeof(pdl_plfill_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plfill_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill_struct *__privtrans = (pdl_plfill_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];x_datap += __offsp[0];
y_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

c_plfill(__privtrans->__n_size,x_datap,y_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plfill_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plfill_struct *__privtrans = (pdl_plfill_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plfill_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plfill_vtable = {
		0,0, 2, 2, pdl_plfill_vtable_flags,
		pdl_plfill_redodims, pdl_plfill_readdata, NULL,
		pdl_plfill_free,NULL,NULL,pdl_plfill_copy,NULL,
		sizeof(pdl_plfill_struct),"pdl_plfill_vtable",
		NULL
	 };

typedef struct pdl_plgradient_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgradient_struct;

void pdl_plgradient_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgradient_struct *__privtrans = (pdl_plgradient_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * angle_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * angle_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","angle"};
		static int __realdims[] = {1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgradient";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgradient:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgradient:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgradient_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgradient_struct *__privtrans = (pdl_plgradient_struct *) __tr;
	
	{
	    pdl_plgradient_struct *__copy = malloc(sizeof(pdl_plgradient_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgradient_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgradient_struct *__privtrans = (pdl_plgradient_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * angle_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * angle_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];x_datap += __offsp[0];
y_datap += __offsp[1];
angle_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

c_plgradient(__privtrans->__n_size,x_datap,y_datap,(angle_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
angle_datap += __tinc0_2;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
angle_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;angle_datap -= __tinc1_2 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
angle_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgradient_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgradient_struct *__privtrans = (pdl_plgradient_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plgradient_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plgradient_vtable = {
		0,0, 3, 3, pdl_plgradient_vtable_flags,
		pdl_plgradient_redodims, pdl_plgradient_readdata, NULL,
		pdl_plgradient_free,NULL,NULL,pdl_plgradient_copy,NULL,
		sizeof(pdl_plgradient_struct),"pdl_plgradient_vtable",
		NULL
	 };

typedef struct pdl_plsym_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsym_struct;

void pdl_plsym_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsym_struct *__privtrans = (pdl_plsym_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * code_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * code_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","code"};
		static int __realdims[] = {1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsym";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsym:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsym:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsym_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsym_struct *__privtrans = (pdl_plsym_struct *) __tr;
	
	{
	    pdl_plsym_struct *__copy = malloc(sizeof(pdl_plsym_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsym_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsym_struct *__privtrans = (pdl_plsym_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * code_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * code_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];x_datap += __offsp[0];
y_datap += __offsp[1];
code_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;

c_plsym(__privtrans->__n_size,x_datap,y_datap,(code_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
code_datap += __tinc0_2;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
code_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;code_datap -= __tinc1_2 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
code_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsym_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsym_struct *__privtrans = (pdl_plsym_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plsym_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsym_vtable = {
		0,0, 3, 3, pdl_plsym_vtable_flags,
		pdl_plsym_redodims, pdl_plsym_readdata, NULL,
		pdl_plsym_free,NULL,NULL,pdl_plsym_copy,NULL,
		sizeof(pdl_plsym_struct),"pdl_plsym_vtable",
		NULL
	 };

typedef struct pdl_plsurf3d_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_nx;PDL_Long  __inc_y_ny;PDL_Long  __inc_z_nx;PDL_Long  __inc_z_ny;PDL_Long  __inc_clevel_nlevel;PDL_Long  __ny_size;PDL_Long  __nlevel_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsurf3d_struct;

void pdl_plsurf3d_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsurf3d_struct *__privtrans = (pdl_plsurf3d_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__ny_size = -1;
__privtrans->__nlevel_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","opt","clevel"};
		static int __realdims[] = {1,1,2,0,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plsurf3d";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsurf3d:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsurf3d:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsurf3d:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plsurf3d:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__nlevel_size <= 1) __privtrans->__nlevel_size = 1;
   }
   if(__privtrans->__nlevel_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nlevel_size == 1)) {
      __privtrans->__nlevel_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nlevel_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsurf3d:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_nx = 0; else
		 __privtrans->__inc_x_nx = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_ny = 0; else
		 __privtrans->__inc_y_ny = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_nx = 0; else
		 __privtrans->__inc_z_nx = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_z_ny = 0; else
		 __privtrans->__inc_z_ny = PDL_REPRINC(__privtrans->pdls[2],1);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_clevel_nlevel = 0; else
		 __privtrans->__inc_clevel_nlevel = __privtrans->pdls[4]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsurf3d_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsurf3d_struct *__privtrans = (pdl_plsurf3d_struct *) __tr;
	
	{
	    pdl_plsurf3d_struct *__copy = malloc(sizeof(pdl_plsurf3d_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_nx=__copy->__inc_x_nx;__privtrans->__inc_y_ny=__copy->__inc_y_ny;__privtrans->__inc_z_nx=__copy->__inc_z_nx;__privtrans->__inc_z_ny=__copy->__inc_z_ny;__privtrans->__inc_clevel_nlevel=__copy->__inc_clevel_nlevel;__copy->__ny_size=__privtrans->__ny_size;__copy->__nlevel_size=__privtrans->__nlevel_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsurf3d_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsurf3d_struct *__privtrans = (pdl_plsurf3d_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
opt_datap += __offsp[3];
clevel_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;


           int i, j, size_x, size_y;
           PLFLT** zz;

           size_x =  __privtrans->__nx_size;
           size_y =  __privtrans->__ny_size;
           plAlloc2dGrid (&zz, size_x, size_y);
           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               zz[i][j] = (z_datap)[0+(__inc_z_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_z_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;
           c_plsurf3d (x_datap, y_datap, (const PLFLT **)zz, size_x, size_y, (opt_datap)[0] PDL_COMMENT("ACCESS()") ,
                       clevel_datap, __privtrans->__nlevel_size);
           plFree2dGrid (zz, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
opt_datap += __tinc0_3;
clevel_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
opt_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
clevel_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;opt_datap -= __tinc1_3 *
     				  __tdims1;clevel_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
opt_datap -= __offsp[3];
clevel_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsurf3d_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsurf3d_struct *__privtrans = (pdl_plsurf3d_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;
			}
			
	}
    }
    



static char pdl_plsurf3d_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_plsurf3d_vtable = {
		0,0, 5, 5, pdl_plsurf3d_vtable_flags,
		pdl_plsurf3d_redodims, pdl_plsurf3d_readdata, NULL,
		pdl_plsurf3d_free,NULL,NULL,pdl_plsurf3d_copy,NULL,
		sizeof(pdl_plsurf3d_struct),"pdl_plsurf3d_vtable",
		NULL
	 };

typedef struct pdl_plstyl_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_mark_nms;PDL_Long  __inc_space_nms;PDL_Long  __nms_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstyl_struct;

void pdl_plstyl_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstyl_struct *__privtrans = (pdl_plstyl_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__nms_size = -1;
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * mark_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * mark_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * space_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * space_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_mark_nms = __privtrans->__inc_mark_nms;
register PDL_Long __inc_space_nms = __privtrans->__inc_space_nms;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"mark","space"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plstyl";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nms_size <= 1) __privtrans->__nms_size = 1;
   }
   if(__privtrans->__nms_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nms_size == 1)) {
      __privtrans->__nms_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nms_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstyl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__nms_size <= 1) __privtrans->__nms_size = 1;
   }
   if(__privtrans->__nms_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__nms_size == 1)) {
      __privtrans->__nms_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__nms_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstyl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_mark_nms = 0; else
		 __privtrans->__inc_mark_nms = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_space_nms = 0; else
		 __privtrans->__inc_space_nms = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstyl_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstyl_struct *__privtrans = (pdl_plstyl_struct *) __tr;
	
	{
	    pdl_plstyl_struct *__copy = malloc(sizeof(pdl_plstyl_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_mark_nms=__copy->__inc_mark_nms;__privtrans->__inc_space_nms=__copy->__inc_space_nms;__copy->__nms_size=__privtrans->__nms_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstyl_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstyl_struct *__privtrans = (pdl_plstyl_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * mark_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * mark_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * space_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * space_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];mark_datap += __offsp[0];
space_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_mark_nms = __privtrans->__inc_mark_nms;
register PDL_Long __inc_space_nms = __privtrans->__inc_space_nms;

c_plstyl (__privtrans->__nms_size, mark_datap, space_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 mark_datap += __tinc0_0;
space_datap += __tinc0_1;

	 } mark_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
space_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} mark_datap -= __tinc1_0 *
     				  __tdims1;space_datap -= __tinc1_1 *
     				  __tdims1;
 mark_datap -= __offsp[0];
space_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstyl_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstyl_struct *__privtrans = (pdl_plstyl_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plstyl_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plstyl_vtable = {
		0,0, 2, 2, pdl_plstyl_vtable_flags,
		pdl_plstyl_redodims, pdl_plstyl_readdata, NULL,
		pdl_plstyl_free,NULL,NULL,pdl_plstyl_copy,NULL,
		sizeof(pdl_plstyl_struct),"pdl_plstyl_vtable",
		NULL
	 };

typedef struct pdl_plseed_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plseed_struct;

void pdl_plseed_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plseed_struct *__privtrans = (pdl_plseed_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"seed"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plseed";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plseed_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plseed_struct *__privtrans = (pdl_plseed_struct *) __tr;
	
	{
	    pdl_plseed_struct *__copy = malloc(sizeof(pdl_plseed_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plseed_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plseed_struct *__privtrans = (pdl_plseed_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * seed_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * seed_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];seed_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
unsigned int useed = (unsigned int)(seed_datap)[0] PDL_COMMENT("ACCESS()") ; c_plseed(useed);
}	PDL_COMMENT("THREADLOOPEND")
	 seed_datap += __tinc0_0;

	 } seed_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} seed_datap -= __tinc1_0 *
     				  __tdims1;
 seed_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plseed_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plseed_struct *__privtrans = (pdl_plseed_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plseed_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plseed_vtable = {
		0,0, 1, 1, pdl_plseed_vtable_flags,
		pdl_plseed_redodims, pdl_plseed_readdata, NULL,
		pdl_plseed_free,NULL,NULL,pdl_plseed_copy,NULL,
		sizeof(pdl_plseed_struct),"pdl_plseed_vtable",
		NULL
	 };

typedef struct pdl_plrandd_struct {
		PDL_TRANS_START(1);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plrandd_struct;

void pdl_plrandd_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plrandd_struct *__privtrans = (pdl_plrandd_struct *) __tr;
	
	{
	    int __creating[1];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"rand"};
		static int __realdims[] = {0};
		static char __funcname[] = "PDL::Graphics::PLplot::plrandd";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 1
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,1,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plrandd_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plrandd_struct *__privtrans = (pdl_plrandd_struct *) __tr;
	
	{
	    pdl_plrandd_struct *__copy = malloc(sizeof(pdl_plrandd_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plrandd_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plrandd_struct *__privtrans = (pdl_plrandd_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Double * rand_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rand_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];rand_datap += __offsp[0];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
(rand_datap)[0] PDL_COMMENT("ACCESS()")  = c_plrandd();
}	PDL_COMMENT("THREADLOOPEND")
	 rand_datap += __tinc0_0;

	 } rand_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;

	} rand_datap -= __tinc1_0 *
     				  __tdims1;
 rand_datap -= __offsp[0];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plrandd_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plrandd_struct *__privtrans = (pdl_plrandd_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plrandd_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plrandd_vtable = {
		0,0, 0, 1, pdl_plrandd_vtable_flags,
		pdl_plrandd_redodims, pdl_plrandd_readdata, NULL,
		pdl_plrandd_free,NULL,NULL,pdl_plrandd_copy,NULL,
		sizeof(pdl_plrandd_struct),"pdl_plrandd_vtable",
		NULL
	 };

typedef struct pdl_plAllocGrid_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_xg_nx;PDL_Long  __inc_yg_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plAllocGrid_struct;

void pdl_plAllocGrid_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plAllocGrid_struct *__privtrans = (pdl_plAllocGrid_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xg_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yg_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * grid_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * grid_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_xg_nx = __privtrans->__inc_xg_nx;
register PDL_Long __inc_yg_ny = __privtrans->__inc_yg_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xg","yg","grid"};
		static int __realdims[] = {1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plAllocGrid";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plAllocGrid:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plAllocGrid:" "Wrong dims\n");
      }
   }
if(!__creating[2]) {
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xg_nx = 0; else
		 __privtrans->__inc_xg_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_yg_ny = 0; else
		 __privtrans->__inc_yg_ny = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plAllocGrid_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plAllocGrid_struct *__privtrans = (pdl_plAllocGrid_struct *) __tr;
	
	{
	    pdl_plAllocGrid_struct *__copy = malloc(sizeof(pdl_plAllocGrid_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xg_nx=__copy->__inc_xg_nx;__privtrans->__inc_yg_ny=__copy->__inc_yg_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plAllocGrid_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plAllocGrid_struct *__privtrans = (pdl_plAllocGrid_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xg_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yg_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * grid_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * grid_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];xg_datap += __offsp[0];
yg_datap += __offsp[1];
grid_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_xg_nx = __privtrans->__inc_xg_nx;
register PDL_Long __inc_yg_ny = __privtrans->__inc_yg_ny;


          PLcGrid *grid;
          int i, nx, ny;

          nx = __privtrans->__nx_size;
          ny = __privtrans->__ny_size;

          New(1, grid, 1, PLcGrid);
          if(grid == NULL) croak("Failed to allocate memory for grid");
          Newz(2, grid->xg, nx, PLFLT);
          if(grid->xg == NULL) croak("Failed to allocate memory for grid->xg");
          Newz(3, grid->yg, ny, PLFLT);
          if(grid->yg == NULL) croak("Failed to allocate memory for grid->yg");
          grid->nx = nx;
          grid->ny = ny;

          for (i = 0; i < nx; i++)
            grid->xg[i] = (xg_datap)[0+(__inc_xg_nx*PP_INDTERM(__privtrans->__nx_size, i))] PDL_COMMENT("ACCESS()") ;

          for (i = 0; i < ny; i++)
            grid->yg[i] = (yg_datap)[0+(__inc_yg_ny*PP_INDTERM(__privtrans->__ny_size, i))] PDL_COMMENT("ACCESS()") ;

          (grid_datap)[0] PDL_COMMENT("ACCESS()")  = (I32) grid;
}	PDL_COMMENT("THREADLOOPEND")
	 xg_datap += __tinc0_0;
yg_datap += __tinc0_1;
grid_datap += __tinc0_2;

	 } xg_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yg_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
grid_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} xg_datap -= __tinc1_0 *
     				  __tdims1;yg_datap -= __tinc1_1 *
     				  __tdims1;grid_datap -= __tinc1_2 *
     				  __tdims1;
 xg_datap -= __offsp[0];
yg_datap -= __offsp[1];
grid_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plAllocGrid_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plAllocGrid_struct *__privtrans = (pdl_plAllocGrid_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plAllocGrid_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plAllocGrid_vtable = {
		0,0, 2, 3, pdl_plAllocGrid_vtable_flags,
		pdl_plAllocGrid_redodims, pdl_plAllocGrid_readdata, NULL,
		pdl_plAllocGrid_free,NULL,NULL,pdl_plAllocGrid_copy,NULL,
		sizeof(pdl_plAllocGrid_struct),"pdl_plAllocGrid_vtable",
		NULL
	 };

typedef struct pdl_plAlloc2dGrid_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_xg_nx;PDL_Long  __inc_xg_ny;PDL_Long  __inc_yg_nx;PDL_Long  __inc_yg_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plAlloc2dGrid_struct;

void pdl_plAlloc2dGrid_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plAlloc2dGrid_struct *__privtrans = (pdl_plAlloc2dGrid_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xg_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yg_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * grid_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * grid_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_xg_nx = __privtrans->__inc_xg_nx;
register PDL_Long __inc_xg_ny = __privtrans->__inc_xg_ny;
register PDL_Long __inc_yg_nx = __privtrans->__inc_yg_nx;
register PDL_Long __inc_yg_ny = __privtrans->__inc_yg_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xg","yg","grid"};
		static int __realdims[] = {2,2,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plAlloc2dGrid";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plAlloc2dGrid:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plAlloc2dGrid:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plAlloc2dGrid:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plAlloc2dGrid:" "Wrong dims\n");
      }
   }
if(!__creating[2]) {
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xg_nx = 0; else
		 __privtrans->__inc_xg_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_xg_ny = 0; else
		 __privtrans->__inc_xg_ny = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_yg_nx = 0; else
		 __privtrans->__inc_yg_nx = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_yg_ny = 0; else
		 __privtrans->__inc_yg_ny = PDL_REPRINC(__privtrans->pdls[1],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plAlloc2dGrid_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plAlloc2dGrid_struct *__privtrans = (pdl_plAlloc2dGrid_struct *) __tr;
	
	{
	    pdl_plAlloc2dGrid_struct *__copy = malloc(sizeof(pdl_plAlloc2dGrid_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xg_nx=__copy->__inc_xg_nx;__privtrans->__inc_xg_ny=__copy->__inc_xg_ny;__privtrans->__inc_yg_nx=__copy->__inc_yg_nx;__privtrans->__inc_yg_ny=__copy->__inc_yg_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plAlloc2dGrid_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plAlloc2dGrid_struct *__privtrans = (pdl_plAlloc2dGrid_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xg_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * yg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * yg_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * grid_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * grid_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];xg_datap += __offsp[0];
yg_datap += __offsp[1];
grid_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_xg_nx = __privtrans->__inc_xg_nx;
register PDL_Long __inc_xg_ny = __privtrans->__inc_xg_ny;
register PDL_Long __inc_yg_nx = __privtrans->__inc_yg_nx;
register PDL_Long __inc_yg_ny = __privtrans->__inc_yg_ny;


          PLcGrid2 *grid;
          int i, j, nx, ny;

          nx = __privtrans->__nx_size;
          ny = __privtrans->__ny_size;

          grid = (PLcGrid2*) malloc (sizeof (PLcGrid2));
          plAlloc2dGrid (&(grid->xg), nx, ny);
          plAlloc2dGrid (&(grid->yg), nx, ny);

          for (i = 0; i < nx; i++)
            for (j = 0; j < ny; j++) {
              grid->xg[i][j] = (xg_datap)[0+(__inc_xg_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_xg_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;
              grid->yg[i][j] = (yg_datap)[0+(__inc_yg_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_yg_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;
            }

          grid->nx = nx;
          grid->ny = ny;

          (grid_datap)[0] PDL_COMMENT("ACCESS()")  = (I32) grid;
}	PDL_COMMENT("THREADLOOPEND")
	 xg_datap += __tinc0_0;
yg_datap += __tinc0_1;
grid_datap += __tinc0_2;

	 } xg_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
yg_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
grid_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} xg_datap -= __tinc1_0 *
     				  __tdims1;yg_datap -= __tinc1_1 *
     				  __tdims1;grid_datap -= __tinc1_2 *
     				  __tdims1;
 xg_datap -= __offsp[0];
yg_datap -= __offsp[1];
grid_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plAlloc2dGrid_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plAlloc2dGrid_struct *__privtrans = (pdl_plAlloc2dGrid_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plAlloc2dGrid_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plAlloc2dGrid_vtable = {
		0,0, 2, 3, pdl_plAlloc2dGrid_vtable_flags,
		pdl_plAlloc2dGrid_redodims, pdl_plAlloc2dGrid_readdata, NULL,
		pdl_plAlloc2dGrid_free,NULL,NULL,pdl_plAlloc2dGrid_copy,NULL,
		sizeof(pdl_plAlloc2dGrid_struct),"pdl_plAlloc2dGrid_vtable",
		NULL
	 };


#define check_sub_pointer(subptr, errmsg) \
  if (SvTRUE (subptr) \
      && (! SvROK (subptr) || SvTYPE (SvRV (subptr)) != SVt_PVCV)) \
    croak (errmsg);

static SV* pltr_subroutine;

static IV pltr0_iv;
static IV pltr1_iv;
static IV pltr2_iv;

static void
pltr_callback (PLFLT x, PLFLT y, PLFLT* tx, PLFLT* ty, PLPointer pltr_data)
{
  I32 count;
  dSP;

  ENTER;
  SAVETMPS;

  PUSHMARK (SP);
  XPUSHs (sv_2mortal (newSVnv ((double) x)));
  XPUSHs (sv_2mortal (newSVnv ((double) y)));
  XPUSHs ((SV*) pltr_data);
  PUTBACK;

  count = call_sv (pltr_subroutine, G_ARRAY);

  SPAGAIN;

  if (count != 2)
    croak ("pltr: must return two scalars");

  *ty = (PLFLT) POPn;
  *tx = (PLFLT) POPn;

  PUTBACK;
  FREETMPS;
  LEAVE;
}

static void*
get_standard_pltrcb (SV* cb)
{
  if ( !SvROK(cb) ) return NULL; /* Added to prevent bug in plshades for 0 input. D. Hunt 12/18/2008 */
  IV sub = (IV) SvRV (cb);

  if (sub == pltr0_iv)
    return (void*) pltr0;
  else if (sub == pltr1_iv)
    return (void*) pltr1;
  else if (sub == pltr2_iv)
    return (void*) pltr2;
  else
    return SvTRUE (cb) ? (void*) pltr_callback : NULL;
}

static SV* defined_subroutine;

static PLINT
defined_callback (PLFLT x, PLFLT y)
{
  I32 count, retval;
  dSP;

  ENTER;
  SAVETMPS;

  PUSHMARK (SP);
  XPUSHs (sv_2mortal (newSVnv ((double) x)));
  XPUSHs (sv_2mortal (newSVnv ((double) y)));
  PUTBACK;

  count = call_sv (defined_subroutine, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak ("defined: must return one scalar");

  retval = POPi;

  PUTBACK;
  FREETMPS;
  LEAVE;

  return retval;
}

static SV* mapform_subroutine;

static void default_magic (pdl *p, int pa) { p->data = 0; }

static void
mapform_callback (PLINT n, PLFLT* x, PLFLT* y)
{
  pdl *x_pdl, *y_pdl;
  PLFLT *tx, *ty;
  SV *x_sv, *y_sv;
  int dims, i;
  I32 count, ax;
  dSP;

  ENTER;
  SAVETMPS;

  dims = n;

  x_pdl = PDL->pdlnew ();
  PDL->add_deletedata_magic(x_pdl, default_magic, 0);
  PDL->setdims (x_pdl, &dims, 1);
  x_pdl->datatype = PDL_D;
  x_pdl->data = x;
  x_pdl->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
  x_sv = sv_newmortal ();
  PDL->SetSV_PDL (x_sv, x_pdl);

  y_pdl = PDL->pdlnew ();
  PDL->add_deletedata_magic(y_pdl, default_magic, 0);
  PDL->setdims (y_pdl, &dims, 1);
  y_pdl->datatype = PDL_D;
  y_pdl->data = y;
  y_pdl->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
  y_sv = sv_newmortal ();
  PDL->SetSV_PDL (y_sv, y_pdl);

  PUSHMARK (SP);
  XPUSHs (x_sv);
  XPUSHs (y_sv);
  PUTBACK;

  count = call_sv (mapform_subroutine, G_ARRAY);

  SPAGAIN;
  SP -= count ;
  ax = (SP - PL_stack_base) + 1;

  if (count != 2)
    croak ("mapform: must return two piddles");

  tx = (PLFLT*) ((PDL->SvPDLV(ST(0)))->data);
  ty = (PLFLT*) ((PDL->SvPDLV(ST(1)))->data);

  for (i = 0; i < n; i++) {
    *(x + i) = *(tx + i);
    *(y + i) = *(ty + i);
  }

  PUTBACK;
  FREETMPS;
  LEAVE;
}

// Subroutines for adding transforms via plstransform
static SV* xform_subroutine;

static void
xform_callback ( PLFLT x, PLFLT y, PLFLT *xt, PLFLT *yt, PLPointer data )
{
  SV *x_sv, *y_sv; // Perl scalars for the input x and y
  I32 count, ax;
  dSP;

  ENTER;
  SAVETMPS;

  x_sv = newSVnv((double)x);
  y_sv = newSVnv((double)y);

  PUSHMARK (SP);
  XPUSHs (x_sv);
  XPUSHs (y_sv);
  PUTBACK;

  count = call_sv (xform_subroutine, G_ARRAY);

  SPAGAIN;
  SP -= count ;
  ax = (SP - PL_stack_base) + 1;

  if (count != 2)
    croak ("xform: must return two perl scalars");

  *xt = (PLFLT) SvNV(ST(0));
  *yt = (PLFLT) SvNV(ST(1));

  PUTBACK;
  FREETMPS;
  LEAVE;
}

// Subroutines for adding label formatting via plslabelfunc
static SV* labelfunc_subroutine;

void labelfunc_callback (PLINT axis, PLFLT value, char *label_text, PLINT length, void *data )
{
  SV *axis_sv, *value_sv, *length_sv; // Perl scalars for inputs
  I32 count, ax;
  dSP;

  ENTER;
  SAVETMPS;

  axis_sv   = newSViv((IV)axis);
  value_sv  = newSVnv((double)value);
  length_sv = newSViv((IV)length);

  PUSHMARK (SP);
  XPUSHs (axis_sv);
  XPUSHs (value_sv);
  XPUSHs (length_sv);
  PUTBACK;

  count = call_sv (labelfunc_subroutine, G_ARRAY);

  SPAGAIN;
  SP -= count ;
  ax = (SP - PL_stack_base) + 1;

  if (count != 1)
    croak ("labelfunc: must return one perl scalar");

  // Copy label into output string
  snprintf( label_text, length, (char *)SvPV_nolen(ST(0)) );

  PUTBACK;
  FREETMPS;
  LEAVE;
}

typedef struct pdl_init_pltr_struct {
		PDL_TRANS_START(0);
		pdl_thread  __pdlthread;
		SV *p0;SV *p1;SV *p2;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_init_pltr_struct;

void pdl_init_pltr_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_init_pltr_struct *__privtrans = (pdl_init_pltr_struct *) __tr;
	
	{
	    int __creating[1];
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {};
		static int __realdims[] = {};
		static char __funcname[] = "PDL::Graphics::PLplot::init_pltr";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 0
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,0,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_init_pltr_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_init_pltr_struct *__privtrans = (pdl_init_pltr_struct *) __tr;
	
	{
	    pdl_init_pltr_struct *__copy = malloc(sizeof(pdl_init_pltr_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->p0) = newSVsv(__privtrans->p0);;(__copy->p1) = newSVsv(__privtrans->p1);;(__copy->p2) = newSVsv(__privtrans->p2);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_init_pltr_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_init_pltr_struct *__privtrans = (pdl_init_pltr_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 
	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{

           pltr0_iv = (IV) SvRV (__privtrans->p0);
           pltr1_iv = (IV) SvRV (__privtrans->p1);
           pltr2_iv = (IV) SvRV (__privtrans->p2);
}	PDL_COMMENT("THREADLOOPEND")
	 
	 } 
	} 
 
      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_init_pltr_free(pdl_trans *__tr ) {
	int __dim;
	pdl_init_pltr_struct *__privtrans = (pdl_init_pltr_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->p0);;SvREFCNT_dec(__privtrans->p1);;SvREFCNT_dec(__privtrans->p2);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_init_pltr_vtable_flags[] =
	 	{ };
	 pdl_transvtable pdl_init_pltr_vtable = {
		0,0, 0, 0, pdl_init_pltr_vtable_flags,
		pdl_init_pltr_redodims, pdl_init_pltr_readdata, NULL,
		pdl_init_pltr_free,NULL,NULL,pdl_init_pltr_copy,NULL,
		sizeof(pdl_init_pltr_struct),"pdl_init_pltr_vtable",
		NULL
	 };

typedef struct pdl_plmap_pp_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		SV *mapform;char *type;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plmap_pp_struct;

void pdl_plmap_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plmap_pp_struct *__privtrans = (pdl_plmap_pp_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * minlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * minlong_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * maxlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * maxlong_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * minlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * minlat_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * maxlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * maxlat_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"minlong","maxlong","minlat","maxlat"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plmap_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plmap_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plmap_pp_struct *__privtrans = (pdl_plmap_pp_struct *) __tr;
	
	{
	    pdl_plmap_pp_struct *__copy = malloc(sizeof(pdl_plmap_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->mapform) = newSVsv(__privtrans->mapform);;(__copy->type) = malloc(strlen(__privtrans->type)+1); strcpy(__copy->type,__privtrans->type);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plmap_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plmap_pp_struct *__privtrans = (pdl_plmap_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * minlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * minlong_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * maxlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * maxlong_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * minlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * minlat_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * maxlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * maxlat_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];minlong_datap += __offsp[0];
maxlong_datap += __offsp[1];
minlat_datap += __offsp[2];
maxlat_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{

           int use_xform;
           mapform_subroutine = __privtrans->mapform;
	   check_sub_pointer (mapform_subroutine,
	     "plmap: mapform must be either 0 or a subroutine pointer");

           use_xform = SvTRUE (__privtrans->mapform);
           plmap (use_xform ? mapform_callback : NULL,
	     __privtrans->type, (minlong_datap)[0] PDL_COMMENT("ACCESS()") , (maxlong_datap)[0] PDL_COMMENT("ACCESS()") , (minlat_datap)[0] PDL_COMMENT("ACCESS()") , (maxlat_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 minlong_datap += __tinc0_0;
maxlong_datap += __tinc0_1;
minlat_datap += __tinc0_2;
maxlat_datap += __tinc0_3;

	 } minlong_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
maxlong_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
minlat_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
maxlat_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} minlong_datap -= __tinc1_0 *
     				  __tdims1;maxlong_datap -= __tinc1_1 *
     				  __tdims1;minlat_datap -= __tinc1_2 *
     				  __tdims1;maxlat_datap -= __tinc1_3 *
     				  __tdims1;
 minlong_datap -= __offsp[0];
maxlong_datap -= __offsp[1];
minlat_datap -= __offsp[2];
maxlat_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plmap_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plmap_pp_struct *__privtrans = (pdl_plmap_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->mapform);;free(__privtrans->type);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plmap_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plmap_pp_vtable = {
		0,0, 4, 4, pdl_plmap_pp_vtable_flags,
		pdl_plmap_pp_redodims, pdl_plmap_pp_readdata, NULL,
		pdl_plmap_pp_free,NULL,NULL,pdl_plmap_pp_copy,NULL,
		sizeof(pdl_plmap_pp_struct),"pdl_plmap_pp_vtable",
		NULL
	 };

typedef struct pdl_plstring_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_na;PDL_Long  __inc_y_na;PDL_Long  __na_size;
		char *string;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstring_struct;

void pdl_plstring_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring_struct *__privtrans = (pdl_plstring_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__na_size = -1;
__creating[0] = 0;
__creating[1] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_y_na = __privtrans->__inc_y_na;
register PDL_Long __inc_x_na = __privtrans->__inc_x_na;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plstring";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__na_size <= 1) __privtrans->__na_size = 1;
   }
   if(__privtrans->__na_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__na_size == 1)) {
      __privtrans->__na_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__na_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstring:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__na_size <= 1) __privtrans->__na_size = 1;
   }
   if(__privtrans->__na_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__na_size == 1)) {
      __privtrans->__na_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__na_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstring:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_na = 0; else
		 __privtrans->__inc_x_na = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_na = 0; else
		 __privtrans->__inc_y_na = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstring_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring_struct *__privtrans = (pdl_plstring_struct *) __tr;
	
	{
	    pdl_plstring_struct *__copy = malloc(sizeof(pdl_plstring_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->string) = malloc(strlen(__privtrans->string)+1); strcpy(__copy->string,__privtrans->string);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_na=__copy->__inc_x_na;__privtrans->__inc_y_na=__copy->__inc_y_na;__copy->__na_size=__privtrans->__na_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstring_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring_struct *__privtrans = (pdl_plstring_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];x_datap += __offsp[0];
y_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_na = __privtrans->__inc_y_na;
register PDL_Long __inc_x_na = __privtrans->__inc_x_na;

c_plstring(__privtrans->__na_size, x_datap, y_datap, __privtrans->string);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstring_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring_struct *__privtrans = (pdl_plstring_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->string);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plstring_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_plstring_vtable = {
		0,0, 2, 2, pdl_plstring_vtable_flags,
		pdl_plstring_redodims, pdl_plstring_readdata, NULL,
		pdl_plstring_free,NULL,NULL,pdl_plstring_copy,NULL,
		sizeof(pdl_plstring_struct),"pdl_plstring_vtable",
		NULL
	 };

typedef struct pdl_plstring3_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_na;PDL_Long  __inc_y_na;PDL_Long  __inc_z_na;PDL_Long  __na_size;
		char *string;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstring3_struct;

void pdl_plstring3_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring3_struct *__privtrans = (pdl_plstring3_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__na_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_y_na = __privtrans->__inc_y_na;
register PDL_Long __inc_x_na = __privtrans->__inc_x_na;
register PDL_Long __inc_z_na = __privtrans->__inc_z_na;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z"};
		static int __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plstring3";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__na_size <= 1) __privtrans->__na_size = 1;
   }
   if(__privtrans->__na_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__na_size == 1)) {
      __privtrans->__na_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__na_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstring3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__na_size <= 1) __privtrans->__na_size = 1;
   }
   if(__privtrans->__na_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__na_size == 1)) {
      __privtrans->__na_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__na_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstring3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__na_size <= 1) __privtrans->__na_size = 1;
   }
   if(__privtrans->__na_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__na_size == 1)) {
      __privtrans->__na_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__na_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstring3:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_na = 0; else
		 __privtrans->__inc_x_na = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_na = 0; else
		 __privtrans->__inc_y_na = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_na = 0; else
		 __privtrans->__inc_z_na = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstring3_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring3_struct *__privtrans = (pdl_plstring3_struct *) __tr;
	
	{
	    pdl_plstring3_struct *__copy = malloc(sizeof(pdl_plstring3_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->string) = malloc(strlen(__privtrans->string)+1); strcpy(__copy->string,__privtrans->string);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_na=__copy->__inc_x_na;__privtrans->__inc_y_na=__copy->__inc_y_na;__privtrans->__inc_z_na=__copy->__inc_z_na;__copy->__na_size=__privtrans->__na_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstring3_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring3_struct *__privtrans = (pdl_plstring3_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_na = __privtrans->__inc_y_na;
register PDL_Long __inc_x_na = __privtrans->__inc_x_na;
register PDL_Long __inc_z_na = __privtrans->__inc_z_na;

c_plstring3(__privtrans->__na_size, x_datap, y_datap, z_datap, __privtrans->string);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstring3_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstring3_struct *__privtrans = (pdl_plstring3_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->string);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plstring3_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plstring3_vtable = {
		0,0, 3, 3, pdl_plstring3_vtable_flags,
		pdl_plstring3_redodims, pdl_plstring3_readdata, NULL,
		pdl_plstring3_free,NULL,NULL,pdl_plstring3_copy,NULL,
		sizeof(pdl_plstring3_struct),"pdl_plstring3_vtable",
		NULL
	 };

typedef struct pdl_plmeridians_pp_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		SV *mapform;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plmeridians_pp_struct;

void pdl_plmeridians_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeridians_pp_struct *__privtrans = (pdl_plmeridians_pp_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * dlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * dlong_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * dlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * dlat_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * minlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * minlong_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * maxlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * maxlong_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * minlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * minlat_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * maxlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * maxlat_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"dlong","dlat","minlong","maxlong","minlat","maxlat"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plmeridians_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plmeridians_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeridians_pp_struct *__privtrans = (pdl_plmeridians_pp_struct *) __tr;
	
	{
	    pdl_plmeridians_pp_struct *__copy = malloc(sizeof(pdl_plmeridians_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->mapform) = newSVsv(__privtrans->mapform);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plmeridians_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeridians_pp_struct *__privtrans = (pdl_plmeridians_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * dlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * dlong_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * dlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * dlat_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * minlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * minlong_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * maxlong_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * maxlong_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * minlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * minlat_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * maxlat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * maxlat_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];dlong_datap += __offsp[0];
dlat_datap += __offsp[1];
minlong_datap += __offsp[2];
maxlong_datap += __offsp[3];
minlat_datap += __offsp[4];
maxlat_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{

           mapform_subroutine = __privtrans->mapform;
	   check_sub_pointer (mapform_subroutine,
	     "plmeridians: mapform must be either 0 or a subroutine pointer");

           plmeridians (SvTRUE (__privtrans->mapform) ? mapform_callback : NULL,
	     (dlong_datap)[0] PDL_COMMENT("ACCESS()") , (dlat_datap)[0] PDL_COMMENT("ACCESS()") , (minlong_datap)[0] PDL_COMMENT("ACCESS()") , (maxlong_datap)[0] PDL_COMMENT("ACCESS()") , (minlat_datap)[0] PDL_COMMENT("ACCESS()") , (maxlat_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 dlong_datap += __tinc0_0;
dlat_datap += __tinc0_1;
minlong_datap += __tinc0_2;
maxlong_datap += __tinc0_3;
minlat_datap += __tinc0_4;
maxlat_datap += __tinc0_5;

	 } dlong_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dlat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
minlong_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
maxlong_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
minlat_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
maxlat_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} dlong_datap -= __tinc1_0 *
     				  __tdims1;dlat_datap -= __tinc1_1 *
     				  __tdims1;minlong_datap -= __tinc1_2 *
     				  __tdims1;maxlong_datap -= __tinc1_3 *
     				  __tdims1;minlat_datap -= __tinc1_4 *
     				  __tdims1;maxlat_datap -= __tinc1_5 *
     				  __tdims1;
 dlong_datap -= __offsp[0];
dlat_datap -= __offsp[1];
minlong_datap -= __offsp[2];
maxlong_datap -= __offsp[3];
minlat_datap -= __offsp[4];
maxlat_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plmeridians_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeridians_pp_struct *__privtrans = (pdl_plmeridians_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->mapform);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plmeridians_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plmeridians_pp_vtable = {
		0,0, 6, 6, pdl_plmeridians_pp_vtable_flags,
		pdl_plmeridians_pp_redodims, pdl_plmeridians_pp_readdata, NULL,
		pdl_plmeridians_pp_free,NULL,NULL,pdl_plmeridians_pp_copy,NULL,
		sizeof(pdl_plmeridians_pp_struct),"pdl_plmeridians_pp_vtable",
		NULL
	 };

typedef struct pdl_plshades_pp_struct {
		PDL_TRANS_START(10);
		pdl_thread  __pdlthread;PDL_Long  __inc_z_x;PDL_Long  __inc_z_y;PDL_Long  __inc_clevel_l;PDL_Long  __l_size;PDL_Long  __y_size;PDL_Long  __x_size;
		SV *defined;SV *pltr;SV *pltr_data;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plshades_pp_struct;

void pdl_plshades_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plshades_pp_struct *__privtrans = (pdl_plshades_pp_struct *) __tr;
	
	{
	    int __creating[10];
__privtrans->__l_size = -1;
__privtrans->__y_size = -1;
__privtrans->__x_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * fill_width_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * fill_width_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * cont_color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * cont_color_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cont_width_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cont_width_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Long * rectangular_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Long * rectangular_physdatap = ((PDL_Long *)((__privtrans->pdls[9])->data));

{register PDL_Long __inc_z_x = __privtrans->__inc_z_x;
register PDL_Long __inc_z_y = __privtrans->__inc_z_y;
register PDL_Long __inc_clevel_l = __privtrans->__inc_clevel_l;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"z","xmin","xmax","ymin","ymax","clevel","fill_width","cont_color","cont_width","rectangular"};
		static int __realdims[] = {2,0,0,0,0,1,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plshades_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 10
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,10,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__x_size <= 1) __privtrans->__x_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__y_size <= 1) __privtrans->__y_size = 1;
   }
   if(__privtrans->__x_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__x_size == 1)) {
      __privtrans->__x_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__x_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plshades_pp:" "Wrong dims\n");
      }
   }
   if(__privtrans->__y_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__y_size == 1)) {
      __privtrans->__y_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__y_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plshades_pp:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__l_size <= 1) __privtrans->__l_size = 1;
   }
   if(__privtrans->__l_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__l_size == 1)) {
      __privtrans->__l_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__l_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plshades_pp:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_z_x = 0; else
		 __privtrans->__inc_z_x = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_z_y = 0; else
		 __privtrans->__inc_z_y = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_clevel_l = 0; else
		 __privtrans->__inc_clevel_l = __privtrans->pdls[5]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plshades_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plshades_pp_struct *__privtrans = (pdl_plshades_pp_struct *) __tr;
	
	{
	    pdl_plshades_pp_struct *__copy = malloc(sizeof(pdl_plshades_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->defined) = newSVsv(__privtrans->defined);;(__copy->pltr) = newSVsv(__privtrans->pltr);;(__copy->pltr_data) = newSVsv(__privtrans->pltr_data);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_z_x=__copy->__inc_z_x;__privtrans->__inc_z_y=__copy->__inc_z_y;__privtrans->__inc_clevel_l=__copy->__inc_clevel_l;__copy->__l_size=__privtrans->__l_size;__copy->__y_size=__privtrans->__y_size;__copy->__x_size=__privtrans->__x_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plshades_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plshades_pp_struct *__privtrans = (pdl_plshades_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * fill_width_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * fill_width_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * cont_color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * cont_color_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cont_width_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cont_width_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Long * rectangular_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Long * rectangular_physdatap = ((PDL_Long *)((__privtrans->pdls[9])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];z_datap += __offsp[0];
xmin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymin_datap += __offsp[3];
ymax_datap += __offsp[4];
clevel_datap += __offsp[5];
fill_width_datap += __offsp[6];
cont_color_datap += __offsp[7];
cont_width_datap += __offsp[8];
rectangular_datap += __offsp[9];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_z_x = __privtrans->__inc_z_x;
register PDL_Long __inc_z_y = __privtrans->__inc_z_y;
register PDL_Long __inc_clevel_l = __privtrans->__inc_clevel_l;


           int nx    = __privtrans->__x_size;
           int ny    = __privtrans->__y_size;
           int nlvl  = __privtrans->__l_size;
           int i, j;
           PLFLT **z;
 	   void (*pltrcb) ();
           PLPointer pltrdt;

           plAlloc2dGrid (&z, nx, ny);

           for (i = 0; i < nx; i++)
             for (j = 0; j < ny; j++)
               z[i][j] = (PLFLT) (z_datap)[0+(__inc_z_x*PP_INDTERM(__privtrans->__x_size, i))+(__inc_z_y*PP_INDTERM(__privtrans->__y_size, j))] PDL_COMMENT("ACCESS()") ;

           defined_subroutine = __privtrans->defined;
	   check_sub_pointer (defined_subroutine,
	     "plshades: defined must be either 0 or a subroutine pointer");

           pltr_subroutine = __privtrans->pltr;
	   check_sub_pointer (pltr_subroutine,
	     "plshades: pltr must be either 0 or a subroutine pointer");

	   pltrcb = get_standard_pltrcb (__privtrans->pltr);
           if (pltrcb != pltr_callback)
             pltrdt = (PLPointer) SvIV (__privtrans->pltr_data);
           else
             pltrdt = __privtrans->pltr_data;

           c_plshades ((const PLFLT **)z, nx, ny,
             SvTRUE (__privtrans->defined) ? defined_callback : NULL,
             (xmin_datap)[0] PDL_COMMENT("ACCESS()") , (xmax_datap)[0] PDL_COMMENT("ACCESS()") , (ymin_datap)[0] PDL_COMMENT("ACCESS()") , (ymax_datap)[0] PDL_COMMENT("ACCESS()") ,
             clevel_datap, nlvl, (fill_width_datap)[0] PDL_COMMENT("ACCESS()") , (cont_color_datap)[0] PDL_COMMENT("ACCESS()") , (cont_width_datap)[0] PDL_COMMENT("ACCESS()") ,
             plfill, (rectangular_datap)[0] PDL_COMMENT("ACCESS()") , pltrcb, pltrdt);

           plFree2dGrid(z, nx, ny);
}	PDL_COMMENT("THREADLOOPEND")
	 z_datap += __tinc0_0;
xmin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymin_datap += __tinc0_3;
ymax_datap += __tinc0_4;
clevel_datap += __tinc0_5;
fill_width_datap += __tinc0_6;
cont_color_datap += __tinc0_7;
cont_width_datap += __tinc0_8;
rectangular_datap += __tinc0_9;

	 } z_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymin_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ymax_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
clevel_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
fill_width_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
cont_color_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
cont_width_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
rectangular_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;

	} z_datap -= __tinc1_0 *
     				  __tdims1;xmin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymin_datap -= __tinc1_3 *
     				  __tdims1;ymax_datap -= __tinc1_4 *
     				  __tdims1;clevel_datap -= __tinc1_5 *
     				  __tdims1;fill_width_datap -= __tinc1_6 *
     				  __tdims1;cont_color_datap -= __tinc1_7 *
     				  __tdims1;cont_width_datap -= __tinc1_8 *
     				  __tdims1;rectangular_datap -= __tinc1_9 *
     				  __tdims1;
 z_datap -= __offsp[0];
xmin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymin_datap -= __offsp[3];
ymax_datap -= __offsp[4];
clevel_datap -= __offsp[5];
fill_width_datap -= __offsp[6];
cont_color_datap -= __offsp[7];
cont_width_datap -= __offsp[8];
rectangular_datap -= __offsp[9];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plshades_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plshades_pp_struct *__privtrans = (pdl_plshades_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->defined);;SvREFCNT_dec(__privtrans->pltr);;SvREFCNT_dec(__privtrans->pltr_data);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plshades_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plshades_pp_vtable = {
		0,0, 10, 10, pdl_plshades_pp_vtable_flags,
		pdl_plshades_pp_redodims, pdl_plshades_pp_readdata, NULL,
		pdl_plshades_pp_free,NULL,NULL,pdl_plshades_pp_copy,NULL,
		sizeof(pdl_plshades_pp_struct),"pdl_plshades_pp_vtable",
		NULL
	 };

typedef struct pdl_plcont_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Long  __inc_f_nx;PDL_Long  __inc_f_ny;PDL_Long  __inc_clevel_nlevel;PDL_Long  __ny_size;PDL_Long  __nlevel_size;PDL_Long  __nx_size;
		SV *pltr;SV *pltr_data;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plcont_struct;

void pdl_plcont_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plcont_struct *__privtrans = (pdl_plcont_struct *) __tr;
	
	{
	    int __creating[6];
__privtrans->__ny_size = -1;
__privtrans->__nlevel_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * f_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * f_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * kx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * kx_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * lx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * lx_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * ky_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * ky_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * ly_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * ly_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Long __inc_f_nx = __privtrans->__inc_f_nx;
register PDL_Long __inc_f_ny = __privtrans->__inc_f_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"f","kx","lx","ky","ly","clevel"};
		static int __realdims[] = {2,0,0,0,0,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plcont";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plcont:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plcont:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__nlevel_size <= 1) __privtrans->__nlevel_size = 1;
   }
   if(__privtrans->__nlevel_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__nlevel_size == 1)) {
      __privtrans->__nlevel_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__nlevel_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plcont:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_f_nx = 0; else
		 __privtrans->__inc_f_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_f_ny = 0; else
		 __privtrans->__inc_f_ny = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_clevel_nlevel = 0; else
		 __privtrans->__inc_clevel_nlevel = __privtrans->pdls[5]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plcont_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plcont_struct *__privtrans = (pdl_plcont_struct *) __tr;
	
	{
	    pdl_plcont_struct *__copy = malloc(sizeof(pdl_plcont_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->pltr) = newSVsv(__privtrans->pltr);;(__copy->pltr_data) = newSVsv(__privtrans->pltr_data);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_f_nx=__copy->__inc_f_nx;__privtrans->__inc_f_ny=__copy->__inc_f_ny;__privtrans->__inc_clevel_nlevel=__copy->__inc_clevel_nlevel;__copy->__ny_size=__privtrans->__ny_size;__copy->__nlevel_size=__privtrans->__nlevel_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plcont_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plcont_struct *__privtrans = (pdl_plcont_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * f_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * f_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * kx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * kx_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * lx_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * lx_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * ky_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * ky_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * ly_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * ly_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];f_datap += __offsp[0];
kx_datap += __offsp[1];
lx_datap += __offsp[2];
ky_datap += __offsp[3];
ly_datap += __offsp[4];
clevel_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_f_nx = __privtrans->__inc_f_nx;
register PDL_Long __inc_f_ny = __privtrans->__inc_f_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;


           int i, j, size_x, size_y;
           PLFLT** ff;
	   void (*pltrcb) ();
           PLPointer pltrdt;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&ff, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               ff[i][j] = (f_datap)[0+(__inc_f_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_f_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           pltr_subroutine = __privtrans->pltr;
	   check_sub_pointer (pltr_subroutine,
	     "plcont: pltr must be either 0 or a subroutine pointer");

	   pltrcb = get_standard_pltrcb (__privtrans->pltr);
           if (pltrcb != pltr_callback)
             pltrdt = (PLPointer) SvIV (__privtrans->pltr_data);
           else
             pltrdt = __privtrans->pltr_data;

           c_plcont ((const PLFLT **)ff, size_x, size_y, (kx_datap)[0] PDL_COMMENT("ACCESS()") , (lx_datap)[0] PDL_COMMENT("ACCESS()") , (ky_datap)[0] PDL_COMMENT("ACCESS()") , (ly_datap)[0] PDL_COMMENT("ACCESS()") ,
                     clevel_datap, __privtrans->__nlevel_size,
                     pltrcb, pltrdt);

           plFree2dGrid (ff, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 f_datap += __tinc0_0;
kx_datap += __tinc0_1;
lx_datap += __tinc0_2;
ky_datap += __tinc0_3;
ly_datap += __tinc0_4;
clevel_datap += __tinc0_5;

	 } f_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
kx_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
lx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ky_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ly_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
clevel_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} f_datap -= __tinc1_0 *
     				  __tdims1;kx_datap -= __tinc1_1 *
     				  __tdims1;lx_datap -= __tinc1_2 *
     				  __tdims1;ky_datap -= __tinc1_3 *
     				  __tdims1;ly_datap -= __tinc1_4 *
     				  __tdims1;clevel_datap -= __tinc1_5 *
     				  __tdims1;
 f_datap -= __offsp[0];
kx_datap -= __offsp[1];
lx_datap -= __offsp[2];
ky_datap -= __offsp[3];
ly_datap -= __offsp[4];
clevel_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plcont_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plcont_struct *__privtrans = (pdl_plcont_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->pltr);;SvREFCNT_dec(__privtrans->pltr_data);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plcont_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_plcont_vtable = {
		0,0, 6, 6, pdl_plcont_vtable_flags,
		pdl_plcont_redodims, pdl_plcont_readdata, NULL,
		pdl_plcont_free,NULL,NULL,pdl_plcont_copy,NULL,
		sizeof(pdl_plcont_struct),"pdl_plcont_vtable",
		NULL
	 };

typedef struct pdl_plmesh_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_nx;PDL_Long  __inc_y_ny;PDL_Long  __inc_z_nx;PDL_Long  __inc_z_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plmesh_struct;

void pdl_plmesh_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plmesh_struct *__privtrans = (pdl_plmesh_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","opt"};
		static int __realdims[] = {1,1,2,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plmesh";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmesh:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmesh:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmesh:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plmesh:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_nx = 0; else
		 __privtrans->__inc_x_nx = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_ny = 0; else
		 __privtrans->__inc_y_ny = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_nx = 0; else
		 __privtrans->__inc_z_nx = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_z_ny = 0; else
		 __privtrans->__inc_z_ny = PDL_REPRINC(__privtrans->pdls[2],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plmesh_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plmesh_struct *__privtrans = (pdl_plmesh_struct *) __tr;
	
	{
	    pdl_plmesh_struct *__copy = malloc(sizeof(pdl_plmesh_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_nx=__copy->__inc_x_nx;__privtrans->__inc_y_ny=__copy->__inc_y_ny;__privtrans->__inc_z_nx=__copy->__inc_z_nx;__privtrans->__inc_z_ny=__copy->__inc_z_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plmesh_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plmesh_struct *__privtrans = (pdl_plmesh_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
opt_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;


           int i, j, size_x, size_y;
           PLFLT** zz;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&zz, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               zz[i][j] = (z_datap)[0+(__inc_z_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_z_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           c_plmesh (x_datap, y_datap, (const PLFLT **)zz, size_x, size_y, (opt_datap)[0] PDL_COMMENT("ACCESS()") );

           plFree2dGrid (zz, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
opt_datap += __tinc0_3;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
opt_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;opt_datap -= __tinc1_3 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
opt_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plmesh_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plmesh_struct *__privtrans = (pdl_plmesh_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plmesh_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plmesh_vtable = {
		0,0, 4, 4, pdl_plmesh_vtable_flags,
		pdl_plmesh_redodims, pdl_plmesh_readdata, NULL,
		pdl_plmesh_free,NULL,NULL,pdl_plmesh_copy,NULL,
		sizeof(pdl_plmesh_struct),"pdl_plmesh_vtable",
		NULL
	 };

typedef struct pdl_plmeshc_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_nx;PDL_Long  __inc_y_ny;PDL_Long  __inc_z_nx;PDL_Long  __inc_z_ny;PDL_Long  __inc_clevel_nlevel;PDL_Long  __ny_size;PDL_Long  __nlevel_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plmeshc_struct;

void pdl_plmeshc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeshc_struct *__privtrans = (pdl_plmeshc_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__ny_size = -1;
__privtrans->__nlevel_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","opt","clevel"};
		static int __realdims[] = {1,1,2,0,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plmeshc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmeshc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmeshc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmeshc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plmeshc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__nlevel_size <= 1) __privtrans->__nlevel_size = 1;
   }
   if(__privtrans->__nlevel_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nlevel_size == 1)) {
      __privtrans->__nlevel_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nlevel_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plmeshc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_nx = 0; else
		 __privtrans->__inc_x_nx = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_ny = 0; else
		 __privtrans->__inc_y_ny = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_nx = 0; else
		 __privtrans->__inc_z_nx = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_z_ny = 0; else
		 __privtrans->__inc_z_ny = PDL_REPRINC(__privtrans->pdls[2],1);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_clevel_nlevel = 0; else
		 __privtrans->__inc_clevel_nlevel = __privtrans->pdls[4]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plmeshc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeshc_struct *__privtrans = (pdl_plmeshc_struct *) __tr;
	
	{
	    pdl_plmeshc_struct *__copy = malloc(sizeof(pdl_plmeshc_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_nx=__copy->__inc_x_nx;__privtrans->__inc_y_ny=__copy->__inc_y_ny;__privtrans->__inc_z_nx=__copy->__inc_z_nx;__privtrans->__inc_z_ny=__copy->__inc_z_ny;__privtrans->__inc_clevel_nlevel=__copy->__inc_clevel_nlevel;__copy->__ny_size=__privtrans->__ny_size;__copy->__nlevel_size=__privtrans->__nlevel_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plmeshc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeshc_struct *__privtrans = (pdl_plmeshc_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
opt_datap += __offsp[3];
clevel_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;


           int i, j, size_x, size_y;
           PLFLT** zz;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&zz, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               zz[i][j] = (z_datap)[0+(__inc_z_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_z_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           c_plmeshc (x_datap, y_datap, (const PLFLT **)zz, size_x, size_y, (opt_datap)[0] PDL_COMMENT("ACCESS()") ,
                      clevel_datap, __privtrans->__nlevel_size);

           plFree2dGrid (zz, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
opt_datap += __tinc0_3;
clevel_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
opt_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
clevel_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;opt_datap -= __tinc1_3 *
     				  __tdims1;clevel_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
opt_datap -= __offsp[3];
clevel_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plmeshc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plmeshc_struct *__privtrans = (pdl_plmeshc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;
			}
			
	}
    }
    



static char pdl_plmeshc_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_plmeshc_vtable = {
		0,0, 5, 5, pdl_plmeshc_vtable_flags,
		pdl_plmeshc_redodims, pdl_plmeshc_readdata, NULL,
		pdl_plmeshc_free,NULL,NULL,pdl_plmeshc_copy,NULL,
		sizeof(pdl_plmeshc_struct),"pdl_plmeshc_vtable",
		NULL
	 };

typedef struct pdl_plot3d_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_nx;PDL_Long  __inc_y_ny;PDL_Long  __inc_z_nx;PDL_Long  __inc_z_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plot3d_struct;

void pdl_plot3d_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3d_struct *__privtrans = (pdl_plot3d_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * side_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * side_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","opt","side"};
		static int __realdims[] = {1,1,2,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plot3d";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3d:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3d:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3d:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plot3d:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_nx = 0; else
		 __privtrans->__inc_x_nx = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_ny = 0; else
		 __privtrans->__inc_y_ny = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_nx = 0; else
		 __privtrans->__inc_z_nx = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_z_ny = 0; else
		 __privtrans->__inc_z_ny = PDL_REPRINC(__privtrans->pdls[2],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plot3d_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3d_struct *__privtrans = (pdl_plot3d_struct *) __tr;
	
	{
	    pdl_plot3d_struct *__copy = malloc(sizeof(pdl_plot3d_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_nx=__copy->__inc_x_nx;__privtrans->__inc_y_ny=__copy->__inc_y_ny;__privtrans->__inc_z_nx=__copy->__inc_z_nx;__privtrans->__inc_z_ny=__copy->__inc_z_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plot3d_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3d_struct *__privtrans = (pdl_plot3d_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * side_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * side_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
opt_datap += __offsp[3];
side_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;


           int i, j, size_x, size_y;
           PLFLT** zz;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&zz, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               zz[i][j] = (z_datap)[0+(__inc_z_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_z_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           c_plot3d (x_datap, y_datap, (const PLFLT **)zz, size_x, size_y, (opt_datap)[0] PDL_COMMENT("ACCESS()") , (side_datap)[0] PDL_COMMENT("ACCESS()") );

           plFree2dGrid (zz, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
opt_datap += __tinc0_3;
side_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
opt_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
side_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;opt_datap -= __tinc1_3 *
     				  __tdims1;side_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
opt_datap -= __offsp[3];
side_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plot3d_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3d_struct *__privtrans = (pdl_plot3d_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plot3d_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plot3d_vtable = {
		0,0, 5, 5, pdl_plot3d_vtable_flags,
		pdl_plot3d_redodims, pdl_plot3d_readdata, NULL,
		pdl_plot3d_free,NULL,NULL,pdl_plot3d_copy,NULL,
		sizeof(pdl_plot3d_struct),"pdl_plot3d_vtable",
		NULL
	 };

typedef struct pdl_plot3dc_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_nx;PDL_Long  __inc_y_ny;PDL_Long  __inc_z_nx;PDL_Long  __inc_z_ny;PDL_Long  __inc_clevel_nlevel;PDL_Long  __ny_size;PDL_Long  __nlevel_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plot3dc_struct;

void pdl_plot3dc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3dc_struct *__privtrans = (pdl_plot3dc_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__ny_size = -1;
__privtrans->__nlevel_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","opt","clevel"};
		static int __realdims[] = {1,1,2,0,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plot3dc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3dc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plot3dc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__nlevel_size <= 1) __privtrans->__nlevel_size = 1;
   }
   if(__privtrans->__nlevel_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nlevel_size == 1)) {
      __privtrans->__nlevel_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nlevel_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plot3dc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_nx = 0; else
		 __privtrans->__inc_x_nx = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_ny = 0; else
		 __privtrans->__inc_y_ny = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_nx = 0; else
		 __privtrans->__inc_z_nx = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_z_ny = 0; else
		 __privtrans->__inc_z_ny = PDL_REPRINC(__privtrans->pdls[2],1);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_clevel_nlevel = 0; else
		 __privtrans->__inc_clevel_nlevel = __privtrans->pdls[4]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plot3dc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3dc_struct *__privtrans = (pdl_plot3dc_struct *) __tr;
	
	{
	    pdl_plot3dc_struct *__copy = malloc(sizeof(pdl_plot3dc_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_nx=__copy->__inc_x_nx;__privtrans->__inc_y_ny=__copy->__inc_y_ny;__privtrans->__inc_z_nx=__copy->__inc_z_nx;__privtrans->__inc_z_ny=__copy->__inc_z_ny;__privtrans->__inc_clevel_nlevel=__copy->__inc_clevel_nlevel;__copy->__ny_size=__privtrans->__ny_size;__copy->__nlevel_size=__privtrans->__nlevel_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plot3dc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3dc_struct *__privtrans = (pdl_plot3dc_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * opt_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * opt_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * clevel_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * clevel_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
opt_datap += __offsp[3];
clevel_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_ny = __privtrans->__inc_y_ny;
register PDL_Long __inc_x_nx = __privtrans->__inc_x_nx;
register PDL_Long __inc_z_nx = __privtrans->__inc_z_nx;
register PDL_Long __inc_z_ny = __privtrans->__inc_z_ny;
register PDL_Long __inc_clevel_nlevel = __privtrans->__inc_clevel_nlevel;


           int i, j, size_x, size_y;
           PLFLT** zz;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&zz, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               zz[i][j] = (z_datap)[0+(__inc_z_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_z_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           c_plot3dc (x_datap, y_datap, (const PLFLT **)zz, size_x, size_y, (opt_datap)[0] PDL_COMMENT("ACCESS()") ,
                      clevel_datap, __privtrans->__nlevel_size);

           plFree2dGrid (zz, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
opt_datap += __tinc0_3;
clevel_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
opt_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
clevel_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;opt_datap -= __tinc1_3 *
     				  __tdims1;clevel_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
opt_datap -= __offsp[3];
clevel_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plot3dc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plot3dc_struct *__privtrans = (pdl_plot3dc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;
			}
			
	}
    }
    



static char pdl_plot3dc_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_plot3dc_vtable = {
		0,0, 5, 5, pdl_plot3dc_vtable_flags,
		pdl_plot3dc_redodims, pdl_plot3dc_readdata, NULL,
		pdl_plot3dc_free,NULL,NULL,pdl_plot3dc_copy,NULL,
		sizeof(pdl_plot3dc_struct),"pdl_plot3dc_vtable",
		NULL
	 };

typedef struct pdl_plscmap1l_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Long  __inc_isty_n;PDL_Long  __inc_coord1_n;PDL_Long  __inc_coord2_n;PDL_Long  __inc_coord3_n;PDL_Long  __inc_rev_nrev;PDL_Long  __n_size;PDL_Long  __nrev_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap1l_struct;

void pdl_plscmap1l_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1l_struct *__privtrans = (pdl_plscmap1l_struct *) __tr;
	
	{
	    int __creating[6];
__privtrans->__n_size = -1;
__privtrans->__nrev_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * itype_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * itype_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * isty_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * isty_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * coord1_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * coord1_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * coord2_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * coord2_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * coord3_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * coord3_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * rev_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * rev_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Long __inc_coord1_n = __privtrans->__inc_coord1_n;
register PDL_Long __inc_coord3_n = __privtrans->__inc_coord3_n;
register PDL_Long __inc_rev_nrev = __privtrans->__inc_rev_nrev;
register PDL_Long __inc_isty_n = __privtrans->__inc_isty_n;
register PDL_Long __inc_coord2_n = __privtrans->__inc_coord2_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"itype","isty","coord1","coord2","coord3","rev"};
		static int __realdims[] = {0,1,1,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap1l";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1l:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1l:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1l:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1l:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__nrev_size <= 1) __privtrans->__nrev_size = 1;
   }
   if(__privtrans->__nrev_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__nrev_size == 1)) {
      __privtrans->__nrev_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__nrev_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1l:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_isty_n = 0; else
		 __privtrans->__inc_isty_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_coord1_n = 0; else
		 __privtrans->__inc_coord1_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_coord2_n = 0; else
		 __privtrans->__inc_coord2_n = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_coord3_n = 0; else
		 __privtrans->__inc_coord3_n = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_rev_nrev = 0; else
		 __privtrans->__inc_rev_nrev = __privtrans->pdls[5]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap1l_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1l_struct *__privtrans = (pdl_plscmap1l_struct *) __tr;
	
	{
	    pdl_plscmap1l_struct *__copy = malloc(sizeof(pdl_plscmap1l_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_isty_n=__copy->__inc_isty_n;__privtrans->__inc_coord1_n=__copy->__inc_coord1_n;__privtrans->__inc_coord2_n=__copy->__inc_coord2_n;__privtrans->__inc_coord3_n=__copy->__inc_coord3_n;__privtrans->__inc_rev_nrev=__copy->__inc_rev_nrev;__copy->__n_size=__privtrans->__n_size;__copy->__nrev_size=__privtrans->__nrev_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap1l_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1l_struct *__privtrans = (pdl_plscmap1l_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * itype_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * itype_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * isty_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * isty_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * coord1_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * coord1_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * coord2_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * coord2_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * coord3_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * coord3_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * rev_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * rev_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];itype_datap += __offsp[0];
isty_datap += __offsp[1];
coord1_datap += __offsp[2];
coord2_datap += __offsp[3];
coord3_datap += __offsp[4];
rev_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_coord1_n = __privtrans->__inc_coord1_n;
register PDL_Long __inc_coord3_n = __privtrans->__inc_coord3_n;
register PDL_Long __inc_rev_nrev = __privtrans->__inc_rev_nrev;
register PDL_Long __inc_isty_n = __privtrans->__inc_isty_n;
register PDL_Long __inc_coord2_n = __privtrans->__inc_coord2_n;


	   PLINT* rev;

	   if (__privtrans->__nrev_size == 0)
	     rev = NULL;
	   else if (__privtrans->__nrev_size == __privtrans->__n_size)
   	     rev = rev_datap;
           else
             croak ("plscmap1l: rev must have either lenght == 0 or have the same length of the other input arguments");

	   c_plscmap1l ((itype_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, isty_datap, coord1_datap,
	                       coord2_datap, coord3_datap, rev);
}	PDL_COMMENT("THREADLOOPEND")
	 itype_datap += __tinc0_0;
isty_datap += __tinc0_1;
coord1_datap += __tinc0_2;
coord2_datap += __tinc0_3;
coord3_datap += __tinc0_4;
rev_datap += __tinc0_5;

	 } itype_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
isty_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
coord1_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
coord2_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
coord3_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
rev_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} itype_datap -= __tinc1_0 *
     				  __tdims1;isty_datap -= __tinc1_1 *
     				  __tdims1;coord1_datap -= __tinc1_2 *
     				  __tdims1;coord2_datap -= __tinc1_3 *
     				  __tdims1;coord3_datap -= __tinc1_4 *
     				  __tdims1;rev_datap -= __tinc1_5 *
     				  __tdims1;
 itype_datap -= __offsp[0];
isty_datap -= __offsp[1];
coord1_datap -= __offsp[2];
coord2_datap -= __offsp[3];
coord3_datap -= __offsp[4];
rev_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap1l_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1l_struct *__privtrans = (pdl_plscmap1l_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;
			}
			
	}
    }
    



static char pdl_plscmap1l_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0,0,0};
	 pdl_transvtable pdl_plscmap1l_vtable = {
		0,0, 6, 6, pdl_plscmap1l_vtable_flags,
		pdl_plscmap1l_redodims, pdl_plscmap1l_readdata, NULL,
		pdl_plscmap1l_free,NULL,NULL,pdl_plscmap1l_copy,NULL,
		sizeof(pdl_plscmap1l_struct),"pdl_plscmap1l_vtable",
		NULL
	 };

typedef struct pdl_plshade1_pp_struct {
		PDL_TRANS_START(15);
		pdl_thread  __pdlthread;PDL_Long  __inc_a_nx;PDL_Long  __inc_a_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		SV *defined;SV *pltr;SV *pltr_data;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plshade1_pp_struct;

void pdl_plshade1_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plshade1_pp_struct *__privtrans = (pdl_plshade1_pp_struct *) __tr;
	
	{
	    int __creating[15];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
__creating[10] = 0;
__creating[11] = 0;
__creating[12] = 0;
__creating[13] = 0;
__creating[14] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * left_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * left_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * right_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * right_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * bottom_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * bottom_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * top_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * top_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * shade_min_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * shade_min_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * shade_max_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * shade_max_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * sh_cmap_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * sh_cmap_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * sh_color_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * sh_color_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * sh_width_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * sh_width_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_Double * min_color_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * min_color_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));

	PDL_Double * min_width_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Double * min_width_physdatap = ((PDL_Double *)((__privtrans->pdls[11])->data));

	PDL_Double * max_color_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Double * max_color_physdatap = ((PDL_Double *)((__privtrans->pdls[12])->data));

	PDL_Double * max_width_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Double * max_width_physdatap = ((PDL_Double *)((__privtrans->pdls[13])->data));

	PDL_Double * rectangular_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Double * rectangular_physdatap = ((PDL_Double *)((__privtrans->pdls[14])->data));

{register PDL_Long __inc_a_nx = __privtrans->__inc_a_nx;
register PDL_Long __inc_a_ny = __privtrans->__inc_a_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"a","left","right","bottom","top","shade_min","shade_max","sh_cmap","sh_color","sh_width","min_color","min_width","max_color","max_width","rectangular"};
		static int __realdims[] = {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plshade1_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 15
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,15,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plshade1_pp:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plshade1_pp:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[10]->hdrsv &&
	 (__privtrans->pdls[10]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[10]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[10]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[11]->hdrsv &&
	 (__privtrans->pdls[11]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[11]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[11]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[12]->hdrsv &&
	 (__privtrans->pdls[12]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[12]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[12]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[13]->hdrsv &&
	 (__privtrans->pdls[13]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[13]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[13]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[14]->hdrsv &&
	 (__privtrans->pdls[14]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[14]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[14]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_nx = 0; else
		 __privtrans->__inc_a_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_a_ny = 0; else
		 __privtrans->__inc_a_ny = PDL_REPRINC(__privtrans->pdls[0],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plshade1_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plshade1_pp_struct *__privtrans = (pdl_plshade1_pp_struct *) __tr;
	
	{
	    pdl_plshade1_pp_struct *__copy = malloc(sizeof(pdl_plshade1_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->defined) = newSVsv(__privtrans->defined);;(__copy->pltr) = newSVsv(__privtrans->pltr);;(__copy->pltr_data) = newSVsv(__privtrans->pltr_data);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_a_nx=__copy->__inc_a_nx;__privtrans->__inc_a_ny=__copy->__inc_a_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plshade1_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plshade1_pp_struct *__privtrans = (pdl_plshade1_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * left_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * left_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * right_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * right_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * bottom_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * bottom_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * top_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * top_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * shade_min_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * shade_min_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * shade_max_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * shade_max_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * sh_cmap_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * sh_cmap_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * sh_color_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * sh_color_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * sh_width_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * sh_width_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_Double * min_color_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * min_color_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));

	PDL_Double * min_width_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Double * min_width_physdatap = ((PDL_Double *)((__privtrans->pdls[11])->data));

	PDL_Double * max_color_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Double * max_color_physdatap = ((PDL_Double *)((__privtrans->pdls[12])->data));

	PDL_Double * max_width_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Double * max_width_physdatap = ((PDL_Double *)((__privtrans->pdls[13])->data));

	PDL_Double * rectangular_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Double * rectangular_physdatap = ((PDL_Double *)((__privtrans->pdls[14])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];a_datap += __offsp[0];
left_datap += __offsp[1];
right_datap += __offsp[2];
bottom_datap += __offsp[3];
top_datap += __offsp[4];
shade_min_datap += __offsp[5];
shade_max_datap += __offsp[6];
sh_cmap_datap += __offsp[7];
sh_color_datap += __offsp[8];
sh_width_datap += __offsp[9];
min_color_datap += __offsp[10];
min_width_datap += __offsp[11];
max_color_datap += __offsp[12];
max_width_datap += __offsp[13];
rectangular_datap += __offsp[14];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_nx = __privtrans->__inc_a_nx;
register PDL_Long __inc_a_ny = __privtrans->__inc_a_ny;


           int i, j, size_x, size_y;
           PLFLT* a;
	   void (*pltrcb) ();
           PLPointer pltrdt;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           New(3, a, size_x * size_y, PLFLT);
           if(a == NULL) croak("Failed to allocate memory in plshade1_pp");

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               a[i * size_y + j] = (PLFLT) (a_datap)[0+(__inc_a_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_a_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           defined_subroutine = __privtrans->defined;
	   check_sub_pointer (defined_subroutine,
	     "plshade1: defined must be either 0 or a subroutine pointer");

           pltr_subroutine = __privtrans->pltr;
	   check_sub_pointer (pltr_subroutine,
	     "plshade1: pltr must be either 0 or a subroutine pointer");

	   pltrcb = get_standard_pltrcb (__privtrans->pltr);
           if (pltrcb != pltr_callback)
             pltrdt = (PLPointer) SvIV (__privtrans->pltr_data);
           else
             pltrdt = __privtrans->pltr_data;

           c_plshade1 (a, size_x, size_y,
             SvTRUE (__privtrans->defined) ? defined_callback : NULL,
             (left_datap)[0] PDL_COMMENT("ACCESS()") , (right_datap)[0] PDL_COMMENT("ACCESS()") , (bottom_datap)[0] PDL_COMMENT("ACCESS()") , (top_datap)[0] PDL_COMMENT("ACCESS()") ,
             (shade_min_datap)[0] PDL_COMMENT("ACCESS()") , (shade_max_datap)[0] PDL_COMMENT("ACCESS()") , (sh_cmap_datap)[0] PDL_COMMENT("ACCESS()") , (sh_color_datap)[0] PDL_COMMENT("ACCESS()") , (sh_width_datap)[0] PDL_COMMENT("ACCESS()") ,
             (min_color_datap)[0] PDL_COMMENT("ACCESS()") , (min_width_datap)[0] PDL_COMMENT("ACCESS()") , (max_color_datap)[0] PDL_COMMENT("ACCESS()") , (max_width_datap)[0] PDL_COMMENT("ACCESS()") ,
             plfill, (rectangular_datap)[0] PDL_COMMENT("ACCESS()") , pltrcb, pltrdt);

           Safefree (a);
}	PDL_COMMENT("THREADLOOPEND")
	 a_datap += __tinc0_0;
left_datap += __tinc0_1;
right_datap += __tinc0_2;
bottom_datap += __tinc0_3;
top_datap += __tinc0_4;
shade_min_datap += __tinc0_5;
shade_max_datap += __tinc0_6;
sh_cmap_datap += __tinc0_7;
sh_color_datap += __tinc0_8;
sh_width_datap += __tinc0_9;
min_color_datap += __tinc0_10;
min_width_datap += __tinc0_11;
max_color_datap += __tinc0_12;
max_width_datap += __tinc0_13;
rectangular_datap += __tinc0_14;

	 } a_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
left_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
right_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
bottom_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
top_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
shade_min_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
shade_max_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
sh_cmap_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
sh_color_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
sh_width_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
min_color_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
min_width_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
max_color_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
max_width_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
rectangular_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;

	} a_datap -= __tinc1_0 *
     				  __tdims1;left_datap -= __tinc1_1 *
     				  __tdims1;right_datap -= __tinc1_2 *
     				  __tdims1;bottom_datap -= __tinc1_3 *
     				  __tdims1;top_datap -= __tinc1_4 *
     				  __tdims1;shade_min_datap -= __tinc1_5 *
     				  __tdims1;shade_max_datap -= __tinc1_6 *
     				  __tdims1;sh_cmap_datap -= __tinc1_7 *
     				  __tdims1;sh_color_datap -= __tinc1_8 *
     				  __tdims1;sh_width_datap -= __tinc1_9 *
     				  __tdims1;min_color_datap -= __tinc1_10 *
     				  __tdims1;min_width_datap -= __tinc1_11 *
     				  __tdims1;max_color_datap -= __tinc1_12 *
     				  __tdims1;max_width_datap -= __tinc1_13 *
     				  __tdims1;rectangular_datap -= __tinc1_14 *
     				  __tdims1;
 a_datap -= __offsp[0];
left_datap -= __offsp[1];
right_datap -= __offsp[2];
bottom_datap -= __offsp[3];
top_datap -= __offsp[4];
shade_min_datap -= __offsp[5];
shade_max_datap -= __offsp[6];
sh_cmap_datap -= __offsp[7];
sh_color_datap -= __offsp[8];
sh_width_datap -= __offsp[9];
min_color_datap -= __offsp[10];
min_width_datap -= __offsp[11];
max_color_datap -= __offsp[12];
max_width_datap -= __offsp[13];
rectangular_datap -= __offsp[14];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plshade1_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plshade1_pp_struct *__privtrans = (pdl_plshade1_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->defined);;SvREFCNT_dec(__privtrans->pltr);;SvREFCNT_dec(__privtrans->pltr_data);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plshade1_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plshade1_pp_vtable = {
		0,0, 15, 15, pdl_plshade1_pp_vtable_flags,
		pdl_plshade1_pp_redodims, pdl_plshade1_pp_readdata, NULL,
		pdl_plshade1_pp_free,NULL,NULL,pdl_plshade1_pp_copy,NULL,
		sizeof(pdl_plshade1_pp_struct),"pdl_plshade1_pp_vtable",
		NULL
	 };

typedef struct pdl_plimage_struct {
		PDL_TRANS_START(11);
		pdl_thread  __pdlthread;PDL_Long  __inc_idata_nx;PDL_Long  __inc_idata_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plimage_struct;

void pdl_plimage_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plimage_struct *__privtrans = (pdl_plimage_struct *) __tr;
	
	{
	    int __creating[11];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
__creating[10] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * idata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * idata_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * zmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * zmin_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * zmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * zmax_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * Dxmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * Dxmin_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * Dxmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * Dxmax_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * Dymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * Dymin_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_Double * Dymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * Dymax_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));

{register PDL_Long __inc_idata_nx = __privtrans->__inc_idata_nx;
register PDL_Long __inc_idata_ny = __privtrans->__inc_idata_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"idata","xmin","xmax","ymin","ymax","zmin","zmax","Dxmin","Dxmax","Dymin","Dymax"};
		static int __realdims[] = {2,0,0,0,0,0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plimage";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 11
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,11,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plimage:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plimage:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[10]->hdrsv &&
	 (__privtrans->pdls[10]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[10]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[10]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_idata_nx = 0; else
		 __privtrans->__inc_idata_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_idata_ny = 0; else
		 __privtrans->__inc_idata_ny = PDL_REPRINC(__privtrans->pdls[0],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plimage_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plimage_struct *__privtrans = (pdl_plimage_struct *) __tr;
	
	{
	    pdl_plimage_struct *__copy = malloc(sizeof(pdl_plimage_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_idata_nx=__copy->__inc_idata_nx;__privtrans->__inc_idata_ny=__copy->__inc_idata_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plimage_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plimage_struct *__privtrans = (pdl_plimage_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * idata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * idata_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * zmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * zmin_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * zmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * zmax_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * Dxmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * Dxmin_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * Dxmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * Dxmax_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_Double * Dymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * Dymin_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

	PDL_Double * Dymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * Dymax_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];idata_datap += __offsp[0];
xmin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymin_datap += __offsp[3];
ymax_datap += __offsp[4];
zmin_datap += __offsp[5];
zmax_datap += __offsp[6];
Dxmin_datap += __offsp[7];
Dxmax_datap += __offsp[8];
Dymin_datap += __offsp[9];
Dymax_datap += __offsp[10];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_idata_nx = __privtrans->__inc_idata_nx;
register PDL_Long __inc_idata_ny = __privtrans->__inc_idata_ny;


           int i, j, size_x, size_y;
           PLFLT** idata;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&idata, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               idata[i][j] = (idata_datap)[0+(__inc_idata_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_idata_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           plimage ((const PLFLT **)idata, size_x, size_y,
	     (xmin_datap)[0] PDL_COMMENT("ACCESS()") , (xmax_datap)[0] PDL_COMMENT("ACCESS()") , (ymin_datap)[0] PDL_COMMENT("ACCESS()") , (ymax_datap)[0] PDL_COMMENT("ACCESS()") , (zmin_datap)[0] PDL_COMMENT("ACCESS()") , (zmax_datap)[0] PDL_COMMENT("ACCESS()") ,
             (Dxmin_datap)[0] PDL_COMMENT("ACCESS()") , (Dxmax_datap)[0] PDL_COMMENT("ACCESS()") , (Dymin_datap)[0] PDL_COMMENT("ACCESS()") , (Dymax_datap)[0] PDL_COMMENT("ACCESS()") );

           plFree2dGrid (idata, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 idata_datap += __tinc0_0;
xmin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymin_datap += __tinc0_3;
ymax_datap += __tinc0_4;
zmin_datap += __tinc0_5;
zmax_datap += __tinc0_6;
Dxmin_datap += __tinc0_7;
Dxmax_datap += __tinc0_8;
Dymin_datap += __tinc0_9;
Dymax_datap += __tinc0_10;

	 } idata_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymin_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ymax_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
zmin_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
zmax_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
Dxmin_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
Dxmax_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
Dymin_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
Dymax_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;

	} idata_datap -= __tinc1_0 *
     				  __tdims1;xmin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymin_datap -= __tinc1_3 *
     				  __tdims1;ymax_datap -= __tinc1_4 *
     				  __tdims1;zmin_datap -= __tinc1_5 *
     				  __tdims1;zmax_datap -= __tinc1_6 *
     				  __tdims1;Dxmin_datap -= __tinc1_7 *
     				  __tdims1;Dxmax_datap -= __tinc1_8 *
     				  __tdims1;Dymin_datap -= __tinc1_9 *
     				  __tdims1;Dymax_datap -= __tinc1_10 *
     				  __tdims1;
 idata_datap -= __offsp[0];
xmin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymin_datap -= __offsp[3];
ymax_datap -= __offsp[4];
zmin_datap -= __offsp[5];
zmax_datap -= __offsp[6];
Dxmin_datap -= __offsp[7];
Dxmax_datap -= __offsp[8];
Dymin_datap -= __offsp[9];
Dymax_datap -= __offsp[10];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plimage_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plimage_struct *__privtrans = (pdl_plimage_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plimage_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plimage_vtable = {
		0,0, 11, 11, pdl_plimage_vtable_flags,
		pdl_plimage_redodims, pdl_plimage_readdata, NULL,
		pdl_plimage_free,NULL,NULL,pdl_plimage_copy,NULL,
		sizeof(pdl_plimage_struct),"pdl_plimage_vtable",
		NULL
	 };

typedef struct pdl_plimagefr_struct {
		PDL_TRANS_START(9);
		pdl_thread  __pdlthread;PDL_Long  __inc_idata_nx;PDL_Long  __inc_idata_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		SV *pltr;SV *pltr_data;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plimagefr_struct;

void pdl_plimagefr_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plimagefr_struct *__privtrans = (pdl_plimagefr_struct *) __tr;
	
	{
	    int __creating[9];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * idata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * idata_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * zmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * zmin_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * zmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * zmax_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * valuemin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * valuemin_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * valuemax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * valuemax_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

{register PDL_Long __inc_idata_nx = __privtrans->__inc_idata_nx;
register PDL_Long __inc_idata_ny = __privtrans->__inc_idata_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"idata","xmin","xmax","ymin","ymax","zmin","zmax","valuemin","valuemax"};
		static int __realdims[] = {2,0,0,0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plimagefr";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 9
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,9,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plimagefr:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plimagefr:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_idata_nx = 0; else
		 __privtrans->__inc_idata_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_idata_ny = 0; else
		 __privtrans->__inc_idata_ny = PDL_REPRINC(__privtrans->pdls[0],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plimagefr_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plimagefr_struct *__privtrans = (pdl_plimagefr_struct *) __tr;
	
	{
	    pdl_plimagefr_struct *__copy = malloc(sizeof(pdl_plimagefr_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->pltr) = newSVsv(__privtrans->pltr);;(__copy->pltr_data) = newSVsv(__privtrans->pltr_data);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_idata_nx=__copy->__inc_idata_nx;__privtrans->__inc_idata_ny=__copy->__inc_idata_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plimagefr_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plimagefr_struct *__privtrans = (pdl_plimagefr_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * idata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * idata_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * zmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * zmin_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * zmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * zmax_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * valuemin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * valuemin_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_Double * valuemax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * valuemax_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];idata_datap += __offsp[0];
xmin_datap += __offsp[1];
xmax_datap += __offsp[2];
ymin_datap += __offsp[3];
ymax_datap += __offsp[4];
zmin_datap += __offsp[5];
zmax_datap += __offsp[6];
valuemin_datap += __offsp[7];
valuemax_datap += __offsp[8];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_idata_nx = __privtrans->__inc_idata_nx;
register PDL_Long __inc_idata_ny = __privtrans->__inc_idata_ny;


           int i, j, size_x, size_y;
           PLFLT** idata;
 	   void (*pltrcb) ();
           PLPointer pltrdt;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           pltr_subroutine = __privtrans->pltr;
	   check_sub_pointer (pltr_subroutine, "plimagefr: pltr must be either 0 or a subroutine pointer");

	   pltrcb = get_standard_pltrcb (__privtrans->pltr);
           if (pltrcb != pltr_callback)
             pltrdt = (PLPointer) SvIV (__privtrans->pltr_data);
           else
             pltrdt = __privtrans->pltr_data;

           plAlloc2dGrid (&idata, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               idata[i][j] = (idata_datap)[0+(__inc_idata_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_idata_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;

           c_plimagefr ((const PLFLT **)idata, size_x, size_y,
	     (xmin_datap)[0] PDL_COMMENT("ACCESS()") , (xmax_datap)[0] PDL_COMMENT("ACCESS()") , (ymin_datap)[0] PDL_COMMENT("ACCESS()") , (ymax_datap)[0] PDL_COMMENT("ACCESS()") , (zmin_datap)[0] PDL_COMMENT("ACCESS()") , (zmax_datap)[0] PDL_COMMENT("ACCESS()") ,
             (valuemin_datap)[0] PDL_COMMENT("ACCESS()") , (valuemax_datap)[0] PDL_COMMENT("ACCESS()") ,
             (SvTRUE (__privtrans->pltr) ? pltrcb : NULL),
             (SvTRUE (__privtrans->pltr) ? pltrdt : NULL));

           plFree2dGrid (idata, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 idata_datap += __tinc0_0;
xmin_datap += __tinc0_1;
xmax_datap += __tinc0_2;
ymin_datap += __tinc0_3;
ymax_datap += __tinc0_4;
zmin_datap += __tinc0_5;
zmax_datap += __tinc0_6;
valuemin_datap += __tinc0_7;
valuemax_datap += __tinc0_8;

	 } idata_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmin_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xmax_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymin_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ymax_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
zmin_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
zmax_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
valuemin_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
valuemax_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;

	} idata_datap -= __tinc1_0 *
     				  __tdims1;xmin_datap -= __tinc1_1 *
     				  __tdims1;xmax_datap -= __tinc1_2 *
     				  __tdims1;ymin_datap -= __tinc1_3 *
     				  __tdims1;ymax_datap -= __tinc1_4 *
     				  __tdims1;zmin_datap -= __tinc1_5 *
     				  __tdims1;zmax_datap -= __tinc1_6 *
     				  __tdims1;valuemin_datap -= __tinc1_7 *
     				  __tdims1;valuemax_datap -= __tinc1_8 *
     				  __tdims1;
 idata_datap -= __offsp[0];
xmin_datap -= __offsp[1];
xmax_datap -= __offsp[2];
ymin_datap -= __offsp[3];
ymax_datap -= __offsp[4];
zmin_datap -= __offsp[5];
zmax_datap -= __offsp[6];
valuemin_datap -= __offsp[7];
valuemax_datap -= __offsp[8];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plimagefr_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plimagefr_struct *__privtrans = (pdl_plimagefr_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->pltr);;SvREFCNT_dec(__privtrans->pltr_data);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plimagefr_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plimagefr_vtable = {
		0,0, 9, 9, pdl_plimagefr_vtable_flags,
		pdl_plimagefr_redodims, pdl_plimagefr_readdata, NULL,
		pdl_plimagefr_free,NULL,NULL,pdl_plimagefr_copy,NULL,
		sizeof(pdl_plimagefr_struct),"pdl_plimagefr_vtable",
		NULL
	 };

typedef struct pdl_plstripc_pp_struct {
		PDL_TRANS_START(14);
		pdl_thread  __pdlthread;PDL_Long  __inc_colline_n;PDL_Long  __inc_styline_n;PDL_Long  __n_size;
		char *xspec;char *yspec;SV *legline;char *labx;char *laby;char *labtop;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plstripc_pp_struct;

void pdl_plstripc_pp_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripc_pp_struct *__privtrans = (pdl_plstripc_pp_struct *) __tr;
	
	{
	    int __creating[14];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
__creating[10] = 0;
__creating[11] = 0;
__creating[12] = 0;
__creating[13] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[13]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xjump_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xjump_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * xlpos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * xlpos_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * ylpos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * ylpos_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * y_ascl_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * y_ascl_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * acc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * acc_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Long * colbox_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Long * colbox_physdatap = ((PDL_Long *)((__privtrans->pdls[9])->data));

	PDL_Long * collab_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Long * collab_physdatap = ((PDL_Long *)((__privtrans->pdls[10])->data));

	PDL_Long * colline_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Long * colline_physdatap = ((PDL_Long *)((__privtrans->pdls[11])->data));

	PDL_Long * styline_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Long * styline_physdatap = ((PDL_Long *)((__privtrans->pdls[12])->data));

	PDL_Long * id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Long * id_physdatap = ((PDL_Long *)((__privtrans->pdls[13])->data));

{register PDL_Long __inc_styline_n = __privtrans->__inc_styline_n;
register PDL_Long __inc_colline_n = __privtrans->__inc_colline_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xmin","xmax","xjump","ymin","ymax","xlpos","ylpos","y_ascl","acc","colbox","collab","colline","styline","id"};
		static int __realdims[] = {0,0,0,0,0,0,0,0,0,0,0,1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plstripc_pp";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 14
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,14,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[11]))->ndims < 1) {
      if (((__privtrans->pdls[11]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[11]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[11]))->dims[0];
   } else if(((__privtrans->pdls[11]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[11]))->dims[0]) {
      if(((__privtrans->pdls[11]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstripc_pp:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[11])));
   if(((__privtrans->pdls[12]))->ndims < 1) {
      if (((__privtrans->pdls[12]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[12]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[12]))->dims[0];
   } else if(((__privtrans->pdls[12]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[12]))->dims[0]) {
      if(((__privtrans->pdls[12]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plstripc_pp:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[12])));
if(!__creating[13]) {
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,13,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[10]->hdrsv &&
	 (__privtrans->pdls[10]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[10]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[10]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[11]->hdrsv &&
	 (__privtrans->pdls[11]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[11]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[11]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[12]->hdrsv &&
	 (__privtrans->pdls[12]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[12]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[12]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[13] && 
     __privtrans->pdls[13]->hdrsv &&
	 (__privtrans->pdls[13]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[13]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[13]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[13]->hdrsv != hdrp ){
	 if( __privtrans->pdls[13]->hdrsv && __privtrans->pdls[13]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[13]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[13]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[13]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[11]->ndims <= 0 || __privtrans->pdls[11]->dims[0] <= 1)
		  __privtrans->__inc_colline_n = 0; else
		 __privtrans->__inc_colline_n = __privtrans->pdls[11]->dimincs[0];if(__privtrans->pdls[12]->ndims <= 0 || __privtrans->pdls[12]->dims[0] <= 1)
		  __privtrans->__inc_styline_n = 0; else
		 __privtrans->__inc_styline_n = __privtrans->pdls[12]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plstripc_pp_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripc_pp_struct *__privtrans = (pdl_plstripc_pp_struct *) __tr;
	
	{
	    pdl_plstripc_pp_struct *__copy = malloc(sizeof(pdl_plstripc_pp_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->xspec) = malloc(strlen(__privtrans->xspec)+1); strcpy(__copy->xspec,__privtrans->xspec);;(__copy->yspec) = malloc(strlen(__privtrans->yspec)+1); strcpy(__copy->yspec,__privtrans->yspec);;(__copy->legline) = newSVsv(__privtrans->legline);;(__copy->labx) = malloc(strlen(__privtrans->labx)+1); strcpy(__copy->labx,__privtrans->labx);;(__copy->laby) = malloc(strlen(__privtrans->laby)+1); strcpy(__copy->laby,__privtrans->laby);;(__copy->labtop) = malloc(strlen(__privtrans->labtop)+1); strcpy(__copy->labtop,__privtrans->labtop);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_colline_n=__copy->__inc_colline_n;__privtrans->__inc_styline_n=__copy->__inc_styline_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plstripc_pp_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripc_pp_struct *__privtrans = (pdl_plstripc_pp_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * xmin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xmin_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * xmax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * xmax_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xjump_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xjump_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * ymin_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * ymin_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * ymax_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * ymax_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * xlpos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * xlpos_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Double * ylpos_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * ylpos_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * y_ascl_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * y_ascl_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * acc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * acc_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Long * colbox_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Long * colbox_physdatap = ((PDL_Long *)((__privtrans->pdls[9])->data));

	PDL_Long * collab_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Long * collab_physdatap = ((PDL_Long *)((__privtrans->pdls[10])->data));

	PDL_Long * colline_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Long * colline_physdatap = ((PDL_Long *)((__privtrans->pdls[11])->data));

	PDL_Long * styline_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Long * styline_physdatap = ((PDL_Long *)((__privtrans->pdls[12])->data));

	PDL_Long * id_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Long * id_physdatap = ((PDL_Long *)((__privtrans->pdls[13])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];xmin_datap += __offsp[0];
xmax_datap += __offsp[1];
xjump_datap += __offsp[2];
ymin_datap += __offsp[3];
ymax_datap += __offsp[4];
xlpos_datap += __offsp[5];
ylpos_datap += __offsp[6];
y_ascl_datap += __offsp[7];
acc_datap += __offsp[8];
colbox_datap += __offsp[9];
collab_datap += __offsp[10];
colline_datap += __offsp[11];
styline_datap += __offsp[12];
id_datap += __offsp[13];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_styline_n = __privtrans->__inc_styline_n;
register PDL_Long __inc_colline_n = __privtrans->__inc_colline_n;


           I32 i;
           PLINT id;
           char* legline[4];
           SV* sv_legline = __privtrans->legline;
           AV* av_legline;

           if (! SvROK (sv_legline)
               || SvTYPE (SvRV (sv_legline)) != SVt_PVAV)
             croak ("plstripc: legline must be a reference to an array");

           av_legline = (AV*) SvRV (sv_legline);

           if (av_len (av_legline) != 3)
             croak ("plstripc: legline must have four elements");

           if (__privtrans->__n_size != 4)
             croak ("plstripc: colline and styline must have four elements");

           for (i = 0; i < 4; i++) {
             SV** elem = av_fetch (av_legline, i, 0);
             legline[i] = (char *) SvPV_nolen (*elem);
           }

           c_plstripc (&id, __privtrans->xspec, __privtrans->yspec,
	     (xmin_datap)[0] PDL_COMMENT("ACCESS()") , (xmax_datap)[0] PDL_COMMENT("ACCESS()") , (xjump_datap)[0] PDL_COMMENT("ACCESS()") , (ymin_datap)[0] PDL_COMMENT("ACCESS()") , (ymax_datap)[0] PDL_COMMENT("ACCESS()") ,
	     (xlpos_datap)[0] PDL_COMMENT("ACCESS()") , (ylpos_datap)[0] PDL_COMMENT("ACCESS()") ,(y_ascl_datap)[0] PDL_COMMENT("ACCESS()") , (acc_datap)[0] PDL_COMMENT("ACCESS()") , (colbox_datap)[0] PDL_COMMENT("ACCESS()") , (collab_datap)[0] PDL_COMMENT("ACCESS()") ,
	     colline_datap, styline_datap, (const char **)legline,
	     __privtrans->labx, __privtrans->laby, __privtrans->labtop);

           (id_datap)[0] PDL_COMMENT("ACCESS()")  = (int) id;
}	PDL_COMMENT("THREADLOOPEND")
	 xmin_datap += __tinc0_0;
xmax_datap += __tinc0_1;
xjump_datap += __tinc0_2;
ymin_datap += __tinc0_3;
ymax_datap += __tinc0_4;
xlpos_datap += __tinc0_5;
ylpos_datap += __tinc0_6;
y_ascl_datap += __tinc0_7;
acc_datap += __tinc0_8;
colbox_datap += __tinc0_9;
collab_datap += __tinc0_10;
colline_datap += __tinc0_11;
styline_datap += __tinc0_12;
id_datap += __tinc0_13;

	 } xmin_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
xmax_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xjump_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
ymin_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
ymax_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
xlpos_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
ylpos_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
y_ascl_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
acc_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
colbox_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
collab_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
colline_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
styline_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
id_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;

	} xmin_datap -= __tinc1_0 *
     				  __tdims1;xmax_datap -= __tinc1_1 *
     				  __tdims1;xjump_datap -= __tinc1_2 *
     				  __tdims1;ymin_datap -= __tinc1_3 *
     				  __tdims1;ymax_datap -= __tinc1_4 *
     				  __tdims1;xlpos_datap -= __tinc1_5 *
     				  __tdims1;ylpos_datap -= __tinc1_6 *
     				  __tdims1;y_ascl_datap -= __tinc1_7 *
     				  __tdims1;acc_datap -= __tinc1_8 *
     				  __tdims1;colbox_datap -= __tinc1_9 *
     				  __tdims1;collab_datap -= __tinc1_10 *
     				  __tdims1;colline_datap -= __tinc1_11 *
     				  __tdims1;styline_datap -= __tinc1_12 *
     				  __tdims1;id_datap -= __tinc1_13 *
     				  __tdims1;
 xmin_datap -= __offsp[0];
xmax_datap -= __offsp[1];
xjump_datap -= __offsp[2];
ymin_datap -= __offsp[3];
ymax_datap -= __offsp[4];
xlpos_datap -= __offsp[5];
ylpos_datap -= __offsp[6];
y_ascl_datap -= __offsp[7];
acc_datap -= __offsp[8];
colbox_datap -= __offsp[9];
collab_datap -= __offsp[10];
colline_datap -= __offsp[11];
styline_datap -= __offsp[12];
id_datap -= __offsp[13];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plstripc_pp_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plstripc_pp_struct *__privtrans = (pdl_plstripc_pp_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->xspec);;free(__privtrans->yspec);;SvREFCNT_dec(__privtrans->legline);;free(__privtrans->labx);;free(__privtrans->laby);;free(__privtrans->labtop);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plstripc_pp_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plstripc_pp_vtable = {
		0,0, 13, 14, pdl_plstripc_pp_vtable_flags,
		pdl_plstripc_pp_redodims, pdl_plstripc_pp_readdata, NULL,
		pdl_plstripc_pp_free,NULL,NULL,pdl_plstripc_pp_copy,NULL,
		sizeof(pdl_plstripc_pp_struct),"pdl_plstripc_pp_vtable",
		NULL
	 };

typedef struct pdl_plgriddata_struct {
		PDL_TRANS_START(8);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_npts;PDL_Long  __inc_y_npts;PDL_Long  __inc_z_npts;PDL_Long  __inc_xg_nptsx;PDL_Long  __inc_yg_nptsy;PDL_Long  __inc_zg_nptsx;PDL_Long  __inc_zg_nptsy;PDL_Long  __nptsy_size;PDL_Long  __nptsx_size;PDL_Long  __npts_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgriddata_struct;

void pdl_plgriddata_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgriddata_struct *__privtrans = (pdl_plgriddata_struct *) __tr;
	
	{
	    int __creating[8];
__privtrans->__nptsy_size = -1;
__privtrans->__nptsx_size = -1;
__privtrans->__npts_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * xg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * xg_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * yg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * yg_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * type_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * type_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * zg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * zg_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Long __inc_y_npts = __privtrans->__inc_y_npts;
register PDL_Long __inc_zg_nptsx = __privtrans->__inc_zg_nptsx;
register PDL_Long __inc_zg_nptsy = __privtrans->__inc_zg_nptsy;
register PDL_Long __inc_xg_nptsx = __privtrans->__inc_xg_nptsx;
register PDL_Long __inc_yg_nptsy = __privtrans->__inc_yg_nptsy;
register PDL_Long __inc_x_npts = __privtrans->__inc_x_npts;
register PDL_Long __inc_z_npts = __privtrans->__inc_z_npts;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","y","z","xg","yg","type","data","zg"};
		static int __realdims[] = {1,1,1,1,1,0,0,2};
		static char __funcname[] = "PDL::Graphics::PLplot::plgriddata";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__npts_size <= 1) __privtrans->__npts_size = 1;
   }
   if(__privtrans->__npts_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__npts_size == 1)) {
      __privtrans->__npts_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__npts_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__npts_size <= 1) __privtrans->__npts_size = 1;
   }
   if(__privtrans->__npts_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__npts_size == 1)) {
      __privtrans->__npts_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__npts_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__npts_size <= 1) __privtrans->__npts_size = 1;
   }
   if(__privtrans->__npts_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__npts_size == 1)) {
      __privtrans->__npts_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__npts_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__nptsx_size <= 1) __privtrans->__nptsx_size = 1;
   }
   if(__privtrans->__nptsx_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nptsx_size == 1)) {
      __privtrans->__nptsx_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nptsx_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__nptsy_size <= 1) __privtrans->__nptsy_size = 1;
   }
   if(__privtrans->__nptsy_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nptsy_size == 1)) {
      __privtrans->__nptsy_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nptsy_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
if(!__creating[7]) {
   if(((__privtrans->pdls[7]))->ndims < 2) {
      if (((__privtrans->pdls[7]))->ndims < 1 && __privtrans->__nptsx_size <= 1) __privtrans->__nptsx_size = 1;
      if (((__privtrans->pdls[7]))->ndims < 2 && __privtrans->__nptsy_size <= 1) __privtrans->__nptsy_size = 1;
   }
   if(__privtrans->__nptsx_size == -1 || (((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__nptsx_size == 1)) {
      __privtrans->__nptsx_size = ((__privtrans->pdls[7]))->dims[0];
   } else if(((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__nptsx_size != ((__privtrans->pdls[7]))->dims[0]) {
      if(((__privtrans->pdls[7]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
   if(__privtrans->__nptsy_size == -1 || (((__privtrans->pdls[7]))->ndims > 1 && __privtrans->__nptsy_size == 1)) {
      __privtrans->__nptsy_size = ((__privtrans->pdls[7]))->dims[1];
   } else if(((__privtrans->pdls[7]))->ndims > 1 && __privtrans->__nptsy_size != ((__privtrans->pdls[7]))->dims[1]) {
      if(((__privtrans->pdls[7]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plgriddata:" "Wrong dims\n");
      }
   }
} else {
 int dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__nptsx_size;dims[1] = __privtrans->__nptsy_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,7,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[7] && 
     __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[7]->hdrsv != hdrp ){
	 if( __privtrans->pdls[7]->hdrsv && __privtrans->pdls[7]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[7]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[7]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[7]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_npts = 0; else
		 __privtrans->__inc_x_npts = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_npts = 0; else
		 __privtrans->__inc_y_npts = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_z_npts = 0; else
		 __privtrans->__inc_z_npts = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_xg_nptsx = 0; else
		 __privtrans->__inc_xg_nptsx = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_yg_nptsy = 0; else
		 __privtrans->__inc_yg_nptsy = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[7]->ndims <= 0 || __privtrans->pdls[7]->dims[0] <= 1)
		  __privtrans->__inc_zg_nptsx = 0; else
		 __privtrans->__inc_zg_nptsx = PDL_REPRINC(__privtrans->pdls[7],0);if(__privtrans->pdls[7]->ndims <= 1 || __privtrans->pdls[7]->dims[1] <= 1)
		  __privtrans->__inc_zg_nptsy = 0; else
		 __privtrans->__inc_zg_nptsy = PDL_REPRINC(__privtrans->pdls[7],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgriddata_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgriddata_struct *__privtrans = (pdl_plgriddata_struct *) __tr;
	
	{
	    pdl_plgriddata_struct *__copy = malloc(sizeof(pdl_plgriddata_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_npts=__copy->__inc_x_npts;__privtrans->__inc_y_npts=__copy->__inc_y_npts;__privtrans->__inc_z_npts=__copy->__inc_z_npts;__privtrans->__inc_xg_nptsx=__copy->__inc_xg_nptsx;__privtrans->__inc_yg_nptsy=__copy->__inc_yg_nptsy;__privtrans->__inc_zg_nptsx=__copy->__inc_zg_nptsx;__privtrans->__inc_zg_nptsy=__copy->__inc_zg_nptsy;__copy->__nptsy_size=__privtrans->__nptsy_size;__copy->__nptsx_size=__privtrans->__nptsx_size;__copy->__npts_size=__privtrans->__npts_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgriddata_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgriddata_struct *__privtrans = (pdl_plgriddata_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * z_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * z_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * xg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * xg_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * yg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * yg_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * type_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * type_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Double * zg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * zg_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];x_datap += __offsp[0];
y_datap += __offsp[1];
z_datap += __offsp[2];
xg_datap += __offsp[3];
yg_datap += __offsp[4];
type_datap += __offsp[5];
data_datap += __offsp[6];
zg_datap += __offsp[7];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_y_npts = __privtrans->__inc_y_npts;
register PDL_Long __inc_zg_nptsx = __privtrans->__inc_zg_nptsx;
register PDL_Long __inc_zg_nptsy = __privtrans->__inc_zg_nptsy;
register PDL_Long __inc_xg_nptsx = __privtrans->__inc_xg_nptsx;
register PDL_Long __inc_yg_nptsy = __privtrans->__inc_yg_nptsy;
register PDL_Long __inc_x_npts = __privtrans->__inc_x_npts;
register PDL_Long __inc_z_npts = __privtrans->__inc_z_npts;


           int i, j, size_x, size_y;
           PLFLT** zg;

           size_x = __privtrans->__nptsx_size;
           size_y = __privtrans->__nptsy_size;

           plAlloc2dGrid (&zg, size_x, size_y);

           c_plgriddata (x_datap, y_datap, z_datap, __privtrans->__npts_size,
	                 xg_datap, size_x, yg_datap, size_y,
	                 zg, (type_datap)[0] PDL_COMMENT("ACCESS()") , (data_datap)[0] PDL_COMMENT("ACCESS()") );

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++)
               (zg_datap)[0+(__inc_zg_nptsx*PP_INDTERM(__privtrans->__nptsx_size, i))+(__inc_zg_nptsy*PP_INDTERM(__privtrans->__nptsy_size, j))] PDL_COMMENT("ACCESS()")  = zg[i][j];

           plFree2dGrid (zg, size_x, size_y);
         
}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
z_datap += __tinc0_2;
xg_datap += __tinc0_3;
yg_datap += __tinc0_4;
type_datap += __tinc0_5;
data_datap += __tinc0_6;
zg_datap += __tinc0_7;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
z_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
xg_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
yg_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
type_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
data_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
zg_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;z_datap -= __tinc1_2 *
     				  __tdims1;xg_datap -= __tinc1_3 *
     				  __tdims1;yg_datap -= __tinc1_4 *
     				  __tdims1;type_datap -= __tinc1_5 *
     				  __tdims1;data_datap -= __tinc1_6 *
     				  __tdims1;zg_datap -= __tinc1_7 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
z_datap -= __offsp[2];
xg_datap -= __offsp[3];
yg_datap -= __offsp[4];
type_datap -= __offsp[5];
data_datap -= __offsp[6];
zg_datap -= __offsp[7];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgriddata_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgriddata_struct *__privtrans = (pdl_plgriddata_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_plgriddata_vtable_flags[] =
	 	{ 0,0,0,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plgriddata_vtable = {
		0,0, 7, 8, pdl_plgriddata_vtable_flags,
		pdl_plgriddata_redodims, pdl_plgriddata_readdata, NULL,
		pdl_plgriddata_free,NULL,NULL,pdl_plgriddata_copy,NULL,
		sizeof(pdl_plgriddata_struct),"pdl_plgriddata_vtable",
		NULL
	 };

typedef struct pdl_plvect_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_u_nx;PDL_Long  __inc_u_ny;PDL_Long  __inc_v_nx;PDL_Long  __inc_v_ny;PDL_Long  __ny_size;PDL_Long  __nx_size;
		SV *pltr;SV *pltr_data;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plvect_struct;

void pdl_plvect_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plvect_struct *__privtrans = (pdl_plvect_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__ny_size = -1;
__privtrans->__nx_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * u_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * u_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * v_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * v_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_u_nx = __privtrans->__inc_u_nx;
register PDL_Long __inc_u_ny = __privtrans->__inc_u_ny;
register PDL_Long __inc_v_nx = __privtrans->__inc_v_nx;
register PDL_Long __inc_v_ny = __privtrans->__inc_v_ny;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"u","v","scale"};
		static int __realdims[] = {2,2,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plvect";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plvect:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plvect:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__nx_size <= 1) __privtrans->__nx_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__ny_size <= 1) __privtrans->__ny_size = 1;
   }
   if(__privtrans->__nx_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__nx_size == 1)) {
      __privtrans->__nx_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__nx_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plvect:" "Wrong dims\n");
      }
   }
   if(__privtrans->__ny_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__ny_size == 1)) {
      __privtrans->__ny_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__ny_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in plvect:" "Wrong dims\n");
      }
   }

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_u_nx = 0; else
		 __privtrans->__inc_u_nx = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_u_ny = 0; else
		 __privtrans->__inc_u_ny = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_v_nx = 0; else
		 __privtrans->__inc_v_nx = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_v_ny = 0; else
		 __privtrans->__inc_v_ny = PDL_REPRINC(__privtrans->pdls[1],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plvect_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plvect_struct *__privtrans = (pdl_plvect_struct *) __tr;
	
	{
	    pdl_plvect_struct *__copy = malloc(sizeof(pdl_plvect_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->pltr) = newSVsv(__privtrans->pltr);;(__copy->pltr_data) = newSVsv(__privtrans->pltr_data);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_u_nx=__copy->__inc_u_nx;__privtrans->__inc_u_ny=__copy->__inc_u_ny;__privtrans->__inc_v_nx=__copy->__inc_v_nx;__privtrans->__inc_v_ny=__copy->__inc_v_ny;__copy->__ny_size=__privtrans->__ny_size;__copy->__nx_size=__privtrans->__nx_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plvect_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plvect_struct *__privtrans = (pdl_plvect_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * u_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * u_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * v_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * v_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * scale_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * scale_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];u_datap += __offsp[0];
v_datap += __offsp[1];
scale_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_u_nx = __privtrans->__inc_u_nx;
register PDL_Long __inc_u_ny = __privtrans->__inc_u_ny;
register PDL_Long __inc_v_nx = __privtrans->__inc_v_nx;
register PDL_Long __inc_v_ny = __privtrans->__inc_v_ny;


           int i, j, size_x, size_y;
           PLFLT** u;
           PLFLT** v;
	   void (*pltrcb) ();
           PLPointer pltrdt;

           size_x = __privtrans->__nx_size;
           size_y = __privtrans->__ny_size;

           plAlloc2dGrid (&u, size_x, size_y);
           plAlloc2dGrid (&v, size_x, size_y);

           for (i = 0; i < size_x; i++)
             for (j = 0; j < size_y; j++) {
               u[i][j] = (u_datap)[0+(__inc_u_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_u_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;
               v[i][j] = (v_datap)[0+(__inc_v_nx*PP_INDTERM(__privtrans->__nx_size, i))+(__inc_v_ny*PP_INDTERM(__privtrans->__ny_size, j))] PDL_COMMENT("ACCESS()") ;
             }

           pltr_subroutine = __privtrans->pltr;
	   check_sub_pointer (pltr_subroutine,
	     "plvect: pltr must be either 0 or a subroutine pointer");

	   pltrcb = get_standard_pltrcb (__privtrans->pltr);
           if (pltrcb != pltr_callback)
             pltrdt = (PLPointer) SvIV (__privtrans->pltr_data);
           else
             pltrdt = __privtrans->pltr_data;

           plvect ((const PLFLT **)u, (const PLFLT **)v, size_x, size_y, (scale_datap)[0] PDL_COMMENT("ACCESS()") , pltrcb, pltrdt);

           plFree2dGrid (u, size_x, size_y);
           plFree2dGrid (v, size_x, size_y);
}	PDL_COMMENT("THREADLOOPEND")
	 u_datap += __tinc0_0;
v_datap += __tinc0_1;
scale_datap += __tinc0_2;

	 } u_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
v_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
scale_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} u_datap -= __tinc1_0 *
     				  __tdims1;v_datap -= __tinc1_1 *
     				  __tdims1;scale_datap -= __tinc1_2 *
     				  __tdims1;
 u_datap -= __offsp[0];
v_datap -= __offsp[1];
scale_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plvect_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plvect_struct *__privtrans = (pdl_plvect_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->pltr);;SvREFCNT_dec(__privtrans->pltr_data);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_plvect_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plvect_vtable = {
		0,0, 3, 3, pdl_plvect_vtable_flags,
		pdl_plvect_redodims, pdl_plvect_readdata, NULL,
		pdl_plvect_free,NULL,NULL,pdl_plvect_copy,NULL,
		sizeof(pdl_plvect_struct),"pdl_plvect_vtable",
		NULL
	 };

typedef struct pdl_plsvect_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_arrowx_npts;PDL_Long  __inc_arrowy_npts;PDL_Long  __npts_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsvect_struct;

void pdl_plsvect_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvect_struct *__privtrans = (pdl_plsvect_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__npts_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * arrowx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * arrowx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * arrowy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * arrowy_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * fill_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * fill_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_arrowy_npts = __privtrans->__inc_arrowy_npts;
register PDL_Long __inc_arrowx_npts = __privtrans->__inc_arrowx_npts;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"arrowx","arrowy","fill"};
		static int __realdims[] = {1,1,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsvect";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__npts_size <= 1) __privtrans->__npts_size = 1;
   }
   if(__privtrans->__npts_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__npts_size == 1)) {
      __privtrans->__npts_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__npts_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsvect:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__npts_size <= 1) __privtrans->__npts_size = 1;
   }
   if(__privtrans->__npts_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__npts_size == 1)) {
      __privtrans->__npts_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__npts_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plsvect:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_arrowx_npts = 0; else
		 __privtrans->__inc_arrowx_npts = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_arrowy_npts = 0; else
		 __privtrans->__inc_arrowy_npts = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsvect_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvect_struct *__privtrans = (pdl_plsvect_struct *) __tr;
	
	{
	    pdl_plsvect_struct *__copy = malloc(sizeof(pdl_plsvect_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_arrowx_npts=__copy->__inc_arrowx_npts;__privtrans->__inc_arrowy_npts=__copy->__inc_arrowy_npts;__copy->__npts_size=__privtrans->__npts_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsvect_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvect_struct *__privtrans = (pdl_plsvect_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * arrowx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * arrowx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * arrowy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * arrowy_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * fill_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * fill_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];arrowx_datap += __offsp[0];
arrowy_datap += __offsp[1];
fill_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_arrowy_npts = __privtrans->__inc_arrowy_npts;
register PDL_Long __inc_arrowx_npts = __privtrans->__inc_arrowx_npts;

c_plsvect (arrowx_datap, arrowy_datap, __privtrans->__npts_size, (fill_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 arrowx_datap += __tinc0_0;
arrowy_datap += __tinc0_1;
fill_datap += __tinc0_2;

	 } arrowx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
arrowy_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
fill_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} arrowx_datap -= __tinc1_0 *
     				  __tdims1;arrowy_datap -= __tinc1_1 *
     				  __tdims1;fill_datap -= __tinc1_2 *
     				  __tdims1;
 arrowx_datap -= __offsp[0];
arrowy_datap -= __offsp[1];
fill_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsvect_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsvect_struct *__privtrans = (pdl_plsvect_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_plsvect_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsvect_vtable = {
		0,0, 3, 3, pdl_plsvect_vtable_flags,
		pdl_plsvect_redodims, pdl_plsvect_readdata, NULL,
		pdl_plsvect_free,NULL,NULL,pdl_plsvect_copy,NULL,
		sizeof(pdl_plsvect_struct),"pdl_plsvect_vtable",
		NULL
	 };

typedef struct pdl_plhlsrgb_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plhlsrgb_struct;

void pdl_plhlsrgb_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plhlsrgb_struct *__privtrans = (pdl_plhlsrgb_struct *) __tr;
	
	{
	    int __creating[6];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * h_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * h_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * l_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * l_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * s_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * s_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_r_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_r_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * p_g_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * p_g_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * p_b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * p_b_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"h","l","s","p_r","p_g","p_b"};
		static int __realdims[] = {0,0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plhlsrgb";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plhlsrgb_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plhlsrgb_struct *__privtrans = (pdl_plhlsrgb_struct *) __tr;
	
	{
	    pdl_plhlsrgb_struct *__copy = malloc(sizeof(pdl_plhlsrgb_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plhlsrgb_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plhlsrgb_struct *__privtrans = (pdl_plhlsrgb_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Double * h_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * h_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * l_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * l_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * s_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * s_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * p_r_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * p_r_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * p_g_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * p_g_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * p_b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * p_b_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];h_datap += __offsp[0];
l_datap += __offsp[1];
s_datap += __offsp[2];
p_r_datap += __offsp[3];
p_g_datap += __offsp[4];
p_b_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plhlsrgb((h_datap)[0] PDL_COMMENT("ACCESS()") ,(l_datap)[0] PDL_COMMENT("ACCESS()") ,(s_datap)[0] PDL_COMMENT("ACCESS()") ,p_r_datap,p_g_datap,p_b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 h_datap += __tinc0_0;
l_datap += __tinc0_1;
s_datap += __tinc0_2;
p_r_datap += __tinc0_3;
p_g_datap += __tinc0_4;
p_b_datap += __tinc0_5;

	 } h_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
l_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
s_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
p_r_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
p_g_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
p_b_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} h_datap -= __tinc1_0 *
     				  __tdims1;l_datap -= __tinc1_1 *
     				  __tdims1;s_datap -= __tinc1_2 *
     				  __tdims1;p_r_datap -= __tinc1_3 *
     				  __tdims1;p_g_datap -= __tinc1_4 *
     				  __tdims1;p_b_datap -= __tinc1_5 *
     				  __tdims1;
 h_datap -= __offsp[0];
l_datap -= __offsp[1];
s_datap -= __offsp[2];
p_r_datap -= __offsp[3];
p_g_datap -= __offsp[4];
p_b_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plhlsrgb_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plhlsrgb_struct *__privtrans = (pdl_plhlsrgb_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plhlsrgb_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_plhlsrgb_vtable = {
		0,0, 3, 6, pdl_plhlsrgb_vtable_flags,
		pdl_plhlsrgb_redodims, pdl_plhlsrgb_readdata, NULL,
		pdl_plhlsrgb_free,NULL,NULL,pdl_plhlsrgb_copy,NULL,
		sizeof(pdl_plhlsrgb_struct),"pdl_plhlsrgb_vtable",
		NULL
	 };

typedef struct pdl_plgcol0_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgcol0_struct;

void pdl_plgcol0_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0_struct *__privtrans = (pdl_plgcol0_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"icolzero","r","g","b"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgcol0";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgcol0_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0_struct *__privtrans = (pdl_plgcol0_struct *) __tr;
	
	{
	    pdl_plgcol0_struct *__copy = malloc(sizeof(pdl_plgcol0_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgcol0_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0_struct *__privtrans = (pdl_plgcol0_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgcol0_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0_struct *__privtrans = (pdl_plgcol0_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgcol0_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_plgcol0_vtable = {
		0,0, 1, 4, pdl_plgcol0_vtable_flags,
		pdl_plgcol0_redodims, pdl_plgcol0_readdata, NULL,
		pdl_plgcol0_free,NULL,NULL,pdl_plgcol0_copy,NULL,
		sizeof(pdl_plgcol0_struct),"pdl_plgcol0_vtable",
		NULL
	 };

typedef struct pdl_plgcolbg_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgcolbg_struct;

void pdl_plgcolbg_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbg_struct *__privtrans = (pdl_plgcolbg_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgcolbg";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgcolbg_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbg_struct *__privtrans = (pdl_plgcolbg_struct *) __tr;
	
	{
	    pdl_plgcolbg_struct *__copy = malloc(sizeof(pdl_plgcolbg_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgcolbg_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbg_struct *__privtrans = (pdl_plgcolbg_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbg(r_datap,g_datap,b_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgcolbg_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbg_struct *__privtrans = (pdl_plgcolbg_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgcolbg_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plgcolbg_vtable = {
		0,0, 0, 3, pdl_plgcolbg_vtable_flags,
		pdl_plgcolbg_redodims, pdl_plgcolbg_readdata, NULL,
		pdl_plgcolbg_free,NULL,NULL,pdl_plgcolbg_copy,NULL,
		sizeof(pdl_plgcolbg_struct),"pdl_plgcolbg_vtable",
		NULL
	 };

typedef struct pdl_plscmap0_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_r_n;PDL_Long  __inc_g_n;PDL_Long  __inc_b_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap0_struct;

void pdl_plscmap0_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0_struct *__privtrans = (pdl_plscmap0_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b"};
		static int __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap0";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_r_n = 0; else
		 __privtrans->__inc_r_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_g_n = 0; else
		 __privtrans->__inc_g_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap0_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0_struct *__privtrans = (pdl_plscmap0_struct *) __tr;
	
	{
	    pdl_plscmap0_struct *__copy = malloc(sizeof(pdl_plscmap0_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_r_n=__copy->__inc_r_n;__privtrans->__inc_g_n=__copy->__inc_g_n;__privtrans->__inc_b_n=__copy->__inc_b_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap0_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0_struct *__privtrans = (pdl_plscmap0_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap0_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0_struct *__privtrans = (pdl_plscmap0_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plscmap0_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plscmap0_vtable = {
		0,0, 3, 3, pdl_plscmap0_vtable_flags,
		pdl_plscmap0_redodims, pdl_plscmap0_readdata, NULL,
		pdl_plscmap0_free,NULL,NULL,pdl_plscmap0_copy,NULL,
		sizeof(pdl_plscmap0_struct),"pdl_plscmap0_vtable",
		NULL
	 };

typedef struct pdl_plscmap1_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_r_n;PDL_Long  __inc_g_n;PDL_Long  __inc_b_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap1_struct;

void pdl_plscmap1_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1_struct *__privtrans = (pdl_plscmap1_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b"};
		static int __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap1";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_r_n = 0; else
		 __privtrans->__inc_r_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_g_n = 0; else
		 __privtrans->__inc_g_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap1_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1_struct *__privtrans = (pdl_plscmap1_struct *) __tr;
	
	{
	    pdl_plscmap1_struct *__copy = malloc(sizeof(pdl_plscmap1_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_r_n=__copy->__inc_r_n;__privtrans->__inc_g_n=__copy->__inc_g_n;__privtrans->__inc_b_n=__copy->__inc_b_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap1_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1_struct *__privtrans = (pdl_plscmap1_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1(r_datap,g_datap,b_datap, __privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap1_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1_struct *__privtrans = (pdl_plscmap1_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_plscmap1_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plscmap1_vtable = {
		0,0, 3, 3, pdl_plscmap1_vtable_flags,
		pdl_plscmap1_redodims, pdl_plscmap1_readdata, NULL,
		pdl_plscmap1_free,NULL,NULL,pdl_plscmap1_copy,NULL,
		sizeof(pdl_plscmap1_struct),"pdl_plscmap1_vtable",
		NULL
	 };

typedef struct pdl_plgcol0a_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgcol0a_struct;

void pdl_plgcol0a_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0a_struct *__privtrans = (pdl_plgcol0a_struct *) __tr;
	
	{
	    int __creating[5];
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"icolzero","r","g","b","a"};
		static int __realdims[] = {0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgcol0a";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgcol0a_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0a_struct *__privtrans = (pdl_plgcol0a_struct *) __tr;
	
	{
	    pdl_plgcol0a_struct *__copy = malloc(sizeof(pdl_plgcol0a_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgcol0a_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0a_struct *__privtrans = (pdl_plgcol0a_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * icolzero_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * icolzero_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];icolzero_datap += __offsp[0];
r_datap += __offsp[1];
g_datap += __offsp[2];
b_datap += __offsp[3];
a_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcol0a((icolzero_datap)[0] PDL_COMMENT("ACCESS()") ,r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 icolzero_datap += __tinc0_0;
r_datap += __tinc0_1;
g_datap += __tinc0_2;
b_datap += __tinc0_3;
a_datap += __tinc0_4;

	 } icolzero_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
r_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
g_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
b_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
a_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} icolzero_datap -= __tinc1_0 *
     				  __tdims1;r_datap -= __tinc1_1 *
     				  __tdims1;g_datap -= __tinc1_2 *
     				  __tdims1;b_datap -= __tinc1_3 *
     				  __tdims1;a_datap -= __tinc1_4 *
     				  __tdims1;
 icolzero_datap -= __offsp[0];
r_datap -= __offsp[1];
g_datap -= __offsp[2];
b_datap -= __offsp[3];
a_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgcol0a_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcol0a_struct *__privtrans = (pdl_plgcol0a_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgcol0a_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0,0};
	 pdl_transvtable pdl_plgcol0a_vtable = {
		0,0, 1, 5, pdl_plgcol0a_vtable_flags,
		pdl_plgcol0a_redodims, pdl_plgcol0a_readdata, NULL,
		pdl_plgcol0a_free,NULL,NULL,pdl_plgcol0a_copy,NULL,
		sizeof(pdl_plgcol0a_struct),"pdl_plgcol0a_vtable",
		NULL
	 };

typedef struct pdl_plgcolbga_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgcolbga_struct;

void pdl_plgcolbga_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbga_struct *__privtrans = (pdl_plgcolbga_struct *) __tr;
	
	{
	    int __creating[4];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b","a"};
		static int __realdims[] = {0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgcolbga";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgcolbga_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbga_struct *__privtrans = (pdl_plgcolbga_struct *) __tr;
	
	{
	    pdl_plgcolbga_struct *__copy = malloc(sizeof(pdl_plgcolbga_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgcolbga_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbga_struct *__privtrans = (pdl_plgcolbga_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgcolbga(r_datap,g_datap,b_datap,a_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgcolbga_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgcolbga_struct *__privtrans = (pdl_plgcolbga_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgcolbga_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plgcolbga_vtable = {
		0,0, 0, 4, pdl_plgcolbga_vtable_flags,
		pdl_plgcolbga_redodims, pdl_plgcolbga_readdata, NULL,
		pdl_plgcolbga_free,NULL,NULL,pdl_plgcolbga_copy,NULL,
		sizeof(pdl_plgcolbga_struct),"pdl_plgcolbga_vtable",
		NULL
	 };

typedef struct pdl_plscmap0a_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_r_n;PDL_Long  __inc_g_n;PDL_Long  __inc_b_n;PDL_Long  __inc_a_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap0a_struct;

void pdl_plscmap0a_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0a_struct *__privtrans = (pdl_plscmap0a_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b","a"};
		static int __realdims[] = {1,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap0a";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap0a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_r_n = 0; else
		 __privtrans->__inc_r_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_g_n = 0; else
		 __privtrans->__inc_g_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_a_n = 0; else
		 __privtrans->__inc_a_n = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap0a_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0a_struct *__privtrans = (pdl_plscmap0a_struct *) __tr;
	
	{
	    pdl_plscmap0a_struct *__copy = malloc(sizeof(pdl_plscmap0a_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_r_n=__copy->__inc_r_n;__privtrans->__inc_g_n=__copy->__inc_g_n;__privtrans->__inc_b_n=__copy->__inc_b_n;__privtrans->__inc_a_n=__copy->__inc_a_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap0a_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0a_struct *__privtrans = (pdl_plscmap0a_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap0a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap0a_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap0a_struct *__privtrans = (pdl_plscmap0a_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_plscmap0a_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plscmap0a_vtable = {
		0,0, 4, 4, pdl_plscmap0a_vtable_flags,
		pdl_plscmap0a_redodims, pdl_plscmap0a_readdata, NULL,
		pdl_plscmap0a_free,NULL,NULL,pdl_plscmap0a_copy,NULL,
		sizeof(pdl_plscmap0a_struct),"pdl_plscmap0a_vtable",
		NULL
	 };

typedef struct pdl_plscmap1a_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_r_n;PDL_Long  __inc_g_n;PDL_Long  __inc_b_n;PDL_Long  __inc_a_n;PDL_Long  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap1a_struct;

void pdl_plscmap1a_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1a_struct *__privtrans = (pdl_plscmap1a_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"r","g","b","a"};
		static int __realdims[] = {1,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap1a";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1a:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_r_n = 0; else
		 __privtrans->__inc_r_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_g_n = 0; else
		 __privtrans->__inc_g_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_a_n = 0; else
		 __privtrans->__inc_a_n = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap1a_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1a_struct *__privtrans = (pdl_plscmap1a_struct *) __tr;
	
	{
	    pdl_plscmap1a_struct *__copy = malloc(sizeof(pdl_plscmap1a_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_r_n=__copy->__inc_r_n;__privtrans->__inc_g_n=__copy->__inc_g_n;__privtrans->__inc_b_n=__copy->__inc_b_n;__privtrans->__inc_a_n=__copy->__inc_a_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap1a_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1a_struct *__privtrans = (pdl_plscmap1a_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * r_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * r_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * g_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * g_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * b_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * b_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];r_datap += __offsp[0];
g_datap += __offsp[1];
b_datap += __offsp[2];
a_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_a_n = __privtrans->__inc_a_n;
register PDL_Long __inc_r_n = __privtrans->__inc_r_n;
register PDL_Long __inc_b_n = __privtrans->__inc_b_n;
register PDL_Long __inc_g_n = __privtrans->__inc_g_n;

c_plscmap1a(r_datap,g_datap,b_datap,a_datap,__privtrans->__n_size);
}	PDL_COMMENT("THREADLOOPEND")
	 r_datap += __tinc0_0;
g_datap += __tinc0_1;
b_datap += __tinc0_2;
a_datap += __tinc0_3;

	 } r_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
g_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
b_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
a_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} r_datap -= __tinc1_0 *
     				  __tdims1;g_datap -= __tinc1_1 *
     				  __tdims1;b_datap -= __tinc1_2 *
     				  __tdims1;a_datap -= __tinc1_3 *
     				  __tdims1;
 r_datap -= __offsp[0];
g_datap -= __offsp[1];
b_datap -= __offsp[2];
a_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap1a_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1a_struct *__privtrans = (pdl_plscmap1a_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_plscmap1a_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_plscmap1a_vtable = {
		0,0, 4, 4, pdl_plscmap1a_vtable_flags,
		pdl_plscmap1a_redodims, pdl_plscmap1a_readdata, NULL,
		pdl_plscmap1a_free,NULL,NULL,pdl_plscmap1a_copy,NULL,
		sizeof(pdl_plscmap1a_struct),"pdl_plscmap1a_vtable",
		NULL
	 };

typedef struct pdl_plscmap1la_struct {
		PDL_TRANS_START(7);
		pdl_thread  __pdlthread;PDL_Long  __inc_isty_n;PDL_Long  __inc_coord1_n;PDL_Long  __inc_coord2_n;PDL_Long  __inc_coord3_n;PDL_Long  __inc_coord4_n;PDL_Long  __inc_rev_nrev;PDL_Long  __n_size;PDL_Long  __nrev_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plscmap1la_struct;

void pdl_plscmap1la_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1la_struct *__privtrans = (pdl_plscmap1la_struct *) __tr;
	
	{
	    int __creating[7];
__privtrans->__n_size = -1;
__privtrans->__nrev_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * itype_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * itype_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * isty_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * isty_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * coord1_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * coord1_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * coord2_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * coord2_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * coord3_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * coord3_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * coord4_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * coord4_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * rev_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * rev_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

{register PDL_Long __inc_coord1_n = __privtrans->__inc_coord1_n;
register PDL_Long __inc_coord3_n = __privtrans->__inc_coord3_n;
register PDL_Long __inc_coord4_n = __privtrans->__inc_coord4_n;
register PDL_Long __inc_rev_nrev = __privtrans->__inc_rev_nrev;
register PDL_Long __inc_isty_n = __privtrans->__inc_isty_n;
register PDL_Long __inc_coord2_n = __privtrans->__inc_coord2_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"itype","isty","coord1","coord2","coord3","coord4","rev"};
		static int __realdims[] = {0,1,1,1,1,1,1};
		static char __funcname[] = "PDL::Graphics::PLplot::plscmap1la";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 7
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,7,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1la:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1la:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1la:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1la:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1la:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));
   if(((__privtrans->pdls[6]))->ndims < 1) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__nrev_size <= 1) __privtrans->__nrev_size = 1;
   }
   if(__privtrans->__nrev_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__nrev_size == 1)) {
      __privtrans->__nrev_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__nrev_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in plscmap1la:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[6])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_isty_n = 0; else
		 __privtrans->__inc_isty_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_coord1_n = 0; else
		 __privtrans->__inc_coord1_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_coord2_n = 0; else
		 __privtrans->__inc_coord2_n = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_coord3_n = 0; else
		 __privtrans->__inc_coord3_n = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_coord4_n = 0; else
		 __privtrans->__inc_coord4_n = __privtrans->pdls[5]->dimincs[0];if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_rev_nrev = 0; else
		 __privtrans->__inc_rev_nrev = __privtrans->pdls[6]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plscmap1la_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1la_struct *__privtrans = (pdl_plscmap1la_struct *) __tr;
	
	{
	    pdl_plscmap1la_struct *__copy = malloc(sizeof(pdl_plscmap1la_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_isty_n=__copy->__inc_isty_n;__privtrans->__inc_coord1_n=__copy->__inc_coord1_n;__privtrans->__inc_coord2_n=__copy->__inc_coord2_n;__privtrans->__inc_coord3_n=__copy->__inc_coord3_n;__privtrans->__inc_coord4_n=__copy->__inc_coord4_n;__privtrans->__inc_rev_nrev=__copy->__inc_rev_nrev;__copy->__n_size=__privtrans->__n_size;__copy->__nrev_size=__privtrans->__nrev_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plscmap1la_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1la_struct *__privtrans = (pdl_plscmap1la_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_D: {
	PDL_Long * itype_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * itype_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * isty_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * isty_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * coord1_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * coord1_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * coord2_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * coord2_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * coord3_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * coord3_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * coord4_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * coord4_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * rev_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * rev_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];itype_datap += __offsp[0];
isty_datap += __offsp[1];
coord1_datap += __offsp[2];
coord2_datap += __offsp[3];
coord3_datap += __offsp[4];
coord4_datap += __offsp[5];
rev_datap += __offsp[6];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_coord1_n = __privtrans->__inc_coord1_n;
register PDL_Long __inc_coord3_n = __privtrans->__inc_coord3_n;
register PDL_Long __inc_coord4_n = __privtrans->__inc_coord4_n;
register PDL_Long __inc_rev_nrev = __privtrans->__inc_rev_nrev;
register PDL_Long __inc_isty_n = __privtrans->__inc_isty_n;
register PDL_Long __inc_coord2_n = __privtrans->__inc_coord2_n;


	      PLINT* rev;

	      if (__privtrans->__nrev_size == 0)
	        rev = NULL;
	      else if (__privtrans->__nrev_size == __privtrans->__n_size)
   	        rev = rev_datap;
              else
                croak ("plscmap1la: rev must have either length == 0 or have the same length of the other input arguments");

	      c_plscmap1la ((itype_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, isty_datap, coord1_datap,
	                    coord2_datap, coord3_datap, coord4_datap, rev);
}	PDL_COMMENT("THREADLOOPEND")
	 itype_datap += __tinc0_0;
isty_datap += __tinc0_1;
coord1_datap += __tinc0_2;
coord2_datap += __tinc0_3;
coord3_datap += __tinc0_4;
coord4_datap += __tinc0_5;
rev_datap += __tinc0_6;

	 } itype_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
isty_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
coord1_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
coord2_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
coord3_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
coord4_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
rev_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;

	} itype_datap -= __tinc1_0 *
     				  __tdims1;isty_datap -= __tinc1_1 *
     				  __tdims1;coord1_datap -= __tinc1_2 *
     				  __tdims1;coord2_datap -= __tinc1_3 *
     				  __tdims1;coord3_datap -= __tinc1_4 *
     				  __tdims1;coord4_datap -= __tinc1_5 *
     				  __tdims1;rev_datap -= __tinc1_6 *
     				  __tdims1;
 itype_datap -= __offsp[0];
isty_datap -= __offsp[1];
coord1_datap -= __offsp[2];
coord2_datap -= __offsp[3];
coord3_datap -= __offsp[4];
coord4_datap -= __offsp[5];
rev_datap -= __offsp[6];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plscmap1la_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plscmap1la_struct *__privtrans = (pdl_plscmap1la_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;
			}
			
	}
    }
    



static char pdl_plscmap1la_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0,0,0,0};
	 pdl_transvtable pdl_plscmap1la_vtable = {
		0,0, 7, 7, pdl_plscmap1la_vtable_flags,
		pdl_plscmap1la_redodims, pdl_plscmap1la_readdata, NULL,
		pdl_plscmap1la_free,NULL,NULL,pdl_plscmap1la_copy,NULL,
		sizeof(pdl_plscmap1la_struct),"pdl_plscmap1la_vtable",
		NULL
	 };

typedef struct pdl_plgfont_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plgfont_struct;

void pdl_plgfont_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfont_struct *__privtrans = (pdl_plgfont_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"p_family","p_style","p_weight"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plgfont";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[0]) {
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plgfont_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfont_struct *__privtrans = (pdl_plgfont_struct *) __tr;
	
	{
	    pdl_plgfont_struct *__copy = malloc(sizeof(pdl_plgfont_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plgfont_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfont_struct *__privtrans = (pdl_plgfont_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * p_family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * p_family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * p_style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * p_style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * p_weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * p_weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];p_family_datap += __offsp[0];
p_style_datap += __offsp[1];
p_weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plgfont(p_family_datap,p_style_datap,p_weight_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 p_family_datap += __tinc0_0;
p_style_datap += __tinc0_1;
p_weight_datap += __tinc0_2;

	 } p_family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
p_style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
p_weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} p_family_datap -= __tinc1_0 *
     				  __tdims1;p_style_datap -= __tinc1_1 *
     				  __tdims1;p_weight_datap -= __tinc1_2 *
     				  __tdims1;
 p_family_datap -= __offsp[0];
p_style_datap -= __offsp[1];
p_weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plgfont_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plgfont_struct *__privtrans = (pdl_plgfont_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plgfont_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_plgfont_vtable = {
		0,0, 0, 3, pdl_plgfont_vtable_flags,
		pdl_plgfont_redodims, pdl_plgfont_readdata, NULL,
		pdl_plgfont_free,NULL,NULL,pdl_plgfont_copy,NULL,
		sizeof(pdl_plgfont_struct),"pdl_plgfont_vtable",
		NULL
	 };

typedef struct pdl_plsfont_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plsfont_struct;

void pdl_plsfont_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfont_struct *__privtrans = (pdl_plsfont_struct *) __tr;
	
	{
	    int __creating[3];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"family","style","weight"};
		static int __realdims[] = {0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plsfont";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plsfont_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfont_struct *__privtrans = (pdl_plsfont_struct *) __tr;
	
	{
	    pdl_plsfont_struct *__copy = malloc(sizeof(pdl_plsfont_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plsfont_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfont_struct *__privtrans = (pdl_plsfont_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Long * family_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * family_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * style_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * style_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * weight_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * weight_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];family_datap += __offsp[0];
style_datap += __offsp[1];
weight_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plsfont((family_datap)[0] PDL_COMMENT("ACCESS()") ,(style_datap)[0] PDL_COMMENT("ACCESS()") ,(weight_datap)[0] PDL_COMMENT("ACCESS()") );
}	PDL_COMMENT("THREADLOOPEND")
	 family_datap += __tinc0_0;
style_datap += __tinc0_1;
weight_datap += __tinc0_2;

	 } family_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
style_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
weight_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} family_datap -= __tinc1_0 *
     				  __tdims1;style_datap -= __tinc1_1 *
     				  __tdims1;weight_datap -= __tinc1_2 *
     				  __tdims1;
 family_datap -= __offsp[0];
style_datap -= __offsp[1];
weight_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plsfont_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plsfont_struct *__privtrans = (pdl_plsfont_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plsfont_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_plsfont_vtable = {
		0,0, 3, 3, pdl_plsfont_vtable_flags,
		pdl_plsfont_redodims, pdl_plsfont_readdata, NULL,
		pdl_plsfont_free,NULL,NULL,pdl_plsfont_copy,NULL,
		sizeof(pdl_plsfont_struct),"pdl_plsfont_vtable",
		NULL
	 };

typedef struct pdl_plcalc_world_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_plcalc_world_struct;

void pdl_plcalc_world_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_plcalc_world_struct *__privtrans = (pdl_plcalc_world_struct *) __tr;
	
	{
	    int __creating[5];
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{
PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"rx","ry","wx","wy","window"};
		static int __realdims[] = {0,0,0,0,0};
		static char __funcname[] = "PDL::Graphics::PLplot::plcalc_world";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			1 );
		}
if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
 __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_plcalc_world_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_plcalc_world_struct *__privtrans = (pdl_plcalc_world_struct *) __tr;
	
	{
	    pdl_plcalc_world_struct *__copy = malloc(sizeof(pdl_plcalc_world_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_plcalc_world_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_plcalc_world_struct *__privtrans = (pdl_plcalc_world_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Double * rx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * rx_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ry_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ry_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * wx_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * wx_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * wy_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * wy_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * window_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * window_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];rx_datap += __offsp[0];
ry_datap += __offsp[1];
wx_datap += __offsp[2];
wy_datap += __offsp[3];
window_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{
c_plcalc_world((rx_datap)[0] PDL_COMMENT("ACCESS()") , (ry_datap)[0] PDL_COMMENT("ACCESS()") , wx_datap, wy_datap, window_datap);
}	PDL_COMMENT("THREADLOOPEND")
	 rx_datap += __tinc0_0;
ry_datap += __tinc0_1;
wx_datap += __tinc0_2;
wy_datap += __tinc0_3;
window_datap += __tinc0_4;

	 } rx_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ry_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
wx_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
wy_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
window_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} rx_datap -= __tinc1_0 *
     				  __tdims1;ry_datap -= __tinc1_1 *
     				  __tdims1;wx_datap -= __tinc1_2 *
     				  __tdims1;wy_datap -= __tinc1_3 *
     				  __tdims1;window_datap -= __tinc1_4 *
     				  __tdims1;
 rx_datap -= __offsp[0];
ry_datap -= __offsp[1];
wx_datap -= __offsp[2];
wy_datap -= __offsp[3];
window_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_plcalc_world_free(pdl_trans *__tr ) {
	int __dim;
	pdl_plcalc_world_struct *__privtrans = (pdl_plcalc_world_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;
			}
			
	}
    }
    



static char pdl_plcalc_world_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_plcalc_world_vtable = {
		0,0, 2, 5, pdl_plcalc_world_vtable_flags,
		pdl_plcalc_world_redodims, pdl_plcalc_world_readdata, NULL,
		pdl_plcalc_world_free,NULL,NULL,pdl_plcalc_world_copy,NULL,
		sizeof(pdl_plcalc_world_struct),"pdl_plcalc_world_vtable",
		NULL
	 };



MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

PROTOTYPES: ENABLE

int
set_debugging(i)
	int i;
	CODE:
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
	OUTPUT:
	RETVAL

int
set_boundscheck(i)
       int i;
       CODE:
       if (! 1)
         warn("Bounds checking is disabled for PDL::Graphics::PLplot");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
       OUTPUT:
       RETVAL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_PARTIAL()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_PARTIAL;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_FULL()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_FULL;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_QUIET()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_QUIET;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_NODELETE()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_NODELETE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_SHOWALL()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_SHOWALL;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_OVERRIDE()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_OVERRIDE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_NOPROGRAM()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_NOPROGRAM;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_NODASH()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_NODASH;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_PARSE_SKIP()
PROTOTYPE:
CODE:
  RETVAL = PL_PARSE_SKIP;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
DRAW_LINEX()
PROTOTYPE:
CODE:
  RETVAL = DRAW_LINEX;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
DRAW_LINEY()
PROTOTYPE:
CODE:
  RETVAL = DRAW_LINEY;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
DRAW_LINEXY()
PROTOTYPE:
CODE:
  RETVAL = DRAW_LINEXY;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
MAG_COLOR()
PROTOTYPE:
CODE:
  RETVAL = MAG_COLOR;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
BASE_CONT()
PROTOTYPE:
CODE:
  RETVAL = BASE_CONT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
TOP_CONT()
PROTOTYPE:
CODE:
  RETVAL = TOP_CONT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
SURF_CONT()
PROTOTYPE:
CODE:
  RETVAL = SURF_CONT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
DRAW_SIDES()
PROTOTYPE:
CODE:
  RETVAL = DRAW_SIDES;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
FACETED()
PROTOTYPE:
CODE:
  RETVAL = FACETED;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
MESH()
PROTOTYPE:
CODE:
  RETVAL = MESH;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_FCI_SANS()
PROTOTYPE:
CODE:
  RETVAL = PL_FCI_SANS;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_FCI_MONO()
PROTOTYPE:
CODE:
  RETVAL = PL_FCI_MONO;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_BackSpace()
PROTOTYPE:
CODE:
  RETVAL = PLK_BackSpace;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Tab()
PROTOTYPE:
CODE:
  RETVAL = PLK_Tab;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Linefeed()
PROTOTYPE:
CODE:
  RETVAL = PLK_Linefeed;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Return()
PROTOTYPE:
CODE:
  RETVAL = PLK_Return;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Escape()
PROTOTYPE:
CODE:
  RETVAL = PLK_Escape;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Delete()
PROTOTYPE:
CODE:
  RETVAL = PLK_Delete;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Clear()
PROTOTYPE:
CODE:
  RETVAL = PLK_Clear;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Pause()
PROTOTYPE:
CODE:
  RETVAL = PLK_Pause;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Scroll_Lock()
PROTOTYPE:
CODE:
  RETVAL = PLK_Scroll_Lock;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Home()
PROTOTYPE:
CODE:
  RETVAL = PLK_Home;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Left()
PROTOTYPE:
CODE:
  RETVAL = PLK_Left;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Up()
PROTOTYPE:
CODE:
  RETVAL = PLK_Up;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Right()
PROTOTYPE:
CODE:
  RETVAL = PLK_Right;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Down()
PROTOTYPE:
CODE:
  RETVAL = PLK_Down;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Prior()
PROTOTYPE:
CODE:
  RETVAL = PLK_Prior;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Next()
PROTOTYPE:
CODE:
  RETVAL = PLK_Next;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_End()
PROTOTYPE:
CODE:
  RETVAL = PLK_End;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Begin()
PROTOTYPE:
CODE:
  RETVAL = PLK_Begin;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Select()
PROTOTYPE:
CODE:
  RETVAL = PLK_Select;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Print()
PROTOTYPE:
CODE:
  RETVAL = PLK_Print;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Execute()
PROTOTYPE:
CODE:
  RETVAL = PLK_Execute;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Insert()
PROTOTYPE:
CODE:
  RETVAL = PLK_Insert;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Undo()
PROTOTYPE:
CODE:
  RETVAL = PLK_Undo;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Redo()
PROTOTYPE:
CODE:
  RETVAL = PLK_Redo;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Menu()
PROTOTYPE:
CODE:
  RETVAL = PLK_Menu;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Find()
PROTOTYPE:
CODE:
  RETVAL = PLK_Find;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Cancel()
PROTOTYPE:
CODE:
  RETVAL = PLK_Cancel;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Help()
PROTOTYPE:
CODE:
  RETVAL = PLK_Help;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Break()
PROTOTYPE:
CODE:
  RETVAL = PLK_Break;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Mode_switch()
PROTOTYPE:
CODE:
  RETVAL = PLK_Mode_switch;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_script_switch()
PROTOTYPE:
CODE:
  RETVAL = PLK_script_switch;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Num_Lock()
PROTOTYPE:
CODE:
  RETVAL = PLK_Num_Lock;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Space()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Space;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Tab()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Tab;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Enter()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Enter;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_F1()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_F1;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_F2()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_F2;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_F3()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_F3;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_F4()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_F4;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Equal()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Equal;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Multiply()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Multiply;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Add()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Add;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Separator()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Separator;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Subtract()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Subtract;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Decimal()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Decimal;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_Divide()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_Divide;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_0()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_0;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_1()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_1;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_2()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_2;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_3()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_3;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_4()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_4;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_5()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_5;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_6()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_6;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_7()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_7;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_8()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_8;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_KP_9()
PROTOTYPE:
CODE:
  RETVAL = PLK_KP_9;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F1()
PROTOTYPE:
CODE:
  RETVAL = PLK_F1;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F2()
PROTOTYPE:
CODE:
  RETVAL = PLK_F2;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F3()
PROTOTYPE:
CODE:
  RETVAL = PLK_F3;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F4()
PROTOTYPE:
CODE:
  RETVAL = PLK_F4;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F5()
PROTOTYPE:
CODE:
  RETVAL = PLK_F5;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F6()
PROTOTYPE:
CODE:
  RETVAL = PLK_F6;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F7()
PROTOTYPE:
CODE:
  RETVAL = PLK_F7;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F8()
PROTOTYPE:
CODE:
  RETVAL = PLK_F8;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F9()
PROTOTYPE:
CODE:
  RETVAL = PLK_F9;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F10()
PROTOTYPE:
CODE:
  RETVAL = PLK_F10;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F11()
PROTOTYPE:
CODE:
  RETVAL = PLK_F11;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L1()
PROTOTYPE:
CODE:
  RETVAL = PLK_L1;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F12()
PROTOTYPE:
CODE:
  RETVAL = PLK_F12;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L2()
PROTOTYPE:
CODE:
  RETVAL = PLK_L2;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F13()
PROTOTYPE:
CODE:
  RETVAL = PLK_F13;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L3()
PROTOTYPE:
CODE:
  RETVAL = PLK_L3;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F14()
PROTOTYPE:
CODE:
  RETVAL = PLK_F14;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L4()
PROTOTYPE:
CODE:
  RETVAL = PLK_L4;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F15()
PROTOTYPE:
CODE:
  RETVAL = PLK_F15;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L5()
PROTOTYPE:
CODE:
  RETVAL = PLK_L5;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F16()
PROTOTYPE:
CODE:
  RETVAL = PLK_F16;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L6()
PROTOTYPE:
CODE:
  RETVAL = PLK_L6;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F17()
PROTOTYPE:
CODE:
  RETVAL = PLK_F17;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L7()
PROTOTYPE:
CODE:
  RETVAL = PLK_L7;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F18()
PROTOTYPE:
CODE:
  RETVAL = PLK_F18;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L8()
PROTOTYPE:
CODE:
  RETVAL = PLK_L8;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F19()
PROTOTYPE:
CODE:
  RETVAL = PLK_F19;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L9()
PROTOTYPE:
CODE:
  RETVAL = PLK_L9;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F20()
PROTOTYPE:
CODE:
  RETVAL = PLK_F20;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_L10()
PROTOTYPE:
CODE:
  RETVAL = PLK_L10;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F21()
PROTOTYPE:
CODE:
  RETVAL = PLK_F21;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R1()
PROTOTYPE:
CODE:
  RETVAL = PLK_R1;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F22()
PROTOTYPE:
CODE:
  RETVAL = PLK_F22;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R2()
PROTOTYPE:
CODE:
  RETVAL = PLK_R2;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F23()
PROTOTYPE:
CODE:
  RETVAL = PLK_F23;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R3()
PROTOTYPE:
CODE:
  RETVAL = PLK_R3;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F24()
PROTOTYPE:
CODE:
  RETVAL = PLK_F24;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R4()
PROTOTYPE:
CODE:
  RETVAL = PLK_R4;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F25()
PROTOTYPE:
CODE:
  RETVAL = PLK_F25;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R5()
PROTOTYPE:
CODE:
  RETVAL = PLK_R5;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F26()
PROTOTYPE:
CODE:
  RETVAL = PLK_F26;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R6()
PROTOTYPE:
CODE:
  RETVAL = PLK_R6;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F27()
PROTOTYPE:
CODE:
  RETVAL = PLK_F27;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R7()
PROTOTYPE:
CODE:
  RETVAL = PLK_R7;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F28()
PROTOTYPE:
CODE:
  RETVAL = PLK_F28;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R8()
PROTOTYPE:
CODE:
  RETVAL = PLK_R8;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F29()
PROTOTYPE:
CODE:
  RETVAL = PLK_F29;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R9()
PROTOTYPE:
CODE:
  RETVAL = PLK_R9;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F30()
PROTOTYPE:
CODE:
  RETVAL = PLK_F30;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R10()
PROTOTYPE:
CODE:
  RETVAL = PLK_R10;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F31()
PROTOTYPE:
CODE:
  RETVAL = PLK_F31;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R11()
PROTOTYPE:
CODE:
  RETVAL = PLK_R11;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F32()
PROTOTYPE:
CODE:
  RETVAL = PLK_F32;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R12()
PROTOTYPE:
CODE:
  RETVAL = PLK_R12;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R13()
PROTOTYPE:
CODE:
  RETVAL = PLK_R13;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F33()
PROTOTYPE:
CODE:
  RETVAL = PLK_F33;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F34()
PROTOTYPE:
CODE:
  RETVAL = PLK_F34;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R14()
PROTOTYPE:
CODE:
  RETVAL = PLK_R14;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_F35()
PROTOTYPE:
CODE:
  RETVAL = PLK_F35;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_R15()
PROTOTYPE:
CODE:
  RETVAL = PLK_R15;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Shift_L()
PROTOTYPE:
CODE:
  RETVAL = PLK_Shift_L;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Shift_R()
PROTOTYPE:
CODE:
  RETVAL = PLK_Shift_R;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Control_L()
PROTOTYPE:
CODE:
  RETVAL = PLK_Control_L;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Control_R()
PROTOTYPE:
CODE:
  RETVAL = PLK_Control_R;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Caps_Lock()
PROTOTYPE:
CODE:
  RETVAL = PLK_Caps_Lock;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Shift_Lock()
PROTOTYPE:
CODE:
  RETVAL = PLK_Shift_Lock;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Meta_L()
PROTOTYPE:
CODE:
  RETVAL = PLK_Meta_L;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Meta_R()
PROTOTYPE:
CODE:
  RETVAL = PLK_Meta_R;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Alt_L()
PROTOTYPE:
CODE:
  RETVAL = PLK_Alt_L;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Alt_R()
PROTOTYPE:
CODE:
  RETVAL = PLK_Alt_R;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Super_L()
PROTOTYPE:
CODE:
  RETVAL = PLK_Super_L;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Super_R()
PROTOTYPE:
CODE:
  RETVAL = PLK_Super_R;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Hyper_L()
PROTOTYPE:
CODE:
  RETVAL = PLK_Hyper_L;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PLK_Hyper_R()
PROTOTYPE:
CODE:
  RETVAL = PLK_Hyper_R;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
GRID_CSA()
PROTOTYPE:
CODE:
  RETVAL = GRID_CSA;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
GRID_DTLI()
PROTOTYPE:
CODE:
  RETVAL = GRID_DTLI;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
GRID_NNI()
PROTOTYPE:
CODE:
  RETVAL = GRID_NNI;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
GRID_NNIDW()
PROTOTYPE:
CODE:
  RETVAL = GRID_NNIDW;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
GRID_NNLI()
PROTOTYPE:
CODE:
  RETVAL = GRID_NNLI;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
GRID_NNAIDW()
PROTOTYPE:
CODE:
  RETVAL = GRID_NNAIDW;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_X_AXIS()
PROTOTYPE:
CODE:
  RETVAL = PL_X_AXIS;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_Y_AXIS()
PROTOTYPE:
CODE:
  RETVAL = PL_Y_AXIS;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_Z_AXIS()
PROTOTYPE:
CODE:
  RETVAL = PL_Z_AXIS;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_SHADE()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_SHADE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_SHADE_LABEL()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_SHADE_LABEL;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_IMAGE()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_IMAGE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_GRADIENT()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_GRADIENT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_CAP_LOW()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_CAP_LOW;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_CAP_HIGH()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_CAP_HIGH;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_LABEL_LEFT()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_LABEL_LEFT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_LABEL_RIGHT()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_LABEL_RIGHT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_LABEL_TOP()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_LABEL_TOP;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_COLORBAR_LABEL_BOTTOM()
PROTOTYPE:
CODE:
  RETVAL = PL_COLORBAR_LABEL_BOTTOM;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_BACKGROUND()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_BACKGROUND;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_BOUNDING_BOX()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_BOUNDING_BOX;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_COLOR_BOX()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_COLOR_BOX;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_LINE()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_LINE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_NONE()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_NONE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_ROW_MAJOR()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_ROW_MAJOR;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_SYMBOL()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_SYMBOL;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_LEGEND_TEXT_LEFT()
PROTOTYPE:
CODE:
  RETVAL = PL_LEGEND_TEXT_LEFT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_BOTTOM()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_BOTTOM;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_INSIDE()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_INSIDE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_LEFT()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_LEFT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_OUTSIDE()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_OUTSIDE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_RIGHT()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_RIGHT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_SUBPAGE()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_SUBPAGE;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_TOP()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_TOP;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
PL_POSITION_VIEWPORT()
PROTOTYPE:
CODE:
  RETVAL = PL_POSITION_VIEWPORT;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
pladv(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *page;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    page = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    page = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::pladv(page) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pladv_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pladv_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((page->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != page->datatype) {
	     page = PDL->get_convertedpdl(page,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = page;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plaxes_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xzero;
  pdl  *yzero;
  pdl  *xtick;
  pdl  *nxsub;
  pdl  *ytick;
  pdl  *nysub;
  char  *xopt;
  char  *yopt;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 8) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xzero = PDL->SvPDLV(ST(0));
    yzero = PDL->SvPDLV(ST(1));
    xtick = PDL->SvPDLV(ST(2));
    nxsub = PDL->SvPDLV(ST(3));
    ytick = PDL->SvPDLV(ST(4));
    nysub = PDL->SvPDLV(ST(5));
    xopt = (char *)SvPV_nolen(ST(6))
;
    yopt = (char *)SvPV_nolen(ST(7))
;
  }
  else if (items == 8) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xzero = PDL->SvPDLV(ST(0));
    yzero = PDL->SvPDLV(ST(1));
    xtick = PDL->SvPDLV(ST(2));
    nxsub = PDL->SvPDLV(ST(3));
    ytick = PDL->SvPDLV(ST(4));
    nysub = PDL->SvPDLV(ST(5));
    xopt = (char *)SvPV_nolen(ST(6))
;
    yopt = (char *)SvPV_nolen(ST(7))
;
  }
  else {
    croak ("Usage:  PDL::plaxes_pp(xzero,yzero,xtick,nxsub,ytick,nysub,xopt,yopt) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plaxes_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plaxes_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xzero->state & PDL_BADVAL) > 0) || ((yzero->state & PDL_BADVAL) > 0) || ((xtick->state & PDL_BADVAL) > 0) || ((nxsub->state & PDL_BADVAL) > 0) || ((ytick->state & PDL_BADVAL) > 0) || ((nysub->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xzero->datatype) {
	     xzero = PDL->get_convertedpdl(xzero,PDL_D);
	  }if(PDL_D != yzero->datatype) {
	     yzero = PDL->get_convertedpdl(yzero,PDL_D);
	  }if(PDL_D != xtick->datatype) {
	     xtick = PDL->get_convertedpdl(xtick,PDL_D);
	  }if(PDL_L != nxsub->datatype) {
	     nxsub = PDL->get_convertedpdl(nxsub,PDL_L);
	  }if(PDL_D != ytick->datatype) {
	     ytick = PDL->get_convertedpdl(ytick,PDL_D);
	  }if(PDL_L != nysub->datatype) {
	     nysub = PDL->get_convertedpdl(nysub,PDL_L);
	  }{(__privtrans->xopt) = malloc(strlen(xopt)+1); strcpy(__privtrans->xopt,xopt);(__privtrans->yopt) = malloc(strlen(yopt)+1); strcpy(__privtrans->yopt,yopt);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xzero;
__privtrans->pdls[1] = yzero;
__privtrans->pdls[2] = xtick;
__privtrans->pdls[3] = nxsub;
__privtrans->pdls[4] = ytick;
__privtrans->pdls[5] = nysub;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plbin(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *nbin;
  pdl  *x;
  pdl  *y;
  pdl  *center;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nbin = PDL->SvPDLV(ST(0));
    x = PDL->SvPDLV(ST(1));
    y = PDL->SvPDLV(ST(2));
    center = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    nbin = PDL->SvPDLV(ST(0));
    x = PDL->SvPDLV(ST(1));
    y = PDL->SvPDLV(ST(2));
    center = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plbin(nbin,x,y,center) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plbin_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plbin_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nbin->state & PDL_BADVAL) > 0) || ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((center->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nbin->datatype) {
	     nbin = PDL->get_convertedpdl(nbin,PDL_L);
	  }if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }if(PDL_L != center->datatype) {
	     center = PDL->get_convertedpdl(center,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nbin;
__privtrans->pdls[1] = x;
__privtrans->pdls[2] = y;
__privtrans->pdls[3] = center;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plbop()
CODE:
	c_plbop();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plbox_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xtick;
  pdl  *nxsub;
  pdl  *ytick;
  pdl  *nysub;
  char  *xopt;
  char  *yopt;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xtick = PDL->SvPDLV(ST(0));
    nxsub = PDL->SvPDLV(ST(1));
    ytick = PDL->SvPDLV(ST(2));
    nysub = PDL->SvPDLV(ST(3));
    xopt = (char *)SvPV_nolen(ST(4))
;
    yopt = (char *)SvPV_nolen(ST(5))
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xtick = PDL->SvPDLV(ST(0));
    nxsub = PDL->SvPDLV(ST(1));
    ytick = PDL->SvPDLV(ST(2));
    nysub = PDL->SvPDLV(ST(3));
    xopt = (char *)SvPV_nolen(ST(4))
;
    yopt = (char *)SvPV_nolen(ST(5))
;
  }
  else {
    croak ("Usage:  PDL::plbox_pp(xtick,nxsub,ytick,nysub,xopt,yopt) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plbox_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plbox_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xtick->state & PDL_BADVAL) > 0) || ((nxsub->state & PDL_BADVAL) > 0) || ((ytick->state & PDL_BADVAL) > 0) || ((nysub->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xtick->datatype) {
	     xtick = PDL->get_convertedpdl(xtick,PDL_D);
	  }if(PDL_L != nxsub->datatype) {
	     nxsub = PDL->get_convertedpdl(nxsub,PDL_L);
	  }if(PDL_D != ytick->datatype) {
	     ytick = PDL->get_convertedpdl(ytick,PDL_D);
	  }if(PDL_L != nysub->datatype) {
	     nysub = PDL->get_convertedpdl(nysub,PDL_L);
	  }{(__privtrans->xopt) = malloc(strlen(xopt)+1); strcpy(__privtrans->xopt,xopt);(__privtrans->yopt) = malloc(strlen(yopt)+1); strcpy(__privtrans->yopt,yopt);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xtick;
__privtrans->pdls[1] = nxsub;
__privtrans->pdls[2] = ytick;
__privtrans->pdls[3] = nysub;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plbox3_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xtick;
  pdl  *nsubx;
  pdl  *ytick;
  pdl  *nsuby;
  pdl  *ztick;
  pdl  *nsubz;
  char  *xopt;
  char  *xlabel;
  char  *yopt;
  char  *ylabel;
  char  *zopt;
  char  *zlabel;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 12) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xtick = PDL->SvPDLV(ST(0));
    nsubx = PDL->SvPDLV(ST(1));
    ytick = PDL->SvPDLV(ST(2));
    nsuby = PDL->SvPDLV(ST(3));
    ztick = PDL->SvPDLV(ST(4));
    nsubz = PDL->SvPDLV(ST(5));
    xopt = (char *)SvPV_nolen(ST(6))
;
    xlabel = (char *)SvPV_nolen(ST(7))
;
    yopt = (char *)SvPV_nolen(ST(8))
;
    ylabel = (char *)SvPV_nolen(ST(9))
;
    zopt = (char *)SvPV_nolen(ST(10))
;
    zlabel = (char *)SvPV_nolen(ST(11))
;
  }
  else if (items == 12) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xtick = PDL->SvPDLV(ST(0));
    nsubx = PDL->SvPDLV(ST(1));
    ytick = PDL->SvPDLV(ST(2));
    nsuby = PDL->SvPDLV(ST(3));
    ztick = PDL->SvPDLV(ST(4));
    nsubz = PDL->SvPDLV(ST(5));
    xopt = (char *)SvPV_nolen(ST(6))
;
    xlabel = (char *)SvPV_nolen(ST(7))
;
    yopt = (char *)SvPV_nolen(ST(8))
;
    ylabel = (char *)SvPV_nolen(ST(9))
;
    zopt = (char *)SvPV_nolen(ST(10))
;
    zlabel = (char *)SvPV_nolen(ST(11))
;
  }
  else {
    croak ("Usage:  PDL::plbox3_pp(xtick,nsubx,ytick,nsuby,ztick,nsubz,xopt,xlabel,yopt,ylabel,zopt,zlabel) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plbox3_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plbox3_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xtick->state & PDL_BADVAL) > 0) || ((nsubx->state & PDL_BADVAL) > 0) || ((ytick->state & PDL_BADVAL) > 0) || ((nsuby->state & PDL_BADVAL) > 0) || ((ztick->state & PDL_BADVAL) > 0) || ((nsubz->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xtick->datatype) {
	     xtick = PDL->get_convertedpdl(xtick,PDL_D);
	  }if(PDL_L != nsubx->datatype) {
	     nsubx = PDL->get_convertedpdl(nsubx,PDL_L);
	  }if(PDL_D != ytick->datatype) {
	     ytick = PDL->get_convertedpdl(ytick,PDL_D);
	  }if(PDL_L != nsuby->datatype) {
	     nsuby = PDL->get_convertedpdl(nsuby,PDL_L);
	  }if(PDL_D != ztick->datatype) {
	     ztick = PDL->get_convertedpdl(ztick,PDL_D);
	  }if(PDL_L != nsubz->datatype) {
	     nsubz = PDL->get_convertedpdl(nsubz,PDL_L);
	  }{(__privtrans->xopt) = malloc(strlen(xopt)+1); strcpy(__privtrans->xopt,xopt);(__privtrans->xlabel) = malloc(strlen(xlabel)+1); strcpy(__privtrans->xlabel,xlabel);(__privtrans->yopt) = malloc(strlen(yopt)+1); strcpy(__privtrans->yopt,yopt);(__privtrans->ylabel) = malloc(strlen(ylabel)+1); strcpy(__privtrans->ylabel,ylabel);(__privtrans->zopt) = malloc(strlen(zopt)+1); strcpy(__privtrans->zopt,zopt);(__privtrans->zlabel) = malloc(strlen(zlabel)+1); strcpy(__privtrans->zlabel,zlabel);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xtick;
__privtrans->pdls[1] = nsubx;
__privtrans->pdls[2] = ytick;
__privtrans->pdls[3] = nsuby;
__privtrans->pdls[4] = ztick;
__privtrans->pdls[5] = nsubz;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plclear()
CODE:
	c_plclear();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plcol0(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *icolzero;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plcol0(icolzero) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plcol0_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plcol0_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((icolzero->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != icolzero->datatype) {
	     icolzero = PDL->get_convertedpdl(icolzero,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = icolzero;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plcol1(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *colone;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    colone = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    colone = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plcol1(colone) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plcol1_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plcol1_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((colone->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != colone->datatype) {
	     colone = PDL->get_convertedpdl(colone,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = colone;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plcpstrm(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *iplsr;
  pdl  *flags;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    iplsr = PDL->SvPDLV(ST(0));
    flags = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    iplsr = PDL->SvPDLV(ST(0));
    flags = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plcpstrm(iplsr,flags) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plcpstrm_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plcpstrm_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((iplsr->state & PDL_BADVAL) > 0) || ((flags->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != iplsr->datatype) {
	     iplsr = PDL->get_convertedpdl(iplsr,PDL_L);
	  }if(PDL_L != flags->datatype) {
	     flags = PDL->get_convertedpdl(flags,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = iplsr;
__privtrans->pdls[1] = flags;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
pldid2pc(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *ymin;
  pdl  *xmax;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::pldid2pc(xmin,ymin,xmax,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pldid2pc_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pldid2pc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = ymin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
pldip2dc(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *ymin;
  pdl  *xmax;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::pldip2dc(xmin,ymin,xmax,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pldip2dc_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pldip2dc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = ymin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plend()
CODE:
	c_plend();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plend1()
CODE:
	c_plend1();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plenv(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *just;
  pdl  *axis;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
    just = PDL->SvPDLV(ST(4));
    axis = PDL->SvPDLV(ST(5));
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
    just = PDL->SvPDLV(ST(4));
    axis = PDL->SvPDLV(ST(5));
  }
  else {
    croak ("Usage:  PDL::plenv(xmin,xmax,ymin,ymax,just,axis) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plenv_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plenv_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((just->state & PDL_BADVAL) > 0) || ((axis->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }if(PDL_L != just->datatype) {
	     just = PDL->get_convertedpdl(just,PDL_L);
	  }if(PDL_L != axis->datatype) {
	     axis = PDL->get_convertedpdl(axis,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
__privtrans->pdls[4] = just;
__privtrans->pdls[5] = axis;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plenv0(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *just;
  pdl  *axis;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
    just = PDL->SvPDLV(ST(4));
    axis = PDL->SvPDLV(ST(5));
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
    just = PDL->SvPDLV(ST(4));
    axis = PDL->SvPDLV(ST(5));
  }
  else {
    croak ("Usage:  PDL::plenv0(xmin,xmax,ymin,ymax,just,axis) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plenv0_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plenv0_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((just->state & PDL_BADVAL) > 0) || ((axis->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }if(PDL_L != just->datatype) {
	     just = PDL->get_convertedpdl(just,PDL_L);
	  }if(PDL_L != axis->datatype) {
	     axis = PDL->get_convertedpdl(axis,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
__privtrans->pdls[4] = just;
__privtrans->pdls[5] = axis;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pleop()
CODE:
	c_pleop();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plerrx(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *n;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *y;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    n = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    y = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    n = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    y = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plerrx(n,xmin,xmax,y) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plerrx_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plerrx_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((n->state & PDL_BADVAL) > 0) || ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != n->datatype) {
	     n = PDL->get_convertedpdl(n,PDL_L);
	  }if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = n;
__privtrans->pdls[1] = xmin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plerry(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *n;
  pdl  *x;
  pdl  *ymin;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    n = PDL->SvPDLV(ST(0));
    x = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    n = PDL->SvPDLV(ST(0));
    x = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plerry(n,x,ymin,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plerry_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plerry_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((n->state & PDL_BADVAL) > 0) || ((x->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != n->datatype) {
	     n = PDL->get_convertedpdl(n,PDL_L);
	  }if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = n;
__privtrans->pdls[1] = x;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plfamadv()
CODE:
	c_plfamadv();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plfill3(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *n;
  pdl  *x;
  pdl  *y;
  pdl  *z;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    n = PDL->SvPDLV(ST(0));
    x = PDL->SvPDLV(ST(1));
    y = PDL->SvPDLV(ST(2));
    z = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    n = PDL->SvPDLV(ST(0));
    x = PDL->SvPDLV(ST(1));
    y = PDL->SvPDLV(ST(2));
    z = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plfill3(n,x,y,z) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plfill3_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plfill3_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((n->state & PDL_BADVAL) > 0) || ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != n->datatype) {
	     n = PDL->get_convertedpdl(n,PDL_L);
	  }if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }if(PDL_D != z->datatype) {
	     z = PDL->get_convertedpdl(z,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = n;
__privtrans->pdls[1] = x;
__privtrans->pdls[2] = y;
__privtrans->pdls[3] = z;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plflush()
CODE:
	c_plflush();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plfont(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *ifont;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    ifont = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    ifont = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plfont(ifont) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plfont_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plfont_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ifont->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != ifont->datatype) {
	     ifont = PDL->get_convertedpdl(ifont,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ifont;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plfontld(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *fnt;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    fnt = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    fnt = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plfontld(fnt) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plfontld_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plfontld_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((fnt->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != fnt->datatype) {
	     fnt = PDL->get_convertedpdl(fnt,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = fnt;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgchr(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_def_SV;
  SV *p_ht_SV;
  pdl  *p_def;
  pdl  *p_ht;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_def = PDL->SvPDLV(ST(0));
    p_ht = PDL->SvPDLV(ST(1));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_def_SV = sv_newmortal();
       p_def = PDL->null();
       PDL->SetSV_PDL(p_def_SV,p_def);
       if (bless_stash) p_def_SV = sv_bless(p_def_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_def_SV = POPs;
       PUTBACK;
       p_def = PDL->SvPDLV(p_def_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ht_SV = sv_newmortal();
       p_ht = PDL->null();
       PDL->SetSV_PDL(p_ht_SV,p_ht);
       if (bless_stash) p_ht_SV = sv_bless(p_ht_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ht_SV = POPs;
       PUTBACK;
       p_ht = PDL->SvPDLV(p_ht_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgchr(p_def,p_ht) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgchr_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgchr_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_def->state & PDL_NOMYDIMS) && p_def->trans == NULL ) {
	     p_def->datatype = PDL_D;
	  } else if(PDL_D != p_def->datatype) {
	     p_def = PDL->get_convertedpdl(p_def,PDL_D);
	  }if( (p_ht->state & PDL_NOMYDIMS) && p_ht->trans == NULL ) {
	     p_ht->datatype = PDL_D;
	  } else if(PDL_D != p_ht->datatype) {
	     p_ht = PDL->get_convertedpdl(p_ht,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_def;
__privtrans->pdls[1] = p_ht;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_def->state |= PDL_BADVAL;
  p_ht->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_def_SV;
  ST(1) = p_ht_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgcompression(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *compression_SV;
  pdl  *compression;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    compression = PDL->SvPDLV(ST(0));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       compression_SV = sv_newmortal();
       compression = PDL->null();
       PDL->SetSV_PDL(compression_SV,compression);
       if (bless_stash) compression_SV = sv_bless(compression_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       compression_SV = POPs;
       PUTBACK;
       compression = PDL->SvPDLV(compression_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgcompression(compression) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgcompression_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgcompression_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (compression->state & PDL_NOMYDIMS) && compression->trans == NULL ) {
	     compression->datatype = PDL_L;
	  } else if(PDL_L != compression->datatype) {
	     compression = PDL->get_convertedpdl(compression,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = compression;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  compression->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = compression_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgdidev(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_mar_SV;
  SV *p_aspect_SV;
  SV *p_jx_SV;
  SV *p_jy_SV;
  pdl  *p_mar;
  pdl  *p_aspect;
  pdl  *p_jx;
  pdl  *p_jy;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_mar = PDL->SvPDLV(ST(0));
    p_aspect = PDL->SvPDLV(ST(1));
    p_jx = PDL->SvPDLV(ST(2));
    p_jy = PDL->SvPDLV(ST(3));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_mar_SV = sv_newmortal();
       p_mar = PDL->null();
       PDL->SetSV_PDL(p_mar_SV,p_mar);
       if (bless_stash) p_mar_SV = sv_bless(p_mar_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_mar_SV = POPs;
       PUTBACK;
       p_mar = PDL->SvPDLV(p_mar_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_aspect_SV = sv_newmortal();
       p_aspect = PDL->null();
       PDL->SetSV_PDL(p_aspect_SV,p_aspect);
       if (bless_stash) p_aspect_SV = sv_bless(p_aspect_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_aspect_SV = POPs;
       PUTBACK;
       p_aspect = PDL->SvPDLV(p_aspect_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_jx_SV = sv_newmortal();
       p_jx = PDL->null();
       PDL->SetSV_PDL(p_jx_SV,p_jx);
       if (bless_stash) p_jx_SV = sv_bless(p_jx_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_jx_SV = POPs;
       PUTBACK;
       p_jx = PDL->SvPDLV(p_jx_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_jy_SV = sv_newmortal();
       p_jy = PDL->null();
       PDL->SetSV_PDL(p_jy_SV,p_jy);
       if (bless_stash) p_jy_SV = sv_bless(p_jy_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_jy_SV = POPs;
       PUTBACK;
       p_jy = PDL->SvPDLV(p_jy_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgdidev(p_mar,p_aspect,p_jx,p_jy) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgdidev_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgdidev_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_mar->state & PDL_NOMYDIMS) && p_mar->trans == NULL ) {
	     p_mar->datatype = PDL_D;
	  } else if(PDL_D != p_mar->datatype) {
	     p_mar = PDL->get_convertedpdl(p_mar,PDL_D);
	  }if( (p_aspect->state & PDL_NOMYDIMS) && p_aspect->trans == NULL ) {
	     p_aspect->datatype = PDL_D;
	  } else if(PDL_D != p_aspect->datatype) {
	     p_aspect = PDL->get_convertedpdl(p_aspect,PDL_D);
	  }if( (p_jx->state & PDL_NOMYDIMS) && p_jx->trans == NULL ) {
	     p_jx->datatype = PDL_D;
	  } else if(PDL_D != p_jx->datatype) {
	     p_jx = PDL->get_convertedpdl(p_jx,PDL_D);
	  }if( (p_jy->state & PDL_NOMYDIMS) && p_jy->trans == NULL ) {
	     p_jy->datatype = PDL_D;
	  } else if(PDL_D != p_jy->datatype) {
	     p_jy = PDL->get_convertedpdl(p_jy,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_mar;
__privtrans->pdls[1] = p_aspect;
__privtrans->pdls[2] = p_jx;
__privtrans->pdls[3] = p_jy;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_mar->state |= PDL_BADVAL;
  p_aspect->state |= PDL_BADVAL;
  p_jx->state |= PDL_BADVAL;
  p_jy->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_mar_SV;
  ST(1) = p_aspect_SV;
  ST(2) = p_jx_SV;
  ST(3) = p_jy_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgdiori(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_rot_SV;
  pdl  *p_rot;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_rot = PDL->SvPDLV(ST(0));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_rot_SV = sv_newmortal();
       p_rot = PDL->null();
       PDL->SetSV_PDL(p_rot_SV,p_rot);
       if (bless_stash) p_rot_SV = sv_bless(p_rot_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_rot_SV = POPs;
       PUTBACK;
       p_rot = PDL->SvPDLV(p_rot_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgdiori(p_rot) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgdiori_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgdiori_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_rot->state & PDL_NOMYDIMS) && p_rot->trans == NULL ) {
	     p_rot->datatype = PDL_D;
	  } else if(PDL_D != p_rot->datatype) {
	     p_rot = PDL->get_convertedpdl(p_rot,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_rot;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_rot->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_rot_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgdiplt(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_xmin_SV;
  SV *p_ymin_SV;
  SV *p_xmax_SV;
  SV *p_ymax_SV;
  pdl  *p_xmin;
  pdl  *p_ymin;
  pdl  *p_xmax;
  pdl  *p_ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_xmin = PDL->SvPDLV(ST(0));
    p_ymin = PDL->SvPDLV(ST(1));
    p_xmax = PDL->SvPDLV(ST(2));
    p_ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xmin_SV = sv_newmortal();
       p_xmin = PDL->null();
       PDL->SetSV_PDL(p_xmin_SV,p_xmin);
       if (bless_stash) p_xmin_SV = sv_bless(p_xmin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xmin_SV = POPs;
       PUTBACK;
       p_xmin = PDL->SvPDLV(p_xmin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ymin_SV = sv_newmortal();
       p_ymin = PDL->null();
       PDL->SetSV_PDL(p_ymin_SV,p_ymin);
       if (bless_stash) p_ymin_SV = sv_bless(p_ymin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ymin_SV = POPs;
       PUTBACK;
       p_ymin = PDL->SvPDLV(p_ymin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xmax_SV = sv_newmortal();
       p_xmax = PDL->null();
       PDL->SetSV_PDL(p_xmax_SV,p_xmax);
       if (bless_stash) p_xmax_SV = sv_bless(p_xmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xmax_SV = POPs;
       PUTBACK;
       p_xmax = PDL->SvPDLV(p_xmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ymax_SV = sv_newmortal();
       p_ymax = PDL->null();
       PDL->SetSV_PDL(p_ymax_SV,p_ymax);
       if (bless_stash) p_ymax_SV = sv_bless(p_ymax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ymax_SV = POPs;
       PUTBACK;
       p_ymax = PDL->SvPDLV(p_ymax_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgdiplt(p_xmin,p_ymin,p_xmax,p_ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgdiplt_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgdiplt_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_xmin->state & PDL_NOMYDIMS) && p_xmin->trans == NULL ) {
	     p_xmin->datatype = PDL_D;
	  } else if(PDL_D != p_xmin->datatype) {
	     p_xmin = PDL->get_convertedpdl(p_xmin,PDL_D);
	  }if( (p_ymin->state & PDL_NOMYDIMS) && p_ymin->trans == NULL ) {
	     p_ymin->datatype = PDL_D;
	  } else if(PDL_D != p_ymin->datatype) {
	     p_ymin = PDL->get_convertedpdl(p_ymin,PDL_D);
	  }if( (p_xmax->state & PDL_NOMYDIMS) && p_xmax->trans == NULL ) {
	     p_xmax->datatype = PDL_D;
	  } else if(PDL_D != p_xmax->datatype) {
	     p_xmax = PDL->get_convertedpdl(p_xmax,PDL_D);
	  }if( (p_ymax->state & PDL_NOMYDIMS) && p_ymax->trans == NULL ) {
	     p_ymax->datatype = PDL_D;
	  } else if(PDL_D != p_ymax->datatype) {
	     p_ymax = PDL->get_convertedpdl(p_ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_xmin;
__privtrans->pdls[1] = p_ymin;
__privtrans->pdls[2] = p_xmax;
__privtrans->pdls[3] = p_ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_xmin->state |= PDL_BADVAL;
  p_ymin->state |= PDL_BADVAL;
  p_xmax->state |= PDL_BADVAL;
  p_ymax->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_xmin_SV;
  ST(1) = p_ymin_SV;
  ST(2) = p_xmax_SV;
  ST(3) = p_ymax_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgfam(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_fam_SV;
  SV *p_num_SV;
  SV *p_bmax_SV;
  pdl  *p_fam;
  pdl  *p_num;
  pdl  *p_bmax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_fam = PDL->SvPDLV(ST(0));
    p_num = PDL->SvPDLV(ST(1));
    p_bmax = PDL->SvPDLV(ST(2));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_fam_SV = sv_newmortal();
       p_fam = PDL->null();
       PDL->SetSV_PDL(p_fam_SV,p_fam);
       if (bless_stash) p_fam_SV = sv_bless(p_fam_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_fam_SV = POPs;
       PUTBACK;
       p_fam = PDL->SvPDLV(p_fam_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_num_SV = sv_newmortal();
       p_num = PDL->null();
       PDL->SetSV_PDL(p_num_SV,p_num);
       if (bless_stash) p_num_SV = sv_bless(p_num_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_num_SV = POPs;
       PUTBACK;
       p_num = PDL->SvPDLV(p_num_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_bmax_SV = sv_newmortal();
       p_bmax = PDL->null();
       PDL->SetSV_PDL(p_bmax_SV,p_bmax);
       if (bless_stash) p_bmax_SV = sv_bless(p_bmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_bmax_SV = POPs;
       PUTBACK;
       p_bmax = PDL->SvPDLV(p_bmax_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgfam(p_fam,p_num,p_bmax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgfam_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgfam_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_fam->state & PDL_NOMYDIMS) && p_fam->trans == NULL ) {
	     p_fam->datatype = PDL_L;
	  } else if(PDL_L != p_fam->datatype) {
	     p_fam = PDL->get_convertedpdl(p_fam,PDL_L);
	  }if( (p_num->state & PDL_NOMYDIMS) && p_num->trans == NULL ) {
	     p_num->datatype = PDL_L;
	  } else if(PDL_L != p_num->datatype) {
	     p_num = PDL->get_convertedpdl(p_num,PDL_L);
	  }if( (p_bmax->state & PDL_NOMYDIMS) && p_bmax->trans == NULL ) {
	     p_bmax->datatype = PDL_L;
	  } else if(PDL_L != p_bmax->datatype) {
	     p_bmax = PDL->get_convertedpdl(p_bmax,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_fam;
__privtrans->pdls[1] = p_num;
__privtrans->pdls[2] = p_bmax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_fam->state |= PDL_BADVAL;
  p_num->state |= PDL_BADVAL;
  p_bmax->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_fam_SV;
  ST(1) = p_num_SV;
  ST(2) = p_bmax_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plglevel(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_level_SV;
  pdl  *p_level;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_level = PDL->SvPDLV(ST(0));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_level_SV = sv_newmortal();
       p_level = PDL->null();
       PDL->SetSV_PDL(p_level_SV,p_level);
       if (bless_stash) p_level_SV = sv_bless(p_level_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_level_SV = POPs;
       PUTBACK;
       p_level = PDL->SvPDLV(p_level_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plglevel(p_level) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plglevel_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plglevel_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_level->state & PDL_NOMYDIMS) && p_level->trans == NULL ) {
	     p_level->datatype = PDL_L;
	  } else if(PDL_L != p_level->datatype) {
	     p_level = PDL->get_convertedpdl(p_level,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_level;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_level->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_level_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgpage(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_xp_SV;
  SV *p_yp_SV;
  SV *p_xleng_SV;
  SV *p_yleng_SV;
  SV *p_xoff_SV;
  SV *p_yoff_SV;
  pdl  *p_xp;
  pdl  *p_yp;
  pdl  *p_xleng;
  pdl  *p_yleng;
  pdl  *p_xoff;
  pdl  *p_yoff;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_xp = PDL->SvPDLV(ST(0));
    p_yp = PDL->SvPDLV(ST(1));
    p_xleng = PDL->SvPDLV(ST(2));
    p_yleng = PDL->SvPDLV(ST(3));
    p_xoff = PDL->SvPDLV(ST(4));
    p_yoff = PDL->SvPDLV(ST(5));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 6;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xp_SV = sv_newmortal();
       p_xp = PDL->null();
       PDL->SetSV_PDL(p_xp_SV,p_xp);
       if (bless_stash) p_xp_SV = sv_bless(p_xp_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xp_SV = POPs;
       PUTBACK;
       p_xp = PDL->SvPDLV(p_xp_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_yp_SV = sv_newmortal();
       p_yp = PDL->null();
       PDL->SetSV_PDL(p_yp_SV,p_yp);
       if (bless_stash) p_yp_SV = sv_bless(p_yp_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_yp_SV = POPs;
       PUTBACK;
       p_yp = PDL->SvPDLV(p_yp_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xleng_SV = sv_newmortal();
       p_xleng = PDL->null();
       PDL->SetSV_PDL(p_xleng_SV,p_xleng);
       if (bless_stash) p_xleng_SV = sv_bless(p_xleng_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xleng_SV = POPs;
       PUTBACK;
       p_xleng = PDL->SvPDLV(p_xleng_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_yleng_SV = sv_newmortal();
       p_yleng = PDL->null();
       PDL->SetSV_PDL(p_yleng_SV,p_yleng);
       if (bless_stash) p_yleng_SV = sv_bless(p_yleng_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_yleng_SV = POPs;
       PUTBACK;
       p_yleng = PDL->SvPDLV(p_yleng_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xoff_SV = sv_newmortal();
       p_xoff = PDL->null();
       PDL->SetSV_PDL(p_xoff_SV,p_xoff);
       if (bless_stash) p_xoff_SV = sv_bless(p_xoff_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xoff_SV = POPs;
       PUTBACK;
       p_xoff = PDL->SvPDLV(p_xoff_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_yoff_SV = sv_newmortal();
       p_yoff = PDL->null();
       PDL->SetSV_PDL(p_yoff_SV,p_yoff);
       if (bless_stash) p_yoff_SV = sv_bless(p_yoff_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_yoff_SV = POPs;
       PUTBACK;
       p_yoff = PDL->SvPDLV(p_yoff_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgpage(p_xp,p_yp,p_xleng,p_yleng,p_xoff,p_yoff) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgpage_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgpage_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_xp->state & PDL_NOMYDIMS) && p_xp->trans == NULL ) {
	     p_xp->datatype = PDL_D;
	  } else if(PDL_D != p_xp->datatype) {
	     p_xp = PDL->get_convertedpdl(p_xp,PDL_D);
	  }if( (p_yp->state & PDL_NOMYDIMS) && p_yp->trans == NULL ) {
	     p_yp->datatype = PDL_D;
	  } else if(PDL_D != p_yp->datatype) {
	     p_yp = PDL->get_convertedpdl(p_yp,PDL_D);
	  }if( (p_xleng->state & PDL_NOMYDIMS) && p_xleng->trans == NULL ) {
	     p_xleng->datatype = PDL_L;
	  } else if(PDL_L != p_xleng->datatype) {
	     p_xleng = PDL->get_convertedpdl(p_xleng,PDL_L);
	  }if( (p_yleng->state & PDL_NOMYDIMS) && p_yleng->trans == NULL ) {
	     p_yleng->datatype = PDL_L;
	  } else if(PDL_L != p_yleng->datatype) {
	     p_yleng = PDL->get_convertedpdl(p_yleng,PDL_L);
	  }if( (p_xoff->state & PDL_NOMYDIMS) && p_xoff->trans == NULL ) {
	     p_xoff->datatype = PDL_L;
	  } else if(PDL_L != p_xoff->datatype) {
	     p_xoff = PDL->get_convertedpdl(p_xoff,PDL_L);
	  }if( (p_yoff->state & PDL_NOMYDIMS) && p_yoff->trans == NULL ) {
	     p_yoff->datatype = PDL_L;
	  } else if(PDL_L != p_yoff->datatype) {
	     p_yoff = PDL->get_convertedpdl(p_yoff,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_xp;
__privtrans->pdls[1] = p_yp;
__privtrans->pdls[2] = p_xleng;
__privtrans->pdls[3] = p_yleng;
__privtrans->pdls[4] = p_xoff;
__privtrans->pdls[5] = p_yoff;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_xp->state |= PDL_BADVAL;
  p_yp->state |= PDL_BADVAL;
  p_xleng->state |= PDL_BADVAL;
  p_yleng->state |= PDL_BADVAL;
  p_xoff->state |= PDL_BADVAL;
  p_yoff->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_xp_SV;
  ST(1) = p_yp_SV;
  ST(2) = p_xleng_SV;
  ST(3) = p_yleng_SV;
  ST(4) = p_xoff_SV;
  ST(5) = p_yoff_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plgra()
CODE:
	c_plgra();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plgspa(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *xmin_SV;
  SV *xmax_SV;
  SV *ymin_SV;
  SV *ymax_SV;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       xmin_SV = sv_newmortal();
       xmin = PDL->null();
       PDL->SetSV_PDL(xmin_SV,xmin);
       if (bless_stash) xmin_SV = sv_bless(xmin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       xmin_SV = POPs;
       PUTBACK;
       xmin = PDL->SvPDLV(xmin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       xmax_SV = sv_newmortal();
       xmax = PDL->null();
       PDL->SetSV_PDL(xmax_SV,xmax);
       if (bless_stash) xmax_SV = sv_bless(xmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       xmax_SV = POPs;
       PUTBACK;
       xmax = PDL->SvPDLV(xmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       ymin_SV = sv_newmortal();
       ymin = PDL->null();
       PDL->SetSV_PDL(ymin_SV,ymin);
       if (bless_stash) ymin_SV = sv_bless(ymin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       ymin_SV = POPs;
       PUTBACK;
       ymin = PDL->SvPDLV(ymin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       ymax_SV = sv_newmortal();
       ymax = PDL->null();
       PDL->SetSV_PDL(ymax_SV,ymax);
       if (bless_stash) ymax_SV = sv_bless(ymax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       ymax_SV = POPs;
       PUTBACK;
       ymax = PDL->SvPDLV(ymax_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgspa(xmin,xmax,ymin,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgspa_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgspa_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (xmin->state & PDL_NOMYDIMS) && xmin->trans == NULL ) {
	     xmin->datatype = PDL_D;
	  } else if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if( (xmax->state & PDL_NOMYDIMS) && xmax->trans == NULL ) {
	     xmax->datatype = PDL_D;
	  } else if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if( (ymin->state & PDL_NOMYDIMS) && ymin->trans == NULL ) {
	     ymin->datatype = PDL_D;
	  } else if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if( (ymax->state & PDL_NOMYDIMS) && ymax->trans == NULL ) {
	     ymax->datatype = PDL_D;
	  } else if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  xmin->state |= PDL_BADVAL;
  xmax->state |= PDL_BADVAL;
  ymin->state |= PDL_BADVAL;
  ymax->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = xmin_SV;
  ST(1) = xmax_SV;
  ST(2) = ymin_SV;
  ST(3) = ymax_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgvpd(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_xmin_SV;
  SV *p_xmax_SV;
  SV *p_ymin_SV;
  SV *p_ymax_SV;
  pdl  *p_xmin;
  pdl  *p_xmax;
  pdl  *p_ymin;
  pdl  *p_ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_xmin = PDL->SvPDLV(ST(0));
    p_xmax = PDL->SvPDLV(ST(1));
    p_ymin = PDL->SvPDLV(ST(2));
    p_ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xmin_SV = sv_newmortal();
       p_xmin = PDL->null();
       PDL->SetSV_PDL(p_xmin_SV,p_xmin);
       if (bless_stash) p_xmin_SV = sv_bless(p_xmin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xmin_SV = POPs;
       PUTBACK;
       p_xmin = PDL->SvPDLV(p_xmin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xmax_SV = sv_newmortal();
       p_xmax = PDL->null();
       PDL->SetSV_PDL(p_xmax_SV,p_xmax);
       if (bless_stash) p_xmax_SV = sv_bless(p_xmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xmax_SV = POPs;
       PUTBACK;
       p_xmax = PDL->SvPDLV(p_xmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ymin_SV = sv_newmortal();
       p_ymin = PDL->null();
       PDL->SetSV_PDL(p_ymin_SV,p_ymin);
       if (bless_stash) p_ymin_SV = sv_bless(p_ymin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ymin_SV = POPs;
       PUTBACK;
       p_ymin = PDL->SvPDLV(p_ymin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ymax_SV = sv_newmortal();
       p_ymax = PDL->null();
       PDL->SetSV_PDL(p_ymax_SV,p_ymax);
       if (bless_stash) p_ymax_SV = sv_bless(p_ymax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ymax_SV = POPs;
       PUTBACK;
       p_ymax = PDL->SvPDLV(p_ymax_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgvpd(p_xmin,p_xmax,p_ymin,p_ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgvpd_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgvpd_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_xmin->state & PDL_NOMYDIMS) && p_xmin->trans == NULL ) {
	     p_xmin->datatype = PDL_D;
	  } else if(PDL_D != p_xmin->datatype) {
	     p_xmin = PDL->get_convertedpdl(p_xmin,PDL_D);
	  }if( (p_xmax->state & PDL_NOMYDIMS) && p_xmax->trans == NULL ) {
	     p_xmax->datatype = PDL_D;
	  } else if(PDL_D != p_xmax->datatype) {
	     p_xmax = PDL->get_convertedpdl(p_xmax,PDL_D);
	  }if( (p_ymin->state & PDL_NOMYDIMS) && p_ymin->trans == NULL ) {
	     p_ymin->datatype = PDL_D;
	  } else if(PDL_D != p_ymin->datatype) {
	     p_ymin = PDL->get_convertedpdl(p_ymin,PDL_D);
	  }if( (p_ymax->state & PDL_NOMYDIMS) && p_ymax->trans == NULL ) {
	     p_ymax->datatype = PDL_D;
	  } else if(PDL_D != p_ymax->datatype) {
	     p_ymax = PDL->get_convertedpdl(p_ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_xmin;
__privtrans->pdls[1] = p_xmax;
__privtrans->pdls[2] = p_ymin;
__privtrans->pdls[3] = p_ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_xmin->state |= PDL_BADVAL;
  p_xmax->state |= PDL_BADVAL;
  p_ymin->state |= PDL_BADVAL;
  p_ymax->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_xmin_SV;
  ST(1) = p_xmax_SV;
  ST(2) = p_ymin_SV;
  ST(3) = p_ymax_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgvpw(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_xmin_SV;
  SV *p_xmax_SV;
  SV *p_ymin_SV;
  SV *p_ymax_SV;
  pdl  *p_xmin;
  pdl  *p_xmax;
  pdl  *p_ymin;
  pdl  *p_ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_xmin = PDL->SvPDLV(ST(0));
    p_xmax = PDL->SvPDLV(ST(1));
    p_ymin = PDL->SvPDLV(ST(2));
    p_ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xmin_SV = sv_newmortal();
       p_xmin = PDL->null();
       PDL->SetSV_PDL(p_xmin_SV,p_xmin);
       if (bless_stash) p_xmin_SV = sv_bless(p_xmin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xmin_SV = POPs;
       PUTBACK;
       p_xmin = PDL->SvPDLV(p_xmin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_xmax_SV = sv_newmortal();
       p_xmax = PDL->null();
       PDL->SetSV_PDL(p_xmax_SV,p_xmax);
       if (bless_stash) p_xmax_SV = sv_bless(p_xmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_xmax_SV = POPs;
       PUTBACK;
       p_xmax = PDL->SvPDLV(p_xmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ymin_SV = sv_newmortal();
       p_ymin = PDL->null();
       PDL->SetSV_PDL(p_ymin_SV,p_ymin);
       if (bless_stash) p_ymin_SV = sv_bless(p_ymin_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ymin_SV = POPs;
       PUTBACK;
       p_ymin = PDL->SvPDLV(p_ymin_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_ymax_SV = sv_newmortal();
       p_ymax = PDL->null();
       PDL->SetSV_PDL(p_ymax_SV,p_ymax);
       if (bless_stash) p_ymax_SV = sv_bless(p_ymax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_ymax_SV = POPs;
       PUTBACK;
       p_ymax = PDL->SvPDLV(p_ymax_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgvpw(p_xmin,p_xmax,p_ymin,p_ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgvpw_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgvpw_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_xmin->state & PDL_NOMYDIMS) && p_xmin->trans == NULL ) {
	     p_xmin->datatype = PDL_D;
	  } else if(PDL_D != p_xmin->datatype) {
	     p_xmin = PDL->get_convertedpdl(p_xmin,PDL_D);
	  }if( (p_xmax->state & PDL_NOMYDIMS) && p_xmax->trans == NULL ) {
	     p_xmax->datatype = PDL_D;
	  } else if(PDL_D != p_xmax->datatype) {
	     p_xmax = PDL->get_convertedpdl(p_xmax,PDL_D);
	  }if( (p_ymin->state & PDL_NOMYDIMS) && p_ymin->trans == NULL ) {
	     p_ymin->datatype = PDL_D;
	  } else if(PDL_D != p_ymin->datatype) {
	     p_ymin = PDL->get_convertedpdl(p_ymin,PDL_D);
	  }if( (p_ymax->state & PDL_NOMYDIMS) && p_ymax->trans == NULL ) {
	     p_ymax->datatype = PDL_D;
	  } else if(PDL_D != p_ymax->datatype) {
	     p_ymax = PDL->get_convertedpdl(p_ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_xmin;
__privtrans->pdls[1] = p_xmax;
__privtrans->pdls[2] = p_ymin;
__privtrans->pdls[3] = p_ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_xmin->state |= PDL_BADVAL;
  p_xmax->state |= PDL_BADVAL;
  p_ymin->state |= PDL_BADVAL;
  p_ymax->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_xmin_SV;
  ST(1) = p_xmax_SV;
  ST(2) = p_ymin_SV;
  ST(3) = p_ymax_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgxax(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_digmax_SV;
  SV *p_digits_SV;
  pdl  *p_digmax;
  pdl  *p_digits;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_digmax = PDL->SvPDLV(ST(0));
    p_digits = PDL->SvPDLV(ST(1));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_digmax_SV = sv_newmortal();
       p_digmax = PDL->null();
       PDL->SetSV_PDL(p_digmax_SV,p_digmax);
       if (bless_stash) p_digmax_SV = sv_bless(p_digmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_digmax_SV = POPs;
       PUTBACK;
       p_digmax = PDL->SvPDLV(p_digmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_digits_SV = sv_newmortal();
       p_digits = PDL->null();
       PDL->SetSV_PDL(p_digits_SV,p_digits);
       if (bless_stash) p_digits_SV = sv_bless(p_digits_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_digits_SV = POPs;
       PUTBACK;
       p_digits = PDL->SvPDLV(p_digits_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgxax(p_digmax,p_digits) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgxax_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgxax_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_digmax->state & PDL_NOMYDIMS) && p_digmax->trans == NULL ) {
	     p_digmax->datatype = PDL_L;
	  } else if(PDL_L != p_digmax->datatype) {
	     p_digmax = PDL->get_convertedpdl(p_digmax,PDL_L);
	  }if( (p_digits->state & PDL_NOMYDIMS) && p_digits->trans == NULL ) {
	     p_digits->datatype = PDL_L;
	  } else if(PDL_L != p_digits->datatype) {
	     p_digits = PDL->get_convertedpdl(p_digits,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_digmax;
__privtrans->pdls[1] = p_digits;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_digmax->state |= PDL_BADVAL;
  p_digits->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_digmax_SV;
  ST(1) = p_digits_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgyax(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_digmax_SV;
  SV *p_digits_SV;
  pdl  *p_digmax;
  pdl  *p_digits;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_digmax = PDL->SvPDLV(ST(0));
    p_digits = PDL->SvPDLV(ST(1));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_digmax_SV = sv_newmortal();
       p_digmax = PDL->null();
       PDL->SetSV_PDL(p_digmax_SV,p_digmax);
       if (bless_stash) p_digmax_SV = sv_bless(p_digmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_digmax_SV = POPs;
       PUTBACK;
       p_digmax = PDL->SvPDLV(p_digmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_digits_SV = sv_newmortal();
       p_digits = PDL->null();
       PDL->SetSV_PDL(p_digits_SV,p_digits);
       if (bless_stash) p_digits_SV = sv_bless(p_digits_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_digits_SV = POPs;
       PUTBACK;
       p_digits = PDL->SvPDLV(p_digits_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgyax(p_digmax,p_digits) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgyax_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgyax_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_digmax->state & PDL_NOMYDIMS) && p_digmax->trans == NULL ) {
	     p_digmax->datatype = PDL_L;
	  } else if(PDL_L != p_digmax->datatype) {
	     p_digmax = PDL->get_convertedpdl(p_digmax,PDL_L);
	  }if( (p_digits->state & PDL_NOMYDIMS) && p_digits->trans == NULL ) {
	     p_digits->datatype = PDL_L;
	  } else if(PDL_L != p_digits->datatype) {
	     p_digits = PDL->get_convertedpdl(p_digits,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_digmax;
__privtrans->pdls[1] = p_digits;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_digmax->state |= PDL_BADVAL;
  p_digits->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_digmax_SV;
  ST(1) = p_digits_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgzax(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_digmax_SV;
  SV *p_digits_SV;
  pdl  *p_digmax;
  pdl  *p_digits;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_digmax = PDL->SvPDLV(ST(0));
    p_digits = PDL->SvPDLV(ST(1));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_digmax_SV = sv_newmortal();
       p_digmax = PDL->null();
       PDL->SetSV_PDL(p_digmax_SV,p_digmax);
       if (bless_stash) p_digmax_SV = sv_bless(p_digmax_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_digmax_SV = POPs;
       PUTBACK;
       p_digmax = PDL->SvPDLV(p_digmax_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_digits_SV = sv_newmortal();
       p_digits = PDL->null();
       PDL->SetSV_PDL(p_digits_SV,p_digits);
       if (bless_stash) p_digits_SV = sv_bless(p_digits_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_digits_SV = POPs;
       PUTBACK;
       p_digits = PDL->SvPDLV(p_digits_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgzax(p_digmax,p_digits) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgzax_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgzax_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_digmax->state & PDL_NOMYDIMS) && p_digmax->trans == NULL ) {
	     p_digmax->datatype = PDL_L;
	  } else if(PDL_L != p_digmax->datatype) {
	     p_digmax = PDL->get_convertedpdl(p_digmax,PDL_L);
	  }if( (p_digits->state & PDL_NOMYDIMS) && p_digits->trans == NULL ) {
	     p_digits->datatype = PDL_L;
	  } else if(PDL_L != p_digits->datatype) {
	     p_digits = PDL->get_convertedpdl(p_digits,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_digmax;
__privtrans->pdls[1] = p_digits;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_digmax->state |= PDL_BADVAL;
  p_digits->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_digmax_SV;
  ST(1) = p_digits_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plinit()
CODE:
	c_plinit();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
pljoin(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xone;
  pdl  *yone;
  pdl  *xtwo;
  pdl  *ytwo;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xone = PDL->SvPDLV(ST(0));
    yone = PDL->SvPDLV(ST(1));
    xtwo = PDL->SvPDLV(ST(2));
    ytwo = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xone = PDL->SvPDLV(ST(0));
    yone = PDL->SvPDLV(ST(1));
    xtwo = PDL->SvPDLV(ST(2));
    ytwo = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::pljoin(xone,yone,xtwo,ytwo) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pljoin_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pljoin_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xone->state & PDL_BADVAL) > 0) || ((yone->state & PDL_BADVAL) > 0) || ((xtwo->state & PDL_BADVAL) > 0) || ((ytwo->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xone->datatype) {
	     xone = PDL->get_convertedpdl(xone,PDL_D);
	  }if(PDL_D != yone->datatype) {
	     yone = PDL->get_convertedpdl(yone,PDL_D);
	  }if(PDL_D != xtwo->datatype) {
	     xtwo = PDL->get_convertedpdl(xtwo,PDL_D);
	  }if(PDL_D != ytwo->datatype) {
	     ytwo = PDL->get_convertedpdl(ytwo,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xone;
__privtrans->pdls[1] = yone;
__privtrans->pdls[2] = xtwo;
__privtrans->pdls[3] = ytwo;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pllab(xlabel,ylabel,tlabel)
	char *	xlabel
	char *	ylabel
	char *	tlabel
CODE:
	c_pllab(xlabel,ylabel,tlabel);


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
pllightsource(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::pllightsource(x,y,z) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pllightsource_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pllightsource_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }if(PDL_D != z->datatype) {
	     z = PDL->get_convertedpdl(z,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
pllsty(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *lin;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    lin = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    lin = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::pllsty(lin) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pllsty_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pllsty_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((lin->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != lin->datatype) {
	     lin = PDL->get_convertedpdl(lin,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = lin;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plmtex_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *disp;
  pdl  *pos;
  pdl  *just;
  char  *side;
  char  *text;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    disp = PDL->SvPDLV(ST(0));
    pos = PDL->SvPDLV(ST(1));
    just = PDL->SvPDLV(ST(2));
    side = (char *)SvPV_nolen(ST(3))
;
    text = (char *)SvPV_nolen(ST(4))
;
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    disp = PDL->SvPDLV(ST(0));
    pos = PDL->SvPDLV(ST(1));
    just = PDL->SvPDLV(ST(2));
    side = (char *)SvPV_nolen(ST(3))
;
    text = (char *)SvPV_nolen(ST(4))
;
  }
  else {
    croak ("Usage:  PDL::plmtex_pp(disp,pos,just,side,text) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plmtex_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plmtex_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((disp->state & PDL_BADVAL) > 0) || ((pos->state & PDL_BADVAL) > 0) || ((just->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != disp->datatype) {
	     disp = PDL->get_convertedpdl(disp,PDL_D);
	  }if(PDL_D != pos->datatype) {
	     pos = PDL->get_convertedpdl(pos,PDL_D);
	  }if(PDL_D != just->datatype) {
	     just = PDL->get_convertedpdl(just,PDL_D);
	  }{(__privtrans->side) = malloc(strlen(side)+1); strcpy(__privtrans->side,side);(__privtrans->text) = malloc(strlen(text)+1); strcpy(__privtrans->text,text);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = disp;
__privtrans->pdls[1] = pos;
__privtrans->pdls[2] = just;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plmtex3_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *disp;
  pdl  *pos;
  pdl  *just;
  char  *side;
  char  *text;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    disp = PDL->SvPDLV(ST(0));
    pos = PDL->SvPDLV(ST(1));
    just = PDL->SvPDLV(ST(2));
    side = (char *)SvPV_nolen(ST(3))
;
    text = (char *)SvPV_nolen(ST(4))
;
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    disp = PDL->SvPDLV(ST(0));
    pos = PDL->SvPDLV(ST(1));
    just = PDL->SvPDLV(ST(2));
    side = (char *)SvPV_nolen(ST(3))
;
    text = (char *)SvPV_nolen(ST(4))
;
  }
  else {
    croak ("Usage:  PDL::plmtex3_pp(disp,pos,just,side,text) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plmtex3_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plmtex3_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((disp->state & PDL_BADVAL) > 0) || ((pos->state & PDL_BADVAL) > 0) || ((just->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != disp->datatype) {
	     disp = PDL->get_convertedpdl(disp,PDL_D);
	  }if(PDL_D != pos->datatype) {
	     pos = PDL->get_convertedpdl(pos,PDL_D);
	  }if(PDL_D != just->datatype) {
	     just = PDL->get_convertedpdl(just,PDL_D);
	  }{(__privtrans->side) = malloc(strlen(side)+1); strcpy(__privtrans->side,side);(__privtrans->text) = malloc(strlen(text)+1); strcpy(__privtrans->text,text);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = disp;
__privtrans->pdls[1] = pos;
__privtrans->pdls[2] = just;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plpat(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *nlin;
  pdl  *inc;
  pdl  *del;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nlin = PDL->SvPDLV(ST(0));
    inc = PDL->SvPDLV(ST(1));
    del = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    nlin = PDL->SvPDLV(ST(0));
    inc = PDL->SvPDLV(ST(1));
    del = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plpat(nlin,inc,del) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plpat_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plpat_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nlin->state & PDL_BADVAL) > 0) || ((inc->state & PDL_BADVAL) > 0) || ((del->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nlin->datatype) {
	     nlin = PDL->get_convertedpdl(nlin,PDL_L);
	  }if(PDL_L != inc->datatype) {
	     inc = PDL->get_convertedpdl(inc,PDL_L);
	  }if(PDL_L != del->datatype) {
	     del = PDL->get_convertedpdl(del,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nlin;
__privtrans->pdls[1] = inc;
__privtrans->pdls[2] = del;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plprec(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *setp;
  pdl  *prec;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    setp = PDL->SvPDLV(ST(0));
    prec = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    setp = PDL->SvPDLV(ST(0));
    prec = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plprec(setp,prec) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plprec_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plprec_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((setp->state & PDL_BADVAL) > 0) || ((prec->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != setp->datatype) {
	     setp = PDL->get_convertedpdl(setp,PDL_L);
	  }if(PDL_L != prec->datatype) {
	     prec = PDL->get_convertedpdl(prec,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = setp;
__privtrans->pdls[1] = prec;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plpsty(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *patt;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    patt = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    patt = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plpsty(patt) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plpsty_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plpsty_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((patt->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != patt->datatype) {
	     patt = PDL->get_convertedpdl(patt,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = patt;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plptex(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *dx;
  pdl  *dy;
  pdl  *just;
  char  *text;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    dx = PDL->SvPDLV(ST(2));
    dy = PDL->SvPDLV(ST(3));
    just = PDL->SvPDLV(ST(4));
    text = (char *)SvPV_nolen(ST(5))
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    dx = PDL->SvPDLV(ST(2));
    dy = PDL->SvPDLV(ST(3));
    just = PDL->SvPDLV(ST(4));
    text = (char *)SvPV_nolen(ST(5))
;
  }
  else {
    croak ("Usage:  PDL::plptex(x,y,dx,dy,just,text) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plptex_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plptex_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((dx->state & PDL_BADVAL) > 0) || ((dy->state & PDL_BADVAL) > 0) || ((just->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }if(PDL_D != dx->datatype) {
	     dx = PDL->get_convertedpdl(dx,PDL_D);
	  }if(PDL_D != dy->datatype) {
	     dy = PDL->get_convertedpdl(dy,PDL_D);
	  }if(PDL_D != just->datatype) {
	     just = PDL->get_convertedpdl(just,PDL_D);
	  }{(__privtrans->text) = malloc(strlen(text)+1); strcpy(__privtrans->text,text);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = dx;
__privtrans->pdls[3] = dy;
__privtrans->pdls[4] = just;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plptex3(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *dx;
  pdl  *dy;
  pdl  *dz;
  pdl  *sx;
  pdl  *sy;
  pdl  *sz;
  pdl  *just;
  char  *text;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 11) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    dx = PDL->SvPDLV(ST(3));
    dy = PDL->SvPDLV(ST(4));
    dz = PDL->SvPDLV(ST(5));
    sx = PDL->SvPDLV(ST(6));
    sy = PDL->SvPDLV(ST(7));
    sz = PDL->SvPDLV(ST(8));
    just = PDL->SvPDLV(ST(9));
    text = (char *)SvPV_nolen(ST(10))
;
  }
  else if (items == 11) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    dx = PDL->SvPDLV(ST(3));
    dy = PDL->SvPDLV(ST(4));
    dz = PDL->SvPDLV(ST(5));
    sx = PDL->SvPDLV(ST(6));
    sy = PDL->SvPDLV(ST(7));
    sz = PDL->SvPDLV(ST(8));
    just = PDL->SvPDLV(ST(9));
    text = (char *)SvPV_nolen(ST(10))
;
  }
  else {
    croak ("Usage:  PDL::plptex3(x,y,z,dx,dy,dz,sx,sy,sz,just,text) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plptex3_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plptex3_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((dx->state & PDL_BADVAL) > 0) || ((dy->state & PDL_BADVAL) > 0) || ((dz->state & PDL_BADVAL) > 0) || ((sx->state & PDL_BADVAL) > 0) || ((sy->state & PDL_BADVAL) > 0) || ((sz->state & PDL_BADVAL) > 0) || ((just->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }if(PDL_D != z->datatype) {
	     z = PDL->get_convertedpdl(z,PDL_D);
	  }if(PDL_D != dx->datatype) {
	     dx = PDL->get_convertedpdl(dx,PDL_D);
	  }if(PDL_D != dy->datatype) {
	     dy = PDL->get_convertedpdl(dy,PDL_D);
	  }if(PDL_D != dz->datatype) {
	     dz = PDL->get_convertedpdl(dz,PDL_D);
	  }if(PDL_D != sx->datatype) {
	     sx = PDL->get_convertedpdl(sx,PDL_D);
	  }if(PDL_D != sy->datatype) {
	     sy = PDL->get_convertedpdl(sy,PDL_D);
	  }if(PDL_D != sz->datatype) {
	     sz = PDL->get_convertedpdl(sz,PDL_D);
	  }if(PDL_D != just->datatype) {
	     just = PDL->get_convertedpdl(just,PDL_D);
	  }{(__privtrans->text) = malloc(strlen(text)+1); strcpy(__privtrans->text,text);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = dx;
__privtrans->pdls[4] = dy;
__privtrans->pdls[5] = dz;
__privtrans->pdls[6] = sx;
__privtrans->pdls[7] = sy;
__privtrans->pdls[8] = sz;
__privtrans->pdls[9] = just;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plreplot()
CODE:
	c_plreplot();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plschr(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *def;
  pdl  *scale;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plschr(def,scale) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plschr_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plschr_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((def->state & PDL_BADVAL) > 0) || ((scale->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != def->datatype) {
	     def = PDL->get_convertedpdl(def,PDL_D);
	  }if(PDL_D != scale->datatype) {
	     scale = PDL->get_convertedpdl(scale,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = def;
__privtrans->pdls[1] = scale;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap0n(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *ncolzero;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    ncolzero = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    ncolzero = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plscmap0n(ncolzero) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap0n_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap0n_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ncolzero->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != ncolzero->datatype) {
	     ncolzero = PDL->get_convertedpdl(ncolzero,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ncolzero;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap1n(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *ncolone;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    ncolone = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    ncolone = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plscmap1n(ncolone) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap1n_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap1n_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ncolone->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != ncolone->datatype) {
	     ncolone = PDL->get_convertedpdl(ncolone,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ncolone;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscol0(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *icolzero;
  pdl  *r;
  pdl  *g;
  pdl  *b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
    r = PDL->SvPDLV(ST(1));
    g = PDL->SvPDLV(ST(2));
    b = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
    r = PDL->SvPDLV(ST(1));
    g = PDL->SvPDLV(ST(2));
    b = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plscol0(icolzero,r,g,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscol0_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscol0_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((icolzero->state & PDL_BADVAL) > 0) || ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != icolzero->datatype) {
	     icolzero = PDL->get_convertedpdl(icolzero,PDL_L);
	  }if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = icolzero;
__privtrans->pdls[1] = r;
__privtrans->pdls[2] = g;
__privtrans->pdls[3] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscolbg(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *r;
  pdl  *g;
  pdl  *b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plscolbg(r,g,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscolbg_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscolbg_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscolor(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *color;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    color = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    color = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plscolor(color) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscolor_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscolor_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((color->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != color->datatype) {
	     color = PDL->get_convertedpdl(color,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = color;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscompression(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *compression;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    compression = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    compression = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plscompression(compression) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscompression_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscompression_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((compression->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != compression->datatype) {
	     compression = PDL->get_convertedpdl(compression,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = compression;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plsdev(devname)
	char *	devname
CODE:
	c_plsdev(devname);


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plsdidev(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *mar;
  pdl  *aspect;
  pdl  *jx;
  pdl  *jy;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    mar = PDL->SvPDLV(ST(0));
    aspect = PDL->SvPDLV(ST(1));
    jx = PDL->SvPDLV(ST(2));
    jy = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    mar = PDL->SvPDLV(ST(0));
    aspect = PDL->SvPDLV(ST(1));
    jx = PDL->SvPDLV(ST(2));
    jy = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plsdidev(mar,aspect,jx,jy) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsdidev_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsdidev_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((mar->state & PDL_BADVAL) > 0) || ((aspect->state & PDL_BADVAL) > 0) || ((jx->state & PDL_BADVAL) > 0) || ((jy->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != mar->datatype) {
	     mar = PDL->get_convertedpdl(mar,PDL_D);
	  }if(PDL_D != aspect->datatype) {
	     aspect = PDL->get_convertedpdl(aspect,PDL_D);
	  }if(PDL_D != jx->datatype) {
	     jx = PDL->get_convertedpdl(jx,PDL_D);
	  }if(PDL_D != jy->datatype) {
	     jy = PDL->get_convertedpdl(jy,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = mar;
__privtrans->pdls[1] = aspect;
__privtrans->pdls[2] = jx;
__privtrans->pdls[3] = jy;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsdimap(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *dimxmin;
  pdl  *dimxmax;
  pdl  *dimymin;
  pdl  *dimymax;
  pdl  *dimxpmm;
  pdl  *dimypmm;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    dimxmin = PDL->SvPDLV(ST(0));
    dimxmax = PDL->SvPDLV(ST(1));
    dimymin = PDL->SvPDLV(ST(2));
    dimymax = PDL->SvPDLV(ST(3));
    dimxpmm = PDL->SvPDLV(ST(4));
    dimypmm = PDL->SvPDLV(ST(5));
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    dimxmin = PDL->SvPDLV(ST(0));
    dimxmax = PDL->SvPDLV(ST(1));
    dimymin = PDL->SvPDLV(ST(2));
    dimymax = PDL->SvPDLV(ST(3));
    dimxpmm = PDL->SvPDLV(ST(4));
    dimypmm = PDL->SvPDLV(ST(5));
  }
  else {
    croak ("Usage:  PDL::plsdimap(dimxmin,dimxmax,dimymin,dimymax,dimxpmm,dimypmm) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsdimap_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsdimap_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((dimxmin->state & PDL_BADVAL) > 0) || ((dimxmax->state & PDL_BADVAL) > 0) || ((dimymin->state & PDL_BADVAL) > 0) || ((dimymax->state & PDL_BADVAL) > 0) || ((dimxpmm->state & PDL_BADVAL) > 0) || ((dimypmm->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != dimxmin->datatype) {
	     dimxmin = PDL->get_convertedpdl(dimxmin,PDL_L);
	  }if(PDL_L != dimxmax->datatype) {
	     dimxmax = PDL->get_convertedpdl(dimxmax,PDL_L);
	  }if(PDL_L != dimymin->datatype) {
	     dimymin = PDL->get_convertedpdl(dimymin,PDL_L);
	  }if(PDL_L != dimymax->datatype) {
	     dimymax = PDL->get_convertedpdl(dimymax,PDL_L);
	  }if(PDL_D != dimxpmm->datatype) {
	     dimxpmm = PDL->get_convertedpdl(dimxpmm,PDL_D);
	  }if(PDL_D != dimypmm->datatype) {
	     dimypmm = PDL->get_convertedpdl(dimypmm,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = dimxmin;
__privtrans->pdls[1] = dimxmax;
__privtrans->pdls[2] = dimymin;
__privtrans->pdls[3] = dimymax;
__privtrans->pdls[4] = dimxpmm;
__privtrans->pdls[5] = dimypmm;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsdiori(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *rot;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    rot = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    rot = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plsdiori(rot) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsdiori_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsdiori_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((rot->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != rot->datatype) {
	     rot = PDL->get_convertedpdl(rot,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = rot;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsdiplt(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *ymin;
  pdl  *xmax;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plsdiplt(xmin,ymin,xmax,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsdiplt_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsdiplt_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = ymin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsdiplz(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *ymin;
  pdl  *xmax;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    ymin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plsdiplz(xmin,ymin,xmax,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsdiplz_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsdiplz_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = ymin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
pl_setcontlabelparam(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *offset;
  pdl  *size;
  pdl  *spacing;
  pdl  *active;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    offset = PDL->SvPDLV(ST(0));
    size = PDL->SvPDLV(ST(1));
    spacing = PDL->SvPDLV(ST(2));
    active = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    offset = PDL->SvPDLV(ST(0));
    size = PDL->SvPDLV(ST(1));
    spacing = PDL->SvPDLV(ST(2));
    active = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::pl_setcontlabelparam(offset,size,spacing,active) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pl_setcontlabelparam_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pl_setcontlabelparam_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((offset->state & PDL_BADVAL) > 0) || ((size->state & PDL_BADVAL) > 0) || ((spacing->state & PDL_BADVAL) > 0) || ((active->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != offset->datatype) {
	     offset = PDL->get_convertedpdl(offset,PDL_D);
	  }if(PDL_D != size->datatype) {
	     size = PDL->get_convertedpdl(size,PDL_D);
	  }if(PDL_D != spacing->datatype) {
	     spacing = PDL->get_convertedpdl(spacing,PDL_D);
	  }if(PDL_L != active->datatype) {
	     active = PDL->get_convertedpdl(active,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = offset;
__privtrans->pdls[1] = size;
__privtrans->pdls[2] = spacing;
__privtrans->pdls[3] = active;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
pl_setcontlabelformat(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *lexp;
  pdl  *sigdig;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    lexp = PDL->SvPDLV(ST(0));
    sigdig = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    lexp = PDL->SvPDLV(ST(0));
    sigdig = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::pl_setcontlabelformat(lexp,sigdig) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pl_setcontlabelformat_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pl_setcontlabelformat_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((lexp->state & PDL_BADVAL) > 0) || ((sigdig->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != lexp->datatype) {
	     lexp = PDL->get_convertedpdl(lexp,PDL_L);
	  }if(PDL_L != sigdig->datatype) {
	     sigdig = PDL->get_convertedpdl(sigdig,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = lexp;
__privtrans->pdls[1] = sigdig;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsfam(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *fam;
  pdl  *num;
  pdl  *bmax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    fam = PDL->SvPDLV(ST(0));
    num = PDL->SvPDLV(ST(1));
    bmax = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    fam = PDL->SvPDLV(ST(0));
    num = PDL->SvPDLV(ST(1));
    bmax = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plsfam(fam,num,bmax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsfam_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsfam_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((fam->state & PDL_BADVAL) > 0) || ((num->state & PDL_BADVAL) > 0) || ((bmax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != fam->datatype) {
	     fam = PDL->get_convertedpdl(fam,PDL_L);
	  }if(PDL_L != num->datatype) {
	     num = PDL->get_convertedpdl(num,PDL_L);
	  }if(PDL_L != bmax->datatype) {
	     bmax = PDL->get_convertedpdl(bmax,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = fam;
__privtrans->pdls[1] = num;
__privtrans->pdls[2] = bmax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plsfnam(fnam)
	char *	fnam
CODE:
	c_plsfnam(fnam);


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plsmaj(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *def;
  pdl  *scale;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plsmaj(def,scale) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsmaj_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsmaj_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((def->state & PDL_BADVAL) > 0) || ((scale->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != def->datatype) {
	     def = PDL->get_convertedpdl(def,PDL_D);
	  }if(PDL_D != scale->datatype) {
	     scale = PDL->get_convertedpdl(scale,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = def;
__privtrans->pdls[1] = scale;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsmin(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *def;
  pdl  *scale;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plsmin(def,scale) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsmin_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsmin_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((def->state & PDL_BADVAL) > 0) || ((scale->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != def->datatype) {
	     def = PDL->get_convertedpdl(def,PDL_D);
	  }if(PDL_D != scale->datatype) {
	     scale = PDL->get_convertedpdl(scale,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = def;
__privtrans->pdls[1] = scale;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsori(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *ori;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    ori = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    ori = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plsori(ori) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsori_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsori_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ori->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != ori->datatype) {
	     ori = PDL->get_convertedpdl(ori,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ori;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plspage(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xp;
  pdl  *yp;
  pdl  *xleng;
  pdl  *yleng;
  pdl  *xoff;
  pdl  *yoff;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xp = PDL->SvPDLV(ST(0));
    yp = PDL->SvPDLV(ST(1));
    xleng = PDL->SvPDLV(ST(2));
    yleng = PDL->SvPDLV(ST(3));
    xoff = PDL->SvPDLV(ST(4));
    yoff = PDL->SvPDLV(ST(5));
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xp = PDL->SvPDLV(ST(0));
    yp = PDL->SvPDLV(ST(1));
    xleng = PDL->SvPDLV(ST(2));
    yleng = PDL->SvPDLV(ST(3));
    xoff = PDL->SvPDLV(ST(4));
    yoff = PDL->SvPDLV(ST(5));
  }
  else {
    croak ("Usage:  PDL::plspage(xp,yp,xleng,yleng,xoff,yoff) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plspage_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plspage_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xp->state & PDL_BADVAL) > 0) || ((yp->state & PDL_BADVAL) > 0) || ((xleng->state & PDL_BADVAL) > 0) || ((yleng->state & PDL_BADVAL) > 0) || ((xoff->state & PDL_BADVAL) > 0) || ((yoff->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xp->datatype) {
	     xp = PDL->get_convertedpdl(xp,PDL_D);
	  }if(PDL_D != yp->datatype) {
	     yp = PDL->get_convertedpdl(yp,PDL_D);
	  }if(PDL_L != xleng->datatype) {
	     xleng = PDL->get_convertedpdl(xleng,PDL_L);
	  }if(PDL_L != yleng->datatype) {
	     yleng = PDL->get_convertedpdl(yleng,PDL_L);
	  }if(PDL_L != xoff->datatype) {
	     xoff = PDL->get_convertedpdl(xoff,PDL_L);
	  }if(PDL_L != yoff->datatype) {
	     yoff = PDL->get_convertedpdl(yoff,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xp;
__privtrans->pdls[1] = yp;
__privtrans->pdls[2] = xleng;
__privtrans->pdls[3] = yleng;
__privtrans->pdls[4] = xoff;
__privtrans->pdls[5] = yoff;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plspause(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *pause;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    pause = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    pause = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plspause(pause) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plspause_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plspause_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((pause->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != pause->datatype) {
	     pause = PDL->get_convertedpdl(pause,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = pause;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsstrm(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *strm;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    strm = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    strm = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plsstrm(strm) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsstrm_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsstrm_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((strm->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != strm->datatype) {
	     strm = PDL->get_convertedpdl(strm,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = strm;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plssub(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *nx;
  pdl  *ny;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nx = PDL->SvPDLV(ST(0));
    ny = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    nx = PDL->SvPDLV(ST(0));
    ny = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plssub(nx,ny) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plssub_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plssub_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nx->state & PDL_BADVAL) > 0) || ((ny->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nx->datatype) {
	     nx = PDL->get_convertedpdl(nx,PDL_L);
	  }if(PDL_L != ny->datatype) {
	     ny = PDL->get_convertedpdl(ny,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nx;
__privtrans->pdls[1] = ny;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plssym(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *def;
  pdl  *scale;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    def = PDL->SvPDLV(ST(0));
    scale = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plssym(def,scale) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plssym_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plssym_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((def->state & PDL_BADVAL) > 0) || ((scale->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != def->datatype) {
	     def = PDL->get_convertedpdl(def,PDL_D);
	  }if(PDL_D != scale->datatype) {
	     scale = PDL->get_convertedpdl(scale,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = def;
__privtrans->pdls[1] = scale;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstar(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *nx;
  pdl  *ny;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nx = PDL->SvPDLV(ST(0));
    ny = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    nx = PDL->SvPDLV(ST(0));
    ny = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plstar(nx,ny) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstar_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstar_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nx->state & PDL_BADVAL) > 0) || ((ny->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nx->datatype) {
	     nx = PDL->get_convertedpdl(nx,PDL_L);
	  }if(PDL_L != ny->datatype) {
	     ny = PDL->get_convertedpdl(ny,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nx;
__privtrans->pdls[1] = ny;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstart_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *nx;
  pdl  *ny;
  char  *devname;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nx = PDL->SvPDLV(ST(0));
    ny = PDL->SvPDLV(ST(1));
    devname = (char *)SvPV_nolen(ST(2))
;
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    nx = PDL->SvPDLV(ST(0));
    ny = PDL->SvPDLV(ST(1));
    devname = (char *)SvPV_nolen(ST(2))
;
  }
  else {
    croak ("Usage:  PDL::plstart_pp(nx,ny,devname) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstart_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstart_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nx->state & PDL_BADVAL) > 0) || ((ny->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nx->datatype) {
	     nx = PDL->get_convertedpdl(nx,PDL_L);
	  }if(PDL_L != ny->datatype) {
	     ny = PDL->get_convertedpdl(ny,PDL_L);
	  }{(__privtrans->devname) = malloc(strlen(devname)+1); strcpy(__privtrans->devname,devname);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nx;
__privtrans->pdls[1] = ny;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstripa(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *id;
  pdl  *pen;
  pdl  *x;
  pdl  *y;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    id = PDL->SvPDLV(ST(0));
    pen = PDL->SvPDLV(ST(1));
    x = PDL->SvPDLV(ST(2));
    y = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    id = PDL->SvPDLV(ST(0));
    pen = PDL->SvPDLV(ST(1));
    x = PDL->SvPDLV(ST(2));
    y = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plstripa(id,pen,x,y) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstripa_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstripa_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((id->state & PDL_BADVAL) > 0) || ((pen->state & PDL_BADVAL) > 0) || ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != id->datatype) {
	     id = PDL->get_convertedpdl(id,PDL_L);
	  }if(PDL_L != pen->datatype) {
	     pen = PDL->get_convertedpdl(pen,PDL_L);
	  }if(PDL_D != x->datatype) {
	     x = PDL->get_convertedpdl(x,PDL_D);
	  }if(PDL_D != y->datatype) {
	     y = PDL->get_convertedpdl(y,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = id;
__privtrans->pdls[1] = pen;
__privtrans->pdls[2] = x;
__privtrans->pdls[3] = y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstripd(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *id;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    id = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    id = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plstripd(id) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstripd_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstripd_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((id->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != id->datatype) {
	     id = PDL->get_convertedpdl(id,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = id;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsvpa(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plsvpa(xmin,xmax,ymin,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsvpa_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsvpa_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsxax(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *digmax;
  pdl  *digits;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    digmax = PDL->SvPDLV(ST(0));
    digits = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    digmax = PDL->SvPDLV(ST(0));
    digits = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plsxax(digmax,digits) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsxax_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsxax_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((digmax->state & PDL_BADVAL) > 0) || ((digits->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != digmax->datatype) {
	     digmax = PDL->get_convertedpdl(digmax,PDL_L);
	  }if(PDL_L != digits->datatype) {
	     digits = PDL->get_convertedpdl(digits,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = digmax;
__privtrans->pdls[1] = digits;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsxwin(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *window_id;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    window_id = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    window_id = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plsxwin(window_id) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsxwin_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsxwin_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((window_id->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != window_id->datatype) {
	     window_id = PDL->get_convertedpdl(window_id,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = window_id;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsyax(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *digmax;
  pdl  *digits;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    digmax = PDL->SvPDLV(ST(0));
    digits = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    digmax = PDL->SvPDLV(ST(0));
    digits = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plsyax(digmax,digits) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsyax_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsyax_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((digmax->state & PDL_BADVAL) > 0) || ((digits->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != digmax->datatype) {
	     digmax = PDL->get_convertedpdl(digmax,PDL_L);
	  }if(PDL_L != digits->datatype) {
	     digits = PDL->get_convertedpdl(digits,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = digmax;
__privtrans->pdls[1] = digits;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plszax(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *digmax;
  pdl  *digits;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    digmax = PDL->SvPDLV(ST(0));
    digits = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    digmax = PDL->SvPDLV(ST(0));
    digits = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plszax(digmax,digits) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plszax_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plszax_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((digmax->state & PDL_BADVAL) > 0) || ((digits->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != digmax->datatype) {
	     digmax = PDL->get_convertedpdl(digmax,PDL_L);
	  }if(PDL_L != digits->datatype) {
	     digits = PDL->get_convertedpdl(digits,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = digmax;
__privtrans->pdls[1] = digits;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pltext()
CODE:
	c_pltext();


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plvasp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *aspect;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    aspect = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    aspect = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plvasp(aspect) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plvasp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plvasp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((aspect->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != aspect->datatype) {
	     aspect = PDL->get_convertedpdl(aspect,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = aspect;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plvpas(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *aspect;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
    aspect = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
    aspect = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plvpas(xmin,xmax,ymin,ymax,aspect) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plvpas_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plvpas_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((aspect->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }if(PDL_D != aspect->datatype) {
	     aspect = PDL->get_convertedpdl(aspect,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
__privtrans->pdls[4] = aspect;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plvpor(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plvpor(xmin,xmax,ymin,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plvpor_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plvpor_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plvsta()
CODE:
	c_plvsta();

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plw3d(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *basex;
  pdl  *basey;
  pdl  *height;
  pdl  *xminzero;
  pdl  *xmaxzero;
  pdl  *yminzero;
  pdl  *ymaxzero;
  pdl  *zminzero;
  pdl  *zmaxzero;
  pdl  *alt;
  pdl  *az;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 11) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    basex = PDL->SvPDLV(ST(0));
    basey = PDL->SvPDLV(ST(1));
    height = PDL->SvPDLV(ST(2));
    xminzero = PDL->SvPDLV(ST(3));
    xmaxzero = PDL->SvPDLV(ST(4));
    yminzero = PDL->SvPDLV(ST(5));
    ymaxzero = PDL->SvPDLV(ST(6));
    zminzero = PDL->SvPDLV(ST(7));
    zmaxzero = PDL->SvPDLV(ST(8));
    alt = PDL->SvPDLV(ST(9));
    az = PDL->SvPDLV(ST(10));
  }
  else if (items == 11) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    basex = PDL->SvPDLV(ST(0));
    basey = PDL->SvPDLV(ST(1));
    height = PDL->SvPDLV(ST(2));
    xminzero = PDL->SvPDLV(ST(3));
    xmaxzero = PDL->SvPDLV(ST(4));
    yminzero = PDL->SvPDLV(ST(5));
    ymaxzero = PDL->SvPDLV(ST(6));
    zminzero = PDL->SvPDLV(ST(7));
    zmaxzero = PDL->SvPDLV(ST(8));
    alt = PDL->SvPDLV(ST(9));
    az = PDL->SvPDLV(ST(10));
  }
  else {
    croak ("Usage:  PDL::plw3d(basex,basey,height,xminzero,xmaxzero,yminzero,ymaxzero,zminzero,zmaxzero,alt,az) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plw3d_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plw3d_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((basex->state & PDL_BADVAL) > 0) || ((basey->state & PDL_BADVAL) > 0) || ((height->state & PDL_BADVAL) > 0) || ((xminzero->state & PDL_BADVAL) > 0) || ((xmaxzero->state & PDL_BADVAL) > 0) || ((yminzero->state & PDL_BADVAL) > 0) || ((ymaxzero->state & PDL_BADVAL) > 0) || ((zminzero->state & PDL_BADVAL) > 0) || ((zmaxzero->state & PDL_BADVAL) > 0) || ((alt->state & PDL_BADVAL) > 0) || ((az->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != basex->datatype) {
	     basex = PDL->get_convertedpdl(basex,PDL_D);
	  }if(PDL_D != basey->datatype) {
	     basey = PDL->get_convertedpdl(basey,PDL_D);
	  }if(PDL_D != height->datatype) {
	     height = PDL->get_convertedpdl(height,PDL_D);
	  }if(PDL_D != xminzero->datatype) {
	     xminzero = PDL->get_convertedpdl(xminzero,PDL_D);
	  }if(PDL_D != xmaxzero->datatype) {
	     xmaxzero = PDL->get_convertedpdl(xmaxzero,PDL_D);
	  }if(PDL_D != yminzero->datatype) {
	     yminzero = PDL->get_convertedpdl(yminzero,PDL_D);
	  }if(PDL_D != ymaxzero->datatype) {
	     ymaxzero = PDL->get_convertedpdl(ymaxzero,PDL_D);
	  }if(PDL_D != zminzero->datatype) {
	     zminzero = PDL->get_convertedpdl(zminzero,PDL_D);
	  }if(PDL_D != zmaxzero->datatype) {
	     zmaxzero = PDL->get_convertedpdl(zmaxzero,PDL_D);
	  }if(PDL_D != alt->datatype) {
	     alt = PDL->get_convertedpdl(alt,PDL_D);
	  }if(PDL_D != az->datatype) {
	     az = PDL->get_convertedpdl(az,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = basex;
__privtrans->pdls[1] = basey;
__privtrans->pdls[2] = height;
__privtrans->pdls[3] = xminzero;
__privtrans->pdls[4] = xmaxzero;
__privtrans->pdls[5] = yminzero;
__privtrans->pdls[6] = ymaxzero;
__privtrans->pdls[7] = zminzero;
__privtrans->pdls[8] = zmaxzero;
__privtrans->pdls[9] = alt;
__privtrans->pdls[10] = az;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plwid(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *width;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    width = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    width = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plwid(width) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plwid_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plwid_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((width->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != width->datatype) {
	     width = PDL->get_convertedpdl(width,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = width;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plwind(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    ymin = PDL->SvPDLV(ST(2));
    ymax = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plwind(xmin,xmax,ymin,ymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plwind_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plwind_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,PDL_D);
	  }if(PDL_D != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,PDL_D);
	  }if(PDL_D != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,PDL_D);
	  }if(PDL_D != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = ymin;
__privtrans->pdls[3] = ymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plsetopt(opt,optarg)
	char *	opt
	char *	optarg
CODE:
	c_plsetopt(opt,optarg);


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plP_gpixmm(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *p_x;
  pdl  *p_y;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_x = PDL->SvPDLV(ST(0));
    p_y = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    p_x = PDL->SvPDLV(ST(0));
    p_y = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plP_gpixmm(p_x,p_y) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plP_gpixmm_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plP_gpixmm_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((p_x->state & PDL_BADVAL) > 0) || ((p_y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != p_x->datatype) {
	     p_x = PDL->get_convertedpdl(p_x,PDL_D);
	  }if(PDL_D != p_y->datatype) {
	     p_y = PDL->get_convertedpdl(p_y,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_x;
__privtrans->pdls[1] = p_y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscolbga(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *r;
  pdl  *g;
  pdl  *b;
  pdl  *a;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plscolbga(r,g,b,a) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscolbga_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscolbga_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0) || ((a->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
__privtrans->pdls[3] = a;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscol0a(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *icolzero;
  pdl  *r;
  pdl  *g;
  pdl  *b;
  pdl  *a;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
    r = PDL->SvPDLV(ST(1));
    g = PDL->SvPDLV(ST(2));
    b = PDL->SvPDLV(ST(3));
    a = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
    r = PDL->SvPDLV(ST(1));
    g = PDL->SvPDLV(ST(2));
    b = PDL->SvPDLV(ST(3));
    a = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plscol0a(icolzero,r,g,b,a) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscol0a_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscol0a_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((icolzero->state & PDL_BADVAL) > 0) || ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0) || ((a->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != icolzero->datatype) {
	     icolzero = PDL->get_convertedpdl(icolzero,PDL_L);
	  }if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = icolzero;
__privtrans->pdls[1] = r;
__privtrans->pdls[2] = g;
__privtrans->pdls[3] = b;
__privtrans->pdls[4] = a;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plline(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plline(x,y) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plline_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plline_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plcolorpoints(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *sym;
  pdl  *minz;
  pdl  *maxz;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    sym = PDL->SvPDLV(ST(3));
    minz = PDL->SvPDLV(ST(4));
    maxz = PDL->SvPDLV(ST(5));
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    sym = PDL->SvPDLV(ST(3));
    minz = PDL->SvPDLV(ST(4));
    maxz = PDL->SvPDLV(ST(5));
  }
  else {
    croak ("Usage:  PDL::plcolorpoints(x,y,z,sym,minz,maxz) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plcolorpoints_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plcolorpoints_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((sym->state & PDL_BADVAL) > 0) || ((minz->state & PDL_BADVAL) > 0) || ((maxz->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype < minz->datatype) {
		 	__privtrans->__datatype = minz->datatype;
		    }
if(__privtrans->__datatype < maxz->datatype) {
		 	__privtrans->__datatype = maxz->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != sym->datatype) {
	     sym = PDL->get_convertedpdl(sym,PDL_L);
	  }if(__privtrans->__datatype != minz->datatype) {
	     minz = PDL->get_convertedpdl(minz,__privtrans->__datatype);
	  }if(__privtrans->__datatype != maxz->datatype) {
	     maxz = PDL->get_convertedpdl(maxz,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = sym;
__privtrans->pdls[4] = minz;
__privtrans->pdls[5] = maxz;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsmem(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *maxx;
  pdl  *maxy;
  pdl  *image;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    maxx = PDL->SvPDLV(ST(0));
    maxy = PDL->SvPDLV(ST(1));
    image = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    maxx = PDL->SvPDLV(ST(0));
    maxy = PDL->SvPDLV(ST(1));
    image = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plsmem(maxx,maxy,image) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsmem_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsmem_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((maxx->state & PDL_BADVAL) > 0) || ((maxy->state & PDL_BADVAL) > 0) || ((image->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < image->datatype) {
		 	__privtrans->__datatype = image->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else __privtrans->__datatype = PDL_B;
if(PDL_L != maxx->datatype) {
	     maxx = PDL->get_convertedpdl(maxx,PDL_L);
	  }if(PDL_L != maxy->datatype) {
	     maxy = PDL->get_convertedpdl(maxy,PDL_L);
	  }if(__privtrans->__datatype != image->datatype) {
	     image = PDL->get_convertedpdl(image,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = maxx;
__privtrans->pdls[1] = maxy;
__privtrans->pdls[2] = image;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plfbox(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xo;
  pdl  *yo;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xo = PDL->SvPDLV(ST(0));
    yo = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xo = PDL->SvPDLV(ST(0));
    yo = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plfbox(xo,yo) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plfbox_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plfbox_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xo->state & PDL_BADVAL) > 0) || ((yo->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xo->datatype) {
		 	__privtrans->__datatype = xo->datatype;
		    }
if(__privtrans->__datatype < yo->datatype) {
		 	__privtrans->__datatype = yo->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xo->datatype) {
	     xo = PDL->get_convertedpdl(xo,__privtrans->__datatype);
	  }if(__privtrans->__datatype != yo->datatype) {
	     yo = PDL->get_convertedpdl(yo,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xo;
__privtrans->pdls[1] = yo;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plunfbox(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *xo;
  pdl  *yo;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xo = PDL->SvPDLV(ST(0));
    yo = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    xo = PDL->SvPDLV(ST(0));
    yo = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plunfbox(xo,yo) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plunfbox_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plunfbox_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xo->state & PDL_BADVAL) > 0) || ((yo->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xo->datatype) {
		 	__privtrans->__datatype = xo->datatype;
		    }
if(__privtrans->__datatype < yo->datatype) {
		 	__privtrans->__datatype = yo->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xo->datatype) {
	     xo = PDL->get_convertedpdl(xo,__privtrans->__datatype);
	  }if(__privtrans->__datatype != yo->datatype) {
	     yo = PDL->get_convertedpdl(yo,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xo;
__privtrans->pdls[1] = yo;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plParseOpts(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *retval_SV;
  pdl  *retval;
  SV *argv;
  int  mode;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    retval = PDL->SvPDLV(ST(0));
    argv = ST(1)
;
    mode = (int)SvIV(ST(2))
;
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    argv = ST(0)
;
    mode = (int)SvIV(ST(1))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       retval_SV = sv_newmortal();
       retval = PDL->null();
       PDL->SetSV_PDL(retval_SV,retval);
       if (bless_stash) retval_SV = sv_bless(retval_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       retval_SV = POPs;
       PUTBACK;
       retval = PDL->SvPDLV(retval_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plParseOpts(retval,argv,mode) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plParseOpts_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plParseOpts_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (retval->state & PDL_NOMYDIMS) && retval->trans == NULL ) {
	     retval->datatype = PDL_L;
	  } else if(PDL_L != retval->datatype) {
	     retval = PDL->get_convertedpdl(retval,PDL_L);
	  }{(__privtrans->argv) = newSVsv(argv);(__privtrans->mode) = (mode);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = retval;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  retval->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = retval_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plpoin(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *code;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    code = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    code = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plpoin(x,y,code) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plpoin_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plpoin_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((code->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(PDL_L != code->datatype) {
	     code = PDL->get_convertedpdl(code,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = code;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plpoin3(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *code;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    code = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    code = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plpoin3(x,y,z,code) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plpoin3_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plpoin3_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((code->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != code->datatype) {
	     code = PDL->get_convertedpdl(code,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = code;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plline3(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plline3(x,y,z) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plline3_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plline3_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plpoly3(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *draw;
  pdl  *ifcc;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    draw = PDL->SvPDLV(ST(3));
    ifcc = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    draw = PDL->SvPDLV(ST(3));
    ifcc = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plpoly3(x,y,z,draw,ifcc) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plpoly3_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plpoly3_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((draw->state & PDL_BADVAL) > 0) || ((ifcc->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != draw->datatype) {
	     draw = PDL->get_convertedpdl(draw,PDL_L);
	  }if(PDL_L != ifcc->datatype) {
	     ifcc = PDL->get_convertedpdl(ifcc,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = draw;
__privtrans->pdls[4] = ifcc;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plhist(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *data;
  pdl  *datmin;
  pdl  *datmax;
  pdl  *nbin;
  pdl  *oldwin;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    datmin = PDL->SvPDLV(ST(1));
    datmax = PDL->SvPDLV(ST(2));
    nbin = PDL->SvPDLV(ST(3));
    oldwin = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    datmin = PDL->SvPDLV(ST(1));
    datmax = PDL->SvPDLV(ST(2));
    nbin = PDL->SvPDLV(ST(3));
    oldwin = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plhist(data,datmin,datmax,nbin,oldwin) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plhist_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plhist_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((datmin->state & PDL_BADVAL) > 0) || ((datmax->state & PDL_BADVAL) > 0) || ((nbin->state & PDL_BADVAL) > 0) || ((oldwin->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < data->datatype) {
		 	__privtrans->__datatype = data->datatype;
		    }
if(__privtrans->__datatype < datmin->datatype) {
		 	__privtrans->__datatype = datmin->datatype;
		    }
if(__privtrans->__datatype < datmax->datatype) {
		 	__privtrans->__datatype = datmax->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != data->datatype) {
	     data = PDL->get_convertedpdl(data,__privtrans->__datatype);
	  }if(__privtrans->__datatype != datmin->datatype) {
	     datmin = PDL->get_convertedpdl(datmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != datmax->datatype) {
	     datmax = PDL->get_convertedpdl(datmax,__privtrans->__datatype);
	  }if(PDL_L != nbin->datatype) {
	     nbin = PDL->get_convertedpdl(nbin,PDL_L);
	  }if(PDL_L != oldwin->datatype) {
	     oldwin = PDL->get_convertedpdl(oldwin,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = datmin;
__privtrans->pdls[2] = datmax;
__privtrans->pdls[3] = nbin;
__privtrans->pdls[4] = oldwin;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plfill(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plfill(x,y) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plfill_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plfill_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgradient(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *angle;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    angle = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    angle = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plgradient(x,y,angle) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgradient_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgradient_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((angle->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < angle->datatype) {
		 	__privtrans->__datatype = angle->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != angle->datatype) {
	     angle = PDL->get_convertedpdl(angle,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = angle;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsym(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *code;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    code = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    code = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plsym(x,y,code) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsym_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsym_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((code->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(PDL_L != code->datatype) {
	     code = PDL->get_convertedpdl(code,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = code;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsurf3d(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *opt;
  pdl  *clevel;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    clevel = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    clevel = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plsurf3d(x,y,z,opt,clevel) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsurf3d_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsurf3d_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((opt->state & PDL_BADVAL) > 0) || ((clevel->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype < clevel->datatype) {
		 	__privtrans->__datatype = clevel->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != opt->datatype) {
	     opt = PDL->get_convertedpdl(opt,PDL_L);
	  }if(__privtrans->__datatype != clevel->datatype) {
	     clevel = PDL->get_convertedpdl(clevel,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = opt;
__privtrans->pdls[4] = clevel;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstyl(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *mark;
  pdl  *space;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    mark = PDL->SvPDLV(ST(0));
    space = PDL->SvPDLV(ST(1));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    mark = PDL->SvPDLV(ST(0));
    space = PDL->SvPDLV(ST(1));
  }
  else {
    croak ("Usage:  PDL::plstyl(mark,space) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstyl_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstyl_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((mark->state & PDL_BADVAL) > 0) || ((space->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != mark->datatype) {
	     mark = PDL->get_convertedpdl(mark,PDL_L);
	  }if(PDL_L != space->datatype) {
	     space = PDL->get_convertedpdl(space,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = mark;
__privtrans->pdls[1] = space;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plseed(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *seed;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    seed = PDL->SvPDLV(ST(0));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    seed = PDL->SvPDLV(ST(0));
  }
  else {
    croak ("Usage:  PDL::plseed(seed) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plseed_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plseed_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((seed->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != seed->datatype) {
	     seed = PDL->get_convertedpdl(seed,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = seed;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plrandd(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *rand_SV;
  pdl  *rand;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 1) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    rand = PDL->SvPDLV(ST(0));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       rand_SV = sv_newmortal();
       rand = PDL->null();
       PDL->SetSV_PDL(rand_SV,rand);
       if (bless_stash) rand_SV = sv_bless(rand_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       rand_SV = POPs;
       PUTBACK;
       rand = PDL->SvPDLV(rand_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plrandd(rand) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plrandd_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plrandd_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (rand->state & PDL_NOMYDIMS) && rand->trans == NULL ) {
	     rand->datatype = PDL_D;
	  } else if(PDL_D != rand->datatype) {
	     rand = PDL->get_convertedpdl(rand,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = rand;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  rand->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = rand_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pltr0 (x, y, grid)
  double x
  double y
  long grid
PPCODE:
  PLFLT tx, ty;

  pltr0 (x, y, &tx, &ty, (PLPointer) grid);

  EXTEND (SP, 2);
  PUSHs (sv_2mortal (newSVnv ((double) tx)));
  PUSHs (sv_2mortal (newSVnv ((double) ty)));

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pltr1 (x, y, grid)
  double x
  double y
  long grid
PPCODE:
  PLFLT tx, ty;

  pltr1 (x, y, &tx, &ty, (PLPointer) grid);

  EXTEND (SP, 2);
  PUSHs (sv_2mortal (newSVnv ((double) tx)));
  PUSHs (sv_2mortal (newSVnv ((double) ty)));

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pltr2 (x, y, grid)
  double x
  double y
  long grid
PPCODE:
  PLFLT tx, ty;

  pltr2 (x, y, &tx, &ty, (PLPointer) grid);

  EXTEND (SP, 2);
  PUSHs (sv_2mortal (newSVnv ((double) tx)));
  PUSHs (sv_2mortal (newSVnv ((double) ty)));

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plAllocGrid(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *grid_SV;
  pdl  *xg;
  pdl  *yg;
  pdl  *grid;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xg = PDL->SvPDLV(ST(0));
    yg = PDL->SvPDLV(ST(1));
    grid = PDL->SvPDLV(ST(2));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    xg = PDL->SvPDLV(ST(0));
    yg = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       grid_SV = sv_newmortal();
       grid = PDL->null();
       PDL->SetSV_PDL(grid_SV,grid);
       if (bless_stash) grid_SV = sv_bless(grid_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       grid_SV = POPs;
       PUTBACK;
       grid = PDL->SvPDLV(grid_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plAllocGrid(xg,yg,grid) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plAllocGrid_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plAllocGrid_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xg->state & PDL_BADVAL) > 0) || ((yg->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xg->datatype) {
	     xg = PDL->get_convertedpdl(xg,PDL_D);
	  }if(PDL_D != yg->datatype) {
	     yg = PDL->get_convertedpdl(yg,PDL_D);
	  }if( (grid->state & PDL_NOMYDIMS) && grid->trans == NULL ) {
	     grid->datatype = PDL_L;
	  } else if(PDL_L != grid->datatype) {
	     grid = PDL->get_convertedpdl(grid,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xg;
__privtrans->pdls[1] = yg;
__privtrans->pdls[2] = grid;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  grid->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = grid_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plFreeGrid (pg)
  long pg
PPCODE:
  PLcGrid* grid = (PLcGrid*) pg;
  free (grid->xg);
  free (grid->yg);
  free (grid);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plAlloc2dGrid(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *grid_SV;
  pdl  *xg;
  pdl  *yg;
  pdl  *grid;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xg = PDL->SvPDLV(ST(0));
    yg = PDL->SvPDLV(ST(1));
    grid = PDL->SvPDLV(ST(2));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    xg = PDL->SvPDLV(ST(0));
    yg = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       grid_SV = sv_newmortal();
       grid = PDL->null();
       PDL->SetSV_PDL(grid_SV,grid);
       if (bless_stash) grid_SV = sv_bless(grid_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       grid_SV = POPs;
       PUTBACK;
       grid = PDL->SvPDLV(grid_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plAlloc2dGrid(xg,yg,grid) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plAlloc2dGrid_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plAlloc2dGrid_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xg->state & PDL_BADVAL) > 0) || ((yg->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xg->datatype) {
	     xg = PDL->get_convertedpdl(xg,PDL_D);
	  }if(PDL_D != yg->datatype) {
	     yg = PDL->get_convertedpdl(yg,PDL_D);
	  }if( (grid->state & PDL_NOMYDIMS) && grid->trans == NULL ) {
	     grid->datatype = PDL_L;
	  } else if(PDL_L != grid->datatype) {
	     grid = PDL->get_convertedpdl(grid,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xg;
__privtrans->pdls[1] = yg;
__privtrans->pdls[2] = grid;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  grid->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = grid_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plFree2dGrid (pg)
  long pg
PPCODE:
  PLcGrid2* grid = (PLcGrid2*) pg;
  plFree2dGrid (grid->xg, grid->nx, grid->ny);
  plFree2dGrid (grid->yg, grid->nx, grid->ny);
  free (grid);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
init_pltr(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p0;
  SV *p1;
  SV *p2;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p0 = ST(0)
;
    p1 = ST(1)
;
    p2 = ST(2)
;
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    p0 = ST(0)
;
    p1 = ST(1)
;
    p2 = ST(2)
;
  }
  else {
    croak ("Usage:  PDL::init_pltr(p0,p1,p2) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_init_pltr_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_init_pltr_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
{(__privtrans->p0) = newSVsv(p0);(__privtrans->p1) = newSVsv(p1);(__privtrans->p2) = newSVsv(p2);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plmap_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *minlong;
  pdl  *maxlong;
  pdl  *minlat;
  pdl  *maxlat;
  SV *mapform;
  char *type;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    minlong = PDL->SvPDLV(ST(0));
    maxlong = PDL->SvPDLV(ST(1));
    minlat = PDL->SvPDLV(ST(2));
    maxlat = PDL->SvPDLV(ST(3));
    mapform = ST(4)
;
    type = (char *)SvPV_nolen(ST(5))
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    minlong = PDL->SvPDLV(ST(0));
    maxlong = PDL->SvPDLV(ST(1));
    minlat = PDL->SvPDLV(ST(2));
    maxlat = PDL->SvPDLV(ST(3));
    mapform = ST(4)
;
    type = (char *)SvPV_nolen(ST(5))
;
  }
  else {
    croak ("Usage:  PDL::plmap_pp(minlong,maxlong,minlat,maxlat,mapform,type) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plmap_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plmap_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((minlong->state & PDL_BADVAL) > 0) || ((maxlong->state & PDL_BADVAL) > 0) || ((minlat->state & PDL_BADVAL) > 0) || ((maxlat->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < minlong->datatype) {
		 	__privtrans->__datatype = minlong->datatype;
		    }
if(__privtrans->__datatype < maxlong->datatype) {
		 	__privtrans->__datatype = maxlong->datatype;
		    }
if(__privtrans->__datatype < minlat->datatype) {
		 	__privtrans->__datatype = minlat->datatype;
		    }
if(__privtrans->__datatype < maxlat->datatype) {
		 	__privtrans->__datatype = maxlat->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != minlong->datatype) {
	     minlong = PDL->get_convertedpdl(minlong,__privtrans->__datatype);
	  }if(__privtrans->__datatype != maxlong->datatype) {
	     maxlong = PDL->get_convertedpdl(maxlong,__privtrans->__datatype);
	  }if(__privtrans->__datatype != minlat->datatype) {
	     minlat = PDL->get_convertedpdl(minlat,__privtrans->__datatype);
	  }if(__privtrans->__datatype != maxlat->datatype) {
	     maxlat = PDL->get_convertedpdl(maxlat,__privtrans->__datatype);
	  }{(__privtrans->mapform) = newSVsv(mapform);(__privtrans->type) = malloc(strlen(type)+1); strcpy(__privtrans->type,type);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = minlong;
__privtrans->pdls[1] = maxlong;
__privtrans->pdls[2] = minlat;
__privtrans->pdls[3] = maxlat;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstring(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  char *string;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    string = (char *)SvPV_nolen(ST(2))
;
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    string = (char *)SvPV_nolen(ST(2))
;
  }
  else {
    croak ("Usage:  PDL::plstring(x,y,string) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstring_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstring_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }{(__privtrans->string) = malloc(strlen(string)+1); strcpy(__privtrans->string,string);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plstring3(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  char *string;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    string = (char *)SvPV_nolen(ST(3))
;
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    string = (char *)SvPV_nolen(ST(3))
;
  }
  else {
    croak ("Usage:  PDL::plstring3(x,y,z,string) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstring3_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstring3_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }{(__privtrans->string) = malloc(strlen(string)+1); strcpy(__privtrans->string,string);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plmeridians_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *dlong;
  pdl  *dlat;
  pdl  *minlong;
  pdl  *maxlong;
  pdl  *minlat;
  pdl  *maxlat;
  SV *mapform;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    dlong = PDL->SvPDLV(ST(0));
    dlat = PDL->SvPDLV(ST(1));
    minlong = PDL->SvPDLV(ST(2));
    maxlong = PDL->SvPDLV(ST(3));
    minlat = PDL->SvPDLV(ST(4));
    maxlat = PDL->SvPDLV(ST(5));
    mapform = ST(6)
;
  }
  else if (items == 7) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    dlong = PDL->SvPDLV(ST(0));
    dlat = PDL->SvPDLV(ST(1));
    minlong = PDL->SvPDLV(ST(2));
    maxlong = PDL->SvPDLV(ST(3));
    minlat = PDL->SvPDLV(ST(4));
    maxlat = PDL->SvPDLV(ST(5));
    mapform = ST(6)
;
  }
  else {
    croak ("Usage:  PDL::plmeridians_pp(dlong,dlat,minlong,maxlong,minlat,maxlat,mapform) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plmeridians_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plmeridians_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((dlong->state & PDL_BADVAL) > 0) || ((dlat->state & PDL_BADVAL) > 0) || ((minlong->state & PDL_BADVAL) > 0) || ((maxlong->state & PDL_BADVAL) > 0) || ((minlat->state & PDL_BADVAL) > 0) || ((maxlat->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < dlong->datatype) {
		 	__privtrans->__datatype = dlong->datatype;
		    }
if(__privtrans->__datatype < dlat->datatype) {
		 	__privtrans->__datatype = dlat->datatype;
		    }
if(__privtrans->__datatype < minlong->datatype) {
		 	__privtrans->__datatype = minlong->datatype;
		    }
if(__privtrans->__datatype < maxlong->datatype) {
		 	__privtrans->__datatype = maxlong->datatype;
		    }
if(__privtrans->__datatype < minlat->datatype) {
		 	__privtrans->__datatype = minlat->datatype;
		    }
if(__privtrans->__datatype < maxlat->datatype) {
		 	__privtrans->__datatype = maxlat->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != dlong->datatype) {
	     dlong = PDL->get_convertedpdl(dlong,__privtrans->__datatype);
	  }if(__privtrans->__datatype != dlat->datatype) {
	     dlat = PDL->get_convertedpdl(dlat,__privtrans->__datatype);
	  }if(__privtrans->__datatype != minlong->datatype) {
	     minlong = PDL->get_convertedpdl(minlong,__privtrans->__datatype);
	  }if(__privtrans->__datatype != maxlong->datatype) {
	     maxlong = PDL->get_convertedpdl(maxlong,__privtrans->__datatype);
	  }if(__privtrans->__datatype != minlat->datatype) {
	     minlat = PDL->get_convertedpdl(minlat,__privtrans->__datatype);
	  }if(__privtrans->__datatype != maxlat->datatype) {
	     maxlat = PDL->get_convertedpdl(maxlat,__privtrans->__datatype);
	  }{(__privtrans->mapform) = newSVsv(mapform);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = dlong;
__privtrans->pdls[1] = dlat;
__privtrans->pdls[2] = minlong;
__privtrans->pdls[3] = maxlong;
__privtrans->pdls[4] = minlat;
__privtrans->pdls[5] = maxlat;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plshades_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *z;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *clevel;
  pdl  *fill_width;
  pdl  *cont_color;
  pdl  *cont_width;
  pdl  *rectangular;
  SV *defined;
  SV *pltr;
  SV *pltr_data;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 13) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    z = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    clevel = PDL->SvPDLV(ST(5));
    fill_width = PDL->SvPDLV(ST(6));
    cont_color = PDL->SvPDLV(ST(7));
    cont_width = PDL->SvPDLV(ST(8));
    rectangular = PDL->SvPDLV(ST(9));
    defined = ST(10)
;
    pltr = ST(11)
;
    pltr_data = ST(12)
;
  }
  else if (items == 13) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    z = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    clevel = PDL->SvPDLV(ST(5));
    fill_width = PDL->SvPDLV(ST(6));
    cont_color = PDL->SvPDLV(ST(7));
    cont_width = PDL->SvPDLV(ST(8));
    rectangular = PDL->SvPDLV(ST(9));
    defined = ST(10)
;
    pltr = ST(11)
;
    pltr_data = ST(12)
;
  }
  else {
    croak ("Usage:  PDL::plshades_pp(z,xmin,xmax,ymin,ymax,clevel,fill_width,cont_color,cont_width,rectangular,defined,pltr,pltr_data) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plshades_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plshades_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((z->state & PDL_BADVAL) > 0) || ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((clevel->state & PDL_BADVAL) > 0) || ((fill_width->state & PDL_BADVAL) > 0) || ((cont_color->state & PDL_BADVAL) > 0) || ((cont_width->state & PDL_BADVAL) > 0) || ((rectangular->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype < xmin->datatype) {
		 	__privtrans->__datatype = xmin->datatype;
		    }
if(__privtrans->__datatype < xmax->datatype) {
		 	__privtrans->__datatype = xmax->datatype;
		    }
if(__privtrans->__datatype < ymin->datatype) {
		 	__privtrans->__datatype = ymin->datatype;
		    }
if(__privtrans->__datatype < ymax->datatype) {
		 	__privtrans->__datatype = ymax->datatype;
		    }
if(__privtrans->__datatype < clevel->datatype) {
		 	__privtrans->__datatype = clevel->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != clevel->datatype) {
	     clevel = PDL->get_convertedpdl(clevel,__privtrans->__datatype);
	  }if(PDL_L != fill_width->datatype) {
	     fill_width = PDL->get_convertedpdl(fill_width,PDL_L);
	  }if(PDL_L != cont_color->datatype) {
	     cont_color = PDL->get_convertedpdl(cont_color,PDL_L);
	  }if(PDL_L != cont_width->datatype) {
	     cont_width = PDL->get_convertedpdl(cont_width,PDL_L);
	  }if(PDL_L != rectangular->datatype) {
	     rectangular = PDL->get_convertedpdl(rectangular,PDL_L);
	  }{(__privtrans->defined) = newSVsv(defined);(__privtrans->pltr) = newSVsv(pltr);(__privtrans->pltr_data) = newSVsv(pltr_data);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = z;
__privtrans->pdls[1] = xmin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymin;
__privtrans->pdls[4] = ymax;
__privtrans->pdls[5] = clevel;
__privtrans->pdls[6] = fill_width;
__privtrans->pdls[7] = cont_color;
__privtrans->pdls[8] = cont_width;
__privtrans->pdls[9] = rectangular;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plcont(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *f;
  pdl  *kx;
  pdl  *lx;
  pdl  *ky;
  pdl  *ly;
  pdl  *clevel;
  SV *pltr;
  SV *pltr_data;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 8) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    f = PDL->SvPDLV(ST(0));
    kx = PDL->SvPDLV(ST(1));
    lx = PDL->SvPDLV(ST(2));
    ky = PDL->SvPDLV(ST(3));
    ly = PDL->SvPDLV(ST(4));
    clevel = PDL->SvPDLV(ST(5));
    pltr = ST(6)
;
    pltr_data = ST(7)
;
  }
  else if (items == 8) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    f = PDL->SvPDLV(ST(0));
    kx = PDL->SvPDLV(ST(1));
    lx = PDL->SvPDLV(ST(2));
    ky = PDL->SvPDLV(ST(3));
    ly = PDL->SvPDLV(ST(4));
    clevel = PDL->SvPDLV(ST(5));
    pltr = ST(6)
;
    pltr_data = ST(7)
;
  }
  else {
    croak ("Usage:  PDL::plcont(f,kx,lx,ky,ly,clevel,pltr,pltr_data) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plcont_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plcont_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((f->state & PDL_BADVAL) > 0) || ((kx->state & PDL_BADVAL) > 0) || ((lx->state & PDL_BADVAL) > 0) || ((ky->state & PDL_BADVAL) > 0) || ((ly->state & PDL_BADVAL) > 0) || ((clevel->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < f->datatype) {
		 	__privtrans->__datatype = f->datatype;
		    }
if(__privtrans->__datatype < clevel->datatype) {
		 	__privtrans->__datatype = clevel->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != f->datatype) {
	     f = PDL->get_convertedpdl(f,__privtrans->__datatype);
	  }if(PDL_L != kx->datatype) {
	     kx = PDL->get_convertedpdl(kx,PDL_L);
	  }if(PDL_L != lx->datatype) {
	     lx = PDL->get_convertedpdl(lx,PDL_L);
	  }if(PDL_L != ky->datatype) {
	     ky = PDL->get_convertedpdl(ky,PDL_L);
	  }if(PDL_L != ly->datatype) {
	     ly = PDL->get_convertedpdl(ly,PDL_L);
	  }if(__privtrans->__datatype != clevel->datatype) {
	     clevel = PDL->get_convertedpdl(clevel,__privtrans->__datatype);
	  }{(__privtrans->pltr) = newSVsv(pltr);(__privtrans->pltr_data) = newSVsv(pltr_data);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = f;
__privtrans->pdls[1] = kx;
__privtrans->pdls[2] = lx;
__privtrans->pdls[3] = ky;
__privtrans->pdls[4] = ly;
__privtrans->pdls[5] = clevel;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plmesh(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *opt;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plmesh(x,y,z,opt) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plmesh_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plmesh_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((opt->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != opt->datatype) {
	     opt = PDL->get_convertedpdl(opt,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = opt;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plmeshc(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *opt;
  pdl  *clevel;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    clevel = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    clevel = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plmeshc(x,y,z,opt,clevel) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plmeshc_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plmeshc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((opt->state & PDL_BADVAL) > 0) || ((clevel->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype < clevel->datatype) {
		 	__privtrans->__datatype = clevel->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != opt->datatype) {
	     opt = PDL->get_convertedpdl(opt,PDL_L);
	  }if(__privtrans->__datatype != clevel->datatype) {
	     clevel = PDL->get_convertedpdl(clevel,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = opt;
__privtrans->pdls[4] = clevel;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plot3d(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *opt;
  pdl  *side;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    side = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    side = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plot3d(x,y,z,opt,side) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plot3d_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plot3d_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((opt->state & PDL_BADVAL) > 0) || ((side->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != opt->datatype) {
	     opt = PDL->get_convertedpdl(opt,PDL_L);
	  }if(PDL_L != side->datatype) {
	     side = PDL->get_convertedpdl(side,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = opt;
__privtrans->pdls[4] = side;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plot3dc(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *opt;
  pdl  *clevel;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    clevel = PDL->SvPDLV(ST(4));
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    opt = PDL->SvPDLV(ST(3));
    clevel = PDL->SvPDLV(ST(4));
  }
  else {
    croak ("Usage:  PDL::plot3dc(x,y,z,opt,clevel) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plot3dc_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plot3dc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((opt->state & PDL_BADVAL) > 0) || ((clevel->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype < clevel->datatype) {
		 	__privtrans->__datatype = clevel->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(PDL_L != opt->datatype) {
	     opt = PDL->get_convertedpdl(opt,PDL_L);
	  }if(__privtrans->__datatype != clevel->datatype) {
	     clevel = PDL->get_convertedpdl(clevel,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = opt;
__privtrans->pdls[4] = clevel;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap1l(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *itype;
  pdl  *isty;
  pdl  *coord1;
  pdl  *coord2;
  pdl  *coord3;
  pdl  *rev;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    itype = PDL->SvPDLV(ST(0));
    isty = PDL->SvPDLV(ST(1));
    coord1 = PDL->SvPDLV(ST(2));
    coord2 = PDL->SvPDLV(ST(3));
    coord3 = PDL->SvPDLV(ST(4));
    rev = PDL->SvPDLV(ST(5));
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    itype = PDL->SvPDLV(ST(0));
    isty = PDL->SvPDLV(ST(1));
    coord1 = PDL->SvPDLV(ST(2));
    coord2 = PDL->SvPDLV(ST(3));
    coord3 = PDL->SvPDLV(ST(4));
    rev = PDL->SvPDLV(ST(5));
  }
  else {
    croak ("Usage:  PDL::plscmap1l(itype,isty,coord1,coord2,coord3,rev) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap1l_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap1l_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((itype->state & PDL_BADVAL) > 0) || ((isty->state & PDL_BADVAL) > 0) || ((coord1->state & PDL_BADVAL) > 0) || ((coord2->state & PDL_BADVAL) > 0) || ((coord3->state & PDL_BADVAL) > 0) || ((rev->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < isty->datatype) {
		 	__privtrans->__datatype = isty->datatype;
		    }
if(__privtrans->__datatype < coord1->datatype) {
		 	__privtrans->__datatype = coord1->datatype;
		    }
if(__privtrans->__datatype < coord2->datatype) {
		 	__privtrans->__datatype = coord2->datatype;
		    }
if(__privtrans->__datatype < coord3->datatype) {
		 	__privtrans->__datatype = coord3->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != itype->datatype) {
	     itype = PDL->get_convertedpdl(itype,PDL_L);
	  }if(__privtrans->__datatype != isty->datatype) {
	     isty = PDL->get_convertedpdl(isty,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord1->datatype) {
	     coord1 = PDL->get_convertedpdl(coord1,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord2->datatype) {
	     coord2 = PDL->get_convertedpdl(coord2,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord3->datatype) {
	     coord3 = PDL->get_convertedpdl(coord3,__privtrans->__datatype);
	  }if(PDL_L != rev->datatype) {
	     rev = PDL->get_convertedpdl(rev,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = itype;
__privtrans->pdls[1] = isty;
__privtrans->pdls[2] = coord1;
__privtrans->pdls[3] = coord2;
__privtrans->pdls[4] = coord3;
__privtrans->pdls[5] = rev;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plshade1_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *a;
  pdl  *left;
  pdl  *right;
  pdl  *bottom;
  pdl  *top;
  pdl  *shade_min;
  pdl  *shade_max;
  pdl  *sh_cmap;
  pdl  *sh_color;
  pdl  *sh_width;
  pdl  *min_color;
  pdl  *min_width;
  pdl  *max_color;
  pdl  *max_width;
  pdl  *rectangular;
  SV *defined;
  SV *pltr;
  SV *pltr_data;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 18) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    a = PDL->SvPDLV(ST(0));
    left = PDL->SvPDLV(ST(1));
    right = PDL->SvPDLV(ST(2));
    bottom = PDL->SvPDLV(ST(3));
    top = PDL->SvPDLV(ST(4));
    shade_min = PDL->SvPDLV(ST(5));
    shade_max = PDL->SvPDLV(ST(6));
    sh_cmap = PDL->SvPDLV(ST(7));
    sh_color = PDL->SvPDLV(ST(8));
    sh_width = PDL->SvPDLV(ST(9));
    min_color = PDL->SvPDLV(ST(10));
    min_width = PDL->SvPDLV(ST(11));
    max_color = PDL->SvPDLV(ST(12));
    max_width = PDL->SvPDLV(ST(13));
    rectangular = PDL->SvPDLV(ST(14));
    defined = ST(15)
;
    pltr = ST(16)
;
    pltr_data = ST(17)
;
  }
  else if (items == 18) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    a = PDL->SvPDLV(ST(0));
    left = PDL->SvPDLV(ST(1));
    right = PDL->SvPDLV(ST(2));
    bottom = PDL->SvPDLV(ST(3));
    top = PDL->SvPDLV(ST(4));
    shade_min = PDL->SvPDLV(ST(5));
    shade_max = PDL->SvPDLV(ST(6));
    sh_cmap = PDL->SvPDLV(ST(7));
    sh_color = PDL->SvPDLV(ST(8));
    sh_width = PDL->SvPDLV(ST(9));
    min_color = PDL->SvPDLV(ST(10));
    min_width = PDL->SvPDLV(ST(11));
    max_color = PDL->SvPDLV(ST(12));
    max_width = PDL->SvPDLV(ST(13));
    rectangular = PDL->SvPDLV(ST(14));
    defined = ST(15)
;
    pltr = ST(16)
;
    pltr_data = ST(17)
;
  }
  else {
    croak ("Usage:  PDL::plshade1_pp(a,left,right,bottom,top,shade_min,shade_max,sh_cmap,sh_color,sh_width,min_color,min_width,max_color,max_width,rectangular,defined,pltr,pltr_data) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plshade1_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plshade1_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((a->state & PDL_BADVAL) > 0) || ((left->state & PDL_BADVAL) > 0) || ((right->state & PDL_BADVAL) > 0) || ((bottom->state & PDL_BADVAL) > 0) || ((top->state & PDL_BADVAL) > 0) || ((shade_min->state & PDL_BADVAL) > 0) || ((shade_max->state & PDL_BADVAL) > 0) || ((sh_cmap->state & PDL_BADVAL) > 0) || ((sh_color->state & PDL_BADVAL) > 0) || ((sh_width->state & PDL_BADVAL) > 0) || ((min_color->state & PDL_BADVAL) > 0) || ((min_width->state & PDL_BADVAL) > 0) || ((max_color->state & PDL_BADVAL) > 0) || ((max_width->state & PDL_BADVAL) > 0) || ((rectangular->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < a->datatype) {
		 	__privtrans->__datatype = a->datatype;
		    }
if(__privtrans->__datatype < left->datatype) {
		 	__privtrans->__datatype = left->datatype;
		    }
if(__privtrans->__datatype < right->datatype) {
		 	__privtrans->__datatype = right->datatype;
		    }
if(__privtrans->__datatype < bottom->datatype) {
		 	__privtrans->__datatype = bottom->datatype;
		    }
if(__privtrans->__datatype < top->datatype) {
		 	__privtrans->__datatype = top->datatype;
		    }
if(__privtrans->__datatype < shade_min->datatype) {
		 	__privtrans->__datatype = shade_min->datatype;
		    }
if(__privtrans->__datatype < shade_max->datatype) {
		 	__privtrans->__datatype = shade_max->datatype;
		    }
if(__privtrans->__datatype < sh_cmap->datatype) {
		 	__privtrans->__datatype = sh_cmap->datatype;
		    }
if(__privtrans->__datatype < sh_color->datatype) {
		 	__privtrans->__datatype = sh_color->datatype;
		    }
if(__privtrans->__datatype < sh_width->datatype) {
		 	__privtrans->__datatype = sh_width->datatype;
		    }
if(__privtrans->__datatype < min_color->datatype) {
		 	__privtrans->__datatype = min_color->datatype;
		    }
if(__privtrans->__datatype < min_width->datatype) {
		 	__privtrans->__datatype = min_width->datatype;
		    }
if(__privtrans->__datatype < max_color->datatype) {
		 	__privtrans->__datatype = max_color->datatype;
		    }
if(__privtrans->__datatype < max_width->datatype) {
		 	__privtrans->__datatype = max_width->datatype;
		    }
if(__privtrans->__datatype < rectangular->datatype) {
		 	__privtrans->__datatype = rectangular->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != a->datatype) {
	     a = PDL->get_convertedpdl(a,__privtrans->__datatype);
	  }if(__privtrans->__datatype != left->datatype) {
	     left = PDL->get_convertedpdl(left,__privtrans->__datatype);
	  }if(__privtrans->__datatype != right->datatype) {
	     right = PDL->get_convertedpdl(right,__privtrans->__datatype);
	  }if(__privtrans->__datatype != bottom->datatype) {
	     bottom = PDL->get_convertedpdl(bottom,__privtrans->__datatype);
	  }if(__privtrans->__datatype != top->datatype) {
	     top = PDL->get_convertedpdl(top,__privtrans->__datatype);
	  }if(__privtrans->__datatype != shade_min->datatype) {
	     shade_min = PDL->get_convertedpdl(shade_min,__privtrans->__datatype);
	  }if(__privtrans->__datatype != shade_max->datatype) {
	     shade_max = PDL->get_convertedpdl(shade_max,__privtrans->__datatype);
	  }if(__privtrans->__datatype != sh_cmap->datatype) {
	     sh_cmap = PDL->get_convertedpdl(sh_cmap,__privtrans->__datatype);
	  }if(__privtrans->__datatype != sh_color->datatype) {
	     sh_color = PDL->get_convertedpdl(sh_color,__privtrans->__datatype);
	  }if(__privtrans->__datatype != sh_width->datatype) {
	     sh_width = PDL->get_convertedpdl(sh_width,__privtrans->__datatype);
	  }if(__privtrans->__datatype != min_color->datatype) {
	     min_color = PDL->get_convertedpdl(min_color,__privtrans->__datatype);
	  }if(__privtrans->__datatype != min_width->datatype) {
	     min_width = PDL->get_convertedpdl(min_width,__privtrans->__datatype);
	  }if(__privtrans->__datatype != max_color->datatype) {
	     max_color = PDL->get_convertedpdl(max_color,__privtrans->__datatype);
	  }if(__privtrans->__datatype != max_width->datatype) {
	     max_width = PDL->get_convertedpdl(max_width,__privtrans->__datatype);
	  }if(__privtrans->__datatype != rectangular->datatype) {
	     rectangular = PDL->get_convertedpdl(rectangular,__privtrans->__datatype);
	  }{(__privtrans->defined) = newSVsv(defined);(__privtrans->pltr) = newSVsv(pltr);(__privtrans->pltr_data) = newSVsv(pltr_data);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = a;
__privtrans->pdls[1] = left;
__privtrans->pdls[2] = right;
__privtrans->pdls[3] = bottom;
__privtrans->pdls[4] = top;
__privtrans->pdls[5] = shade_min;
__privtrans->pdls[6] = shade_max;
__privtrans->pdls[7] = sh_cmap;
__privtrans->pdls[8] = sh_color;
__privtrans->pdls[9] = sh_width;
__privtrans->pdls[10] = min_color;
__privtrans->pdls[11] = min_width;
__privtrans->pdls[12] = max_color;
__privtrans->pdls[13] = max_width;
__privtrans->pdls[14] = rectangular;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plimage(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *idata;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *zmin;
  pdl  *zmax;
  pdl  *Dxmin;
  pdl  *Dxmax;
  pdl  *Dymin;
  pdl  *Dymax;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 11) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    idata = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    zmin = PDL->SvPDLV(ST(5));
    zmax = PDL->SvPDLV(ST(6));
    Dxmin = PDL->SvPDLV(ST(7));
    Dxmax = PDL->SvPDLV(ST(8));
    Dymin = PDL->SvPDLV(ST(9));
    Dymax = PDL->SvPDLV(ST(10));
  }
  else if (items == 11) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    idata = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    zmin = PDL->SvPDLV(ST(5));
    zmax = PDL->SvPDLV(ST(6));
    Dxmin = PDL->SvPDLV(ST(7));
    Dxmax = PDL->SvPDLV(ST(8));
    Dymin = PDL->SvPDLV(ST(9));
    Dymax = PDL->SvPDLV(ST(10));
  }
  else {
    croak ("Usage:  PDL::plimage(idata,xmin,xmax,ymin,ymax,zmin,zmax,Dxmin,Dxmax,Dymin,Dymax) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plimage_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plimage_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((idata->state & PDL_BADVAL) > 0) || ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((zmin->state & PDL_BADVAL) > 0) || ((zmax->state & PDL_BADVAL) > 0) || ((Dxmin->state & PDL_BADVAL) > 0) || ((Dxmax->state & PDL_BADVAL) > 0) || ((Dymin->state & PDL_BADVAL) > 0) || ((Dymax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < idata->datatype) {
		 	__privtrans->__datatype = idata->datatype;
		    }
if(__privtrans->__datatype < xmin->datatype) {
		 	__privtrans->__datatype = xmin->datatype;
		    }
if(__privtrans->__datatype < xmax->datatype) {
		 	__privtrans->__datatype = xmax->datatype;
		    }
if(__privtrans->__datatype < ymin->datatype) {
		 	__privtrans->__datatype = ymin->datatype;
		    }
if(__privtrans->__datatype < ymax->datatype) {
		 	__privtrans->__datatype = ymax->datatype;
		    }
if(__privtrans->__datatype < zmin->datatype) {
		 	__privtrans->__datatype = zmin->datatype;
		    }
if(__privtrans->__datatype < zmax->datatype) {
		 	__privtrans->__datatype = zmax->datatype;
		    }
if(__privtrans->__datatype < Dxmin->datatype) {
		 	__privtrans->__datatype = Dxmin->datatype;
		    }
if(__privtrans->__datatype < Dxmax->datatype) {
		 	__privtrans->__datatype = Dxmax->datatype;
		    }
if(__privtrans->__datatype < Dymin->datatype) {
		 	__privtrans->__datatype = Dymin->datatype;
		    }
if(__privtrans->__datatype < Dymax->datatype) {
		 	__privtrans->__datatype = Dymax->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != idata->datatype) {
	     idata = PDL->get_convertedpdl(idata,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != zmin->datatype) {
	     zmin = PDL->get_convertedpdl(zmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != zmax->datatype) {
	     zmax = PDL->get_convertedpdl(zmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != Dxmin->datatype) {
	     Dxmin = PDL->get_convertedpdl(Dxmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != Dxmax->datatype) {
	     Dxmax = PDL->get_convertedpdl(Dxmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != Dymin->datatype) {
	     Dymin = PDL->get_convertedpdl(Dymin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != Dymax->datatype) {
	     Dymax = PDL->get_convertedpdl(Dymax,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = idata;
__privtrans->pdls[1] = xmin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymin;
__privtrans->pdls[4] = ymax;
__privtrans->pdls[5] = zmin;
__privtrans->pdls[6] = zmax;
__privtrans->pdls[7] = Dxmin;
__privtrans->pdls[8] = Dxmax;
__privtrans->pdls[9] = Dymin;
__privtrans->pdls[10] = Dymax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plimagefr(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *idata;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *zmin;
  pdl  *zmax;
  pdl  *valuemin;
  pdl  *valuemax;
  SV *pltr;
  SV *pltr_data;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 11) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    idata = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    zmin = PDL->SvPDLV(ST(5));
    zmax = PDL->SvPDLV(ST(6));
    valuemin = PDL->SvPDLV(ST(7));
    valuemax = PDL->SvPDLV(ST(8));
    pltr = ST(9)
;
    pltr_data = ST(10)
;
  }
  else if (items == 11) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    idata = PDL->SvPDLV(ST(0));
    xmin = PDL->SvPDLV(ST(1));
    xmax = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    zmin = PDL->SvPDLV(ST(5));
    zmax = PDL->SvPDLV(ST(6));
    valuemin = PDL->SvPDLV(ST(7));
    valuemax = PDL->SvPDLV(ST(8));
    pltr = ST(9)
;
    pltr_data = ST(10)
;
  }
  else {
    croak ("Usage:  PDL::plimagefr(idata,xmin,xmax,ymin,ymax,zmin,zmax,valuemin,valuemax,pltr,pltr_data) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plimagefr_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plimagefr_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((idata->state & PDL_BADVAL) > 0) || ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((zmin->state & PDL_BADVAL) > 0) || ((zmax->state & PDL_BADVAL) > 0) || ((valuemin->state & PDL_BADVAL) > 0) || ((valuemax->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < idata->datatype) {
		 	__privtrans->__datatype = idata->datatype;
		    }
if(__privtrans->__datatype < xmin->datatype) {
		 	__privtrans->__datatype = xmin->datatype;
		    }
if(__privtrans->__datatype < xmax->datatype) {
		 	__privtrans->__datatype = xmax->datatype;
		    }
if(__privtrans->__datatype < ymin->datatype) {
		 	__privtrans->__datatype = ymin->datatype;
		    }
if(__privtrans->__datatype < ymax->datatype) {
		 	__privtrans->__datatype = ymax->datatype;
		    }
if(__privtrans->__datatype < zmin->datatype) {
		 	__privtrans->__datatype = zmin->datatype;
		    }
if(__privtrans->__datatype < zmax->datatype) {
		 	__privtrans->__datatype = zmax->datatype;
		    }
if(__privtrans->__datatype < valuemin->datatype) {
		 	__privtrans->__datatype = valuemin->datatype;
		    }
if(__privtrans->__datatype < valuemax->datatype) {
		 	__privtrans->__datatype = valuemax->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != idata->datatype) {
	     idata = PDL->get_convertedpdl(idata,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != zmin->datatype) {
	     zmin = PDL->get_convertedpdl(zmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != zmax->datatype) {
	     zmax = PDL->get_convertedpdl(zmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != valuemin->datatype) {
	     valuemin = PDL->get_convertedpdl(valuemin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != valuemax->datatype) {
	     valuemax = PDL->get_convertedpdl(valuemax,__privtrans->__datatype);
	  }{(__privtrans->pltr) = newSVsv(pltr);(__privtrans->pltr_data) = newSVsv(pltr_data);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = idata;
__privtrans->pdls[1] = xmin;
__privtrans->pdls[2] = xmax;
__privtrans->pdls[3] = ymin;
__privtrans->pdls[4] = ymax;
__privtrans->pdls[5] = zmin;
__privtrans->pdls[6] = zmax;
__privtrans->pdls[7] = valuemin;
__privtrans->pdls[8] = valuemax;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plxormod (mode)
  int mode
CODE:
  PLINT status;
  c_plxormod (mode, &status);
  RETVAL = status;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plGetCursor ()
PPCODE:
  PLGraphicsIn gin;
  if (plGetCursor (&gin)) {
    EXTEND (SP, 24);
    PUSHs (sv_2mortal (newSVpv ("type", 0)));
    PUSHs (sv_2mortal (newSViv ((IV) gin.type)));
    PUSHs (sv_2mortal (newSVpv ("state", 0)));
    PUSHs (sv_2mortal (newSVuv ((UV) gin.state)));
    PUSHs (sv_2mortal (newSVpv ("keysym", 0)));
    PUSHs (sv_2mortal (newSVuv ((UV) gin.keysym)));
    PUSHs (sv_2mortal (newSVpv ("button", 0)));
    PUSHs (sv_2mortal (newSVuv ((UV) gin.button)));
    PUSHs (sv_2mortal (newSVpv ("subwindow", 0)));
    PUSHs (sv_2mortal (newSViv ((IV) gin.subwindow)));
    PUSHs (sv_2mortal (newSVpv ("string", 0)));
    PUSHs (sv_2mortal (newSVpv (gin.string, 0)));
    PUSHs (sv_2mortal (newSVpv ("pX", 0)));
    PUSHs (sv_2mortal (newSViv ((IV) gin.pX)));
    PUSHs (sv_2mortal (newSVpv ("pY", 0)));
    PUSHs (sv_2mortal (newSViv ((IV) gin.pY)));
    PUSHs (sv_2mortal (newSVpv ("dX", 0)));
    PUSHs (sv_2mortal (newSVnv ((double) gin.dX)));
    PUSHs (sv_2mortal (newSVpv ("dY", 0)));
    PUSHs (sv_2mortal (newSVnv ((double) gin.dY)));
    PUSHs (sv_2mortal (newSVpv ("wX", 0)));
    PUSHs (sv_2mortal (newSVnv ((double) gin.wX)));
    PUSHs (sv_2mortal (newSVpv ("wY", 0)));
    PUSHs (sv_2mortal (newSVnv ((double) gin.wY)));
  }

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plgstrm ()
CODE:
  PLINT strm;
  c_plgstrm (&strm);
  RETVAL = strm;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

char*
plgdev ()
CODE:
  char driver[80];
  c_plgdev (driver);
  RETVAL = driver;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

char*
plgfnam ()
CODE:
  char driver[80];
  c_plgfnam (driver);
  RETVAL = driver;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plmkstrm ()
CODE:
  PLINT strm;
  c_plmkstrm (&strm);
  RETVAL = strm;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

char*
plgver ()
CODE:
  char ver[80];
  c_plgver (ver);
  RETVAL = ver;
OUTPUT:
  RETVAL

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plstripc_pp(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *id_SV;
  pdl  *xmin;
  pdl  *xmax;
  pdl  *xjump;
  pdl  *ymin;
  pdl  *ymax;
  pdl  *xlpos;
  pdl  *ylpos;
  pdl  *y_ascl;
  pdl  *acc;
  pdl  *colbox;
  pdl  *collab;
  pdl  *colline;
  pdl  *styline;
  pdl  *id;
  char *xspec;
  char *yspec;
  SV *legline;
  char *labx;
  char *laby;
  char *labtop;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 20) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    xjump = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    xlpos = PDL->SvPDLV(ST(5));
    ylpos = PDL->SvPDLV(ST(6));
    y_ascl = PDL->SvPDLV(ST(7));
    acc = PDL->SvPDLV(ST(8));
    colbox = PDL->SvPDLV(ST(9));
    collab = PDL->SvPDLV(ST(10));
    colline = PDL->SvPDLV(ST(11));
    styline = PDL->SvPDLV(ST(12));
    id = PDL->SvPDLV(ST(13));
    xspec = (char *)SvPV_nolen(ST(14))
;
    yspec = (char *)SvPV_nolen(ST(15))
;
    legline = ST(16)
;
    labx = (char *)SvPV_nolen(ST(17))
;
    laby = (char *)SvPV_nolen(ST(18))
;
    labtop = (char *)SvPV_nolen(ST(19))
;
  }
  else if (items == 19) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    xmin = PDL->SvPDLV(ST(0));
    xmax = PDL->SvPDLV(ST(1));
    xjump = PDL->SvPDLV(ST(2));
    ymin = PDL->SvPDLV(ST(3));
    ymax = PDL->SvPDLV(ST(4));
    xlpos = PDL->SvPDLV(ST(5));
    ylpos = PDL->SvPDLV(ST(6));
    y_ascl = PDL->SvPDLV(ST(7));
    acc = PDL->SvPDLV(ST(8));
    colbox = PDL->SvPDLV(ST(9));
    collab = PDL->SvPDLV(ST(10));
    colline = PDL->SvPDLV(ST(11));
    styline = PDL->SvPDLV(ST(12));
    xspec = (char *)SvPV_nolen(ST(13))
;
    yspec = (char *)SvPV_nolen(ST(14))
;
    legline = ST(15)
;
    labx = (char *)SvPV_nolen(ST(16))
;
    laby = (char *)SvPV_nolen(ST(17))
;
    labtop = (char *)SvPV_nolen(ST(18))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       id_SV = sv_newmortal();
       id = PDL->null();
       PDL->SetSV_PDL(id_SV,id);
       if (bless_stash) id_SV = sv_bless(id_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       id_SV = POPs;
       PUTBACK;
       id = PDL->SvPDLV(id_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plstripc_pp(xmin,xmax,xjump,ymin,ymax,xlpos,ylpos,y_ascl,acc,colbox,collab,colline,styline,id,xspec,yspec,legline,labx,laby,labtop) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plstripc_pp_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plstripc_pp_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xmin->state & PDL_BADVAL) > 0) || ((xmax->state & PDL_BADVAL) > 0) || ((xjump->state & PDL_BADVAL) > 0) || ((ymin->state & PDL_BADVAL) > 0) || ((ymax->state & PDL_BADVAL) > 0) || ((xlpos->state & PDL_BADVAL) > 0) || ((ylpos->state & PDL_BADVAL) > 0) || ((y_ascl->state & PDL_BADVAL) > 0) || ((acc->state & PDL_BADVAL) > 0) || ((colbox->state & PDL_BADVAL) > 0) || ((collab->state & PDL_BADVAL) > 0) || ((colline->state & PDL_BADVAL) > 0) || ((styline->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xmin->datatype) {
		 	__privtrans->__datatype = xmin->datatype;
		    }
if(__privtrans->__datatype < xmax->datatype) {
		 	__privtrans->__datatype = xmax->datatype;
		    }
if(__privtrans->__datatype < xjump->datatype) {
		 	__privtrans->__datatype = xjump->datatype;
		    }
if(__privtrans->__datatype < ymin->datatype) {
		 	__privtrans->__datatype = ymin->datatype;
		    }
if(__privtrans->__datatype < ymax->datatype) {
		 	__privtrans->__datatype = ymax->datatype;
		    }
if(__privtrans->__datatype < xlpos->datatype) {
		 	__privtrans->__datatype = xlpos->datatype;
		    }
if(__privtrans->__datatype < ylpos->datatype) {
		 	__privtrans->__datatype = ylpos->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xmin->datatype) {
	     xmin = PDL->get_convertedpdl(xmin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xmax->datatype) {
	     xmax = PDL->get_convertedpdl(xmax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xjump->datatype) {
	     xjump = PDL->get_convertedpdl(xjump,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymin->datatype) {
	     ymin = PDL->get_convertedpdl(ymin,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ymax->datatype) {
	     ymax = PDL->get_convertedpdl(ymax,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xlpos->datatype) {
	     xlpos = PDL->get_convertedpdl(xlpos,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ylpos->datatype) {
	     ylpos = PDL->get_convertedpdl(ylpos,__privtrans->__datatype);
	  }if(PDL_L != y_ascl->datatype) {
	     y_ascl = PDL->get_convertedpdl(y_ascl,PDL_L);
	  }if(PDL_L != acc->datatype) {
	     acc = PDL->get_convertedpdl(acc,PDL_L);
	  }if(PDL_L != colbox->datatype) {
	     colbox = PDL->get_convertedpdl(colbox,PDL_L);
	  }if(PDL_L != collab->datatype) {
	     collab = PDL->get_convertedpdl(collab,PDL_L);
	  }if(PDL_L != colline->datatype) {
	     colline = PDL->get_convertedpdl(colline,PDL_L);
	  }if(PDL_L != styline->datatype) {
	     styline = PDL->get_convertedpdl(styline,PDL_L);
	  }if( (id->state & PDL_NOMYDIMS) && id->trans == NULL ) {
	     id->datatype = PDL_L;
	  } else if(PDL_L != id->datatype) {
	     id = PDL->get_convertedpdl(id,PDL_L);
	  }{(__privtrans->xspec) = malloc(strlen(xspec)+1); strcpy(__privtrans->xspec,xspec);(__privtrans->yspec) = malloc(strlen(yspec)+1); strcpy(__privtrans->yspec,yspec);(__privtrans->legline) = newSVsv(legline);(__privtrans->labx) = malloc(strlen(labx)+1); strcpy(__privtrans->labx,labx);(__privtrans->laby) = malloc(strlen(laby)+1); strcpy(__privtrans->laby,laby);(__privtrans->labtop) = malloc(strlen(labtop)+1); strcpy(__privtrans->labtop,labtop);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xmin;
__privtrans->pdls[1] = xmax;
__privtrans->pdls[2] = xjump;
__privtrans->pdls[3] = ymin;
__privtrans->pdls[4] = ymax;
__privtrans->pdls[5] = xlpos;
__privtrans->pdls[6] = ylpos;
__privtrans->pdls[7] = y_ascl;
__privtrans->pdls[8] = acc;
__privtrans->pdls[9] = colbox;
__privtrans->pdls[10] = collab;
__privtrans->pdls[11] = colline;
__privtrans->pdls[12] = styline;
__privtrans->pdls[13] = id;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  id->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = id_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgriddata(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *zg_SV;
  pdl  *x;
  pdl  *y;
  pdl  *z;
  pdl  *xg;
  pdl  *yg;
  pdl  *type;
  pdl  *data;
  pdl  *zg;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 8) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    xg = PDL->SvPDLV(ST(3));
    yg = PDL->SvPDLV(ST(4));
    type = PDL->SvPDLV(ST(5));
    data = PDL->SvPDLV(ST(6));
    zg = PDL->SvPDLV(ST(7));
  }
  else if (items == 7) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    z = PDL->SvPDLV(ST(2));
    xg = PDL->SvPDLV(ST(3));
    yg = PDL->SvPDLV(ST(4));
    type = PDL->SvPDLV(ST(5));
    data = PDL->SvPDLV(ST(6));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       zg_SV = sv_newmortal();
       zg = PDL->null();
       PDL->SetSV_PDL(zg_SV,zg);
       if (bless_stash) zg_SV = sv_bless(zg_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       zg_SV = POPs;
       PUTBACK;
       zg = PDL->SvPDLV(zg_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgriddata(x,y,z,xg,yg,type,data,zg) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgriddata_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgriddata_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0) || ((z->state & PDL_BADVAL) > 0) || ((xg->state & PDL_BADVAL) > 0) || ((yg->state & PDL_BADVAL) > 0) || ((type->state & PDL_BADVAL) > 0) || ((data->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype < z->datatype) {
		 	__privtrans->__datatype = z->datatype;
		    }
if(__privtrans->__datatype < xg->datatype) {
		 	__privtrans->__datatype = xg->datatype;
		    }
if(__privtrans->__datatype < yg->datatype) {
		 	__privtrans->__datatype = yg->datatype;
		    }
if(__privtrans->__datatype < data->datatype) {
		 	__privtrans->__datatype = data->datatype;
		    }
if(!((zg->state & PDL_NOMYDIMS) &&
		       zg->trans == NULL) && __privtrans->__datatype < zg->datatype) {
		 	__privtrans->__datatype = zg->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if(__privtrans->__datatype != z->datatype) {
	     z = PDL->get_convertedpdl(z,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xg->datatype) {
	     xg = PDL->get_convertedpdl(xg,__privtrans->__datatype);
	  }if(__privtrans->__datatype != yg->datatype) {
	     yg = PDL->get_convertedpdl(yg,__privtrans->__datatype);
	  }if(PDL_L != type->datatype) {
	     type = PDL->get_convertedpdl(type,PDL_L);
	  }if(__privtrans->__datatype != data->datatype) {
	     data = PDL->get_convertedpdl(data,__privtrans->__datatype);
	  }if( (zg->state & PDL_NOMYDIMS) && zg->trans == NULL ) {
	     zg->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != zg->datatype) {
	     zg = PDL->get_convertedpdl(zg,__privtrans->__datatype);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = z;
__privtrans->pdls[3] = xg;
__privtrans->pdls[4] = yg;
__privtrans->pdls[5] = type;
__privtrans->pdls[6] = data;
__privtrans->pdls[7] = zg;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  zg->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = zg_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plarc (x, y, a, b, angle1, angle2, rotate, fill)
  double x
  double y
  double a
  double b
  double angle1
  double angle2
  double rotate
  int fill
CODE:
  plarc (x, y, a, b, angle1, angle2, rotate, fill);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plstransform (xform)
 SV* xform
CODE:
  check_sub_pointer (xform_subroutine, "plstransform: xform must be either 0 or a subroutine pointer");
  if (SvTRUE(xform)) xform_subroutine = SvRV(xform);
  plstransform (SvTRUE(xform) ? xform_callback : NULL, NULL);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plslabelfunc (labelfunc)
 SV* labelfunc
CODE:
  check_sub_pointer (labelfunc_subroutine, "plslabelfunc: labelfunc must be either 0 or a subroutine pointer");
  if (SvTRUE(labelfunc)) labelfunc_subroutine = SvRV(labelfunc);
  plslabelfunc (SvTRUE(labelfunc) ? labelfunc_callback : NULL, NULL);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pllegend(opt, position, x, y, plot_width, bg_color, bb_color, bb_style, nrow, ncolumn, nlegend, opt_array_rv, text_offset, text_scale, text_spacing, text_justification, text_colors_rv, text_rv, box_colors_rv, box_patterns_rv, box_scales_rv, box_line_widths_rv, line_colors_rv, line_styles_rv, line_widths_rv, symbol_colors_rv, symbol_scales_rv, symbol_numbers_rv, symbols_rv)
  int     opt
  int     position
  double  x
  double  y
  double  plot_width
  int     bg_color
  int     bb_color
  int     bb_style
  int     nrow
  int     ncolumn
  int     nlegend
  SV*     opt_array_rv
  double  text_offset
  double  text_scale
  double  text_spacing
  double  text_justification
  SV*     text_colors_rv
  SV*     text_rv
  SV*     box_colors_rv
  SV*     box_patterns_rv
  SV*     box_scales_rv
  SV*     box_line_widths_rv
  SV*     line_colors_rv
  SV*     line_styles_rv
  SV*     line_widths_rv
  SV*     symbol_colors_rv
  SV*     symbol_scales_rv
  SV*     symbol_numbers_rv
  SV*     symbols_rv
PPCODE:
  int i;
  double p_legend_width;
  double p_legend_height;
  int opt_array[nlegend];
  int text_colors[nlegend];
  char *text[nlegend];
  int box_colors[nlegend];
  int box_patterns[nlegend];
  double box_scales[nlegend];
  int box_line_widths[nlegend];
  int line_colors[nlegend];
  int line_styles[nlegend];
  int line_widths[nlegend];
  int symbol_colors[nlegend];
  double symbol_scales[nlegend];
  int symbol_numbers[nlegend];
  char *symbols[nlegend];
  SV **elem;

  for (i = 0; i < nlegend; i++) {

    elem = av_fetch((AV *)SvRV(opt_array_rv),       i, 0); opt_array[i]       = (int)SvIV(*elem);
    elem = av_fetch((AV *)SvRV(text_colors_rv),     i, 0); text_colors[i]     = (int)SvIV(*elem);
    elem = av_fetch((AV *)SvRV(text_rv),            i, 0); text[i]            = (char *)SvPV_nolen(*elem);
    box_colors[i] = 0;
    if (SvROK(box_colors_rv)) {
      elem = av_fetch((AV *)SvRV(box_colors_rv),    i, 0); 
      if (elem && SvOK(*elem)) {
        box_colors[i] = (int)SvIV(*elem);
      }
    }
    box_patterns[i] = 0;
    if (SvROK(box_patterns_rv)) {
      elem = av_fetch((AV *)SvRV(box_patterns_rv),  i, 0); 
      if (elem && SvOK(*elem)) {
        box_patterns[i] = (int)SvIV(*elem);
      }
    }
    box_scales[i] = 0.0;
    if (SvROK(box_scales_rv)) {
      elem = av_fetch((AV *)SvRV(box_scales_rv),    i, 0); 
      if (elem && SvOK(*elem)) {
        box_scales[i] = (double)SvNV(*elem);
      }
    }
    box_line_widths[i] = 0;
    if (SvROK(box_line_widths_rv)) {
      elem = av_fetch((AV *)SvRV(box_line_widths_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        box_line_widths[i] = (int)SvIV(*elem);
      }
    }
    line_colors[i] = 0;
    if (SvROK(line_colors_rv)) {
      elem = av_fetch((AV *)SvRV(line_colors_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        line_colors[i] = (int)SvIV(*elem);
      }
    }

    line_styles[i] = 0;
    if (SvROK(line_styles_rv)) {
      elem = av_fetch((AV *)SvRV(line_styles_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        line_styles[i] = (int)SvIV(*elem);
      }
    }

    line_widths[i] = 0;
    if (SvROK(line_widths_rv)) {
      elem = av_fetch((AV *)SvRV(line_widths_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        line_widths[i] = (int)SvIV(*elem);
      }
    }

    symbol_colors[i] = 0;
    if (SvROK(symbol_colors_rv)) {
      elem = av_fetch((AV *)SvRV(symbol_colors_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        symbol_colors[i] = (int)SvIV(*elem);
      }
    }

    symbol_scales[i] = 0.0;
    if (SvROK(symbol_scales_rv)) {
      elem = av_fetch((AV *)SvRV(symbol_scales_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        symbol_scales[i] = (double)SvNV(*elem);
      }
    }

    symbol_numbers[i] = 0;
    if (SvROK(symbol_numbers_rv)) {
      elem = av_fetch((AV *)SvRV(symbol_numbers_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        symbol_numbers[i] = (int)SvIV(*elem);
      }
    }

    symbols[i] = "0";
    if (SvROK(symbols_rv)) {
      elem = av_fetch((AV *)SvRV(symbols_rv), i, 0); 
      if (elem && SvOK(*elem)) {
        symbols[i] = (char *)SvPV_nolen(*elem);
      }
    }
  }

  pllegend(&p_legend_width, &p_legend_height,
           opt, position, x, y, plot_width, bg_color, bb_color, bb_style, nrow, ncolumn, nlegend,
           opt_array,
           text_offset, text_scale, text_spacing, text_justification,
           text_colors, (const char **)text, box_colors, box_patterns, box_scales, box_line_widths,
           line_colors, line_styles, line_widths, symbol_colors, symbol_scales, symbol_numbers, (const char **)symbols);

  EXTEND (SP, 2);
  PUSHs (sv_2mortal (newSVnv (p_legend_width)));
  PUSHs (sv_2mortal (newSVnv (p_legend_height)));

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plspal0 (filename)
 char* filename
PPCODE:
  plspal0((const char *)filename);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

int
plspal1 (filename, interpolate)
 char* filename
 int   interpolate
PPCODE:
  plspal1((const char *)filename, (PLBOOL)interpolate);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plbtime (ctime)
  double ctime 
PPCODE:
  PLINT year;
  PLINT month;
  PLINT day;
  PLINT hour;
  PLINT min; 
  PLFLT sec;
  c_plbtime(&year, &month, &day, &hour, &min, &sec, ctime);
  EXTEND (SP, 6);
  PUSHs (sv_2mortal (newSViv (year)));
  PUSHs (sv_2mortal (newSViv (month)));
  PUSHs (sv_2mortal (newSViv (day)));
  PUSHs (sv_2mortal (newSViv (hour)));
  PUSHs (sv_2mortal (newSViv (min)));
  PUSHs (sv_2mortal (newSVnv (sec)));

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plconfigtime(scale, offset1, offset2, ccontrol, ifbtime_offset, year, month, day, hour, min, sec)
  double scale
  double offset1
  double offset2
  int ccontrol
  int ifbtime_offset
  int year
  int month
  int day
  int hour
  int min
  double sec
PPCODE:
  c_plconfigtime((PLFLT) scale, (PLFLT) offset1, (PLFLT) offset2, 
                 (PLINT) ccontrol, (PLBOOL) ifbtime_offset, (PLINT) year, 
                 (PLINT) month, (PLINT) day, (PLINT) hour, (PLINT) min, (PLFLT) sec);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plctime(year, month, day, hour, min, sec)
  int year
  int month
  int day
  int hour
  int min
  double sec
PPCODE:
  PLFLT ctime;
  c_plctime(year, month, day, hour, min, sec, &ctime);
  EXTEND (SP, 1);
  PUSHs (sv_2mortal (newSVnv (ctime)));

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
pltimefmt(fmt)
  char *fmt
PPCODE:
  c_pltimefmt((const char *)fmt);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plsesc (esc)
  SV* esc
PPCODE:
  char *esc_c;
  esc_c = (char *)SvPV_nolen(esc);
  c_plsesc((char)*esc_c);


MODULE = PDL::Graphics::PLplot PACKAGE = PDL


void
plvect(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *u;
  pdl  *v;
  pdl  *scale;
  SV *pltr;
  SV *pltr_data;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    u = PDL->SvPDLV(ST(0));
    v = PDL->SvPDLV(ST(1));
    scale = PDL->SvPDLV(ST(2));
    pltr = ST(3)
;
    pltr_data = ST(4)
;
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    u = PDL->SvPDLV(ST(0));
    v = PDL->SvPDLV(ST(1));
    scale = PDL->SvPDLV(ST(2));
    pltr = ST(3)
;
    pltr_data = ST(4)
;
  }
  else {
    croak ("Usage:  PDL::plvect(u,v,scale,pltr,pltr_data) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plvect_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plvect_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((u->state & PDL_BADVAL) > 0) || ((v->state & PDL_BADVAL) > 0) || ((scale->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < u->datatype) {
		 	__privtrans->__datatype = u->datatype;
		    }
if(__privtrans->__datatype < v->datatype) {
		 	__privtrans->__datatype = v->datatype;
		    }
if(__privtrans->__datatype < scale->datatype) {
		 	__privtrans->__datatype = scale->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != u->datatype) {
	     u = PDL->get_convertedpdl(u,__privtrans->__datatype);
	  }if(__privtrans->__datatype != v->datatype) {
	     v = PDL->get_convertedpdl(v,__privtrans->__datatype);
	  }if(__privtrans->__datatype != scale->datatype) {
	     scale = PDL->get_convertedpdl(scale,__privtrans->__datatype);
	  }{(__privtrans->pltr) = newSVsv(pltr);(__privtrans->pltr_data) = newSVsv(pltr_data);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = u;
__privtrans->pdls[1] = v;
__privtrans->pdls[2] = scale;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsvect(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *arrowx;
  pdl  *arrowy;
  pdl  *fill;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    arrowx = PDL->SvPDLV(ST(0));
    arrowy = PDL->SvPDLV(ST(1));
    fill = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    arrowx = PDL->SvPDLV(ST(0));
    arrowy = PDL->SvPDLV(ST(1));
    fill = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plsvect(arrowx,arrowy,fill) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsvect_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsvect_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((arrowx->state & PDL_BADVAL) > 0) || ((arrowy->state & PDL_BADVAL) > 0) || ((fill->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < arrowx->datatype) {
		 	__privtrans->__datatype = arrowx->datatype;
		    }
if(__privtrans->__datatype < arrowy->datatype) {
		 	__privtrans->__datatype = arrowy->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != arrowx->datatype) {
	     arrowx = PDL->get_convertedpdl(arrowx,__privtrans->__datatype);
	  }if(__privtrans->__datatype != arrowy->datatype) {
	     arrowy = PDL->get_convertedpdl(arrowy,__privtrans->__datatype);
	  }if(PDL_L != fill->datatype) {
	     fill = PDL->get_convertedpdl(fill,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = arrowx;
__privtrans->pdls[1] = arrowy;
__privtrans->pdls[2] = fill;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plhlsrgb(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_r_SV;
  SV *p_g_SV;
  SV *p_b_SV;
  pdl  *h;
  pdl  *l;
  pdl  *s;
  pdl  *p_r;
  pdl  *p_g;
  pdl  *p_b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    h = PDL->SvPDLV(ST(0));
    l = PDL->SvPDLV(ST(1));
    s = PDL->SvPDLV(ST(2));
    p_r = PDL->SvPDLV(ST(3));
    p_g = PDL->SvPDLV(ST(4));
    p_b = PDL->SvPDLV(ST(5));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    h = PDL->SvPDLV(ST(0));
    l = PDL->SvPDLV(ST(1));
    s = PDL->SvPDLV(ST(2));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_r_SV = sv_newmortal();
       p_r = PDL->null();
       PDL->SetSV_PDL(p_r_SV,p_r);
       if (bless_stash) p_r_SV = sv_bless(p_r_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_r_SV = POPs;
       PUTBACK;
       p_r = PDL->SvPDLV(p_r_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_g_SV = sv_newmortal();
       p_g = PDL->null();
       PDL->SetSV_PDL(p_g_SV,p_g);
       if (bless_stash) p_g_SV = sv_bless(p_g_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_g_SV = POPs;
       PUTBACK;
       p_g = PDL->SvPDLV(p_g_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_b_SV = sv_newmortal();
       p_b = PDL->null();
       PDL->SetSV_PDL(p_b_SV,p_b);
       if (bless_stash) p_b_SV = sv_bless(p_b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_b_SV = POPs;
       PUTBACK;
       p_b = PDL->SvPDLV(p_b_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plhlsrgb(h,l,s,p_r,p_g,p_b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plhlsrgb_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plhlsrgb_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((h->state & PDL_BADVAL) > 0) || ((l->state & PDL_BADVAL) > 0) || ((s->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != h->datatype) {
	     h = PDL->get_convertedpdl(h,PDL_D);
	  }if(PDL_D != l->datatype) {
	     l = PDL->get_convertedpdl(l,PDL_D);
	  }if(PDL_D != s->datatype) {
	     s = PDL->get_convertedpdl(s,PDL_D);
	  }if( (p_r->state & PDL_NOMYDIMS) && p_r->trans == NULL ) {
	     p_r->datatype = PDL_D;
	  } else if(PDL_D != p_r->datatype) {
	     p_r = PDL->get_convertedpdl(p_r,PDL_D);
	  }if( (p_g->state & PDL_NOMYDIMS) && p_g->trans == NULL ) {
	     p_g->datatype = PDL_D;
	  } else if(PDL_D != p_g->datatype) {
	     p_g = PDL->get_convertedpdl(p_g,PDL_D);
	  }if( (p_b->state & PDL_NOMYDIMS) && p_b->trans == NULL ) {
	     p_b->datatype = PDL_D;
	  } else if(PDL_D != p_b->datatype) {
	     p_b = PDL->get_convertedpdl(p_b,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = h;
__privtrans->pdls[1] = l;
__privtrans->pdls[2] = s;
__privtrans->pdls[3] = p_r;
__privtrans->pdls[4] = p_g;
__privtrans->pdls[5] = p_b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_r->state |= PDL_BADVAL;
  p_g->state |= PDL_BADVAL;
  p_b->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_r_SV;
  ST(1) = p_g_SV;
  ST(2) = p_b_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgcol0(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *r_SV;
  SV *g_SV;
  SV *b_SV;
  pdl  *icolzero;
  pdl  *r;
  pdl  *g;
  pdl  *b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
    r = PDL->SvPDLV(ST(1));
    g = PDL->SvPDLV(ST(2));
    b = PDL->SvPDLV(ST(3));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    icolzero = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       r_SV = sv_newmortal();
       r = PDL->null();
       PDL->SetSV_PDL(r_SV,r);
       if (bless_stash) r_SV = sv_bless(r_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       r_SV = POPs;
       PUTBACK;
       r = PDL->SvPDLV(r_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       g_SV = sv_newmortal();
       g = PDL->null();
       PDL->SetSV_PDL(g_SV,g);
       if (bless_stash) g_SV = sv_bless(g_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       g_SV = POPs;
       PUTBACK;
       g = PDL->SvPDLV(g_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       b_SV = sv_newmortal();
       b = PDL->null();
       PDL->SetSV_PDL(b_SV,b);
       if (bless_stash) b_SV = sv_bless(b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       b_SV = POPs;
       PUTBACK;
       b = PDL->SvPDLV(b_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgcol0(icolzero,r,g,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgcol0_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgcol0_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((icolzero->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != icolzero->datatype) {
	     icolzero = PDL->get_convertedpdl(icolzero,PDL_L);
	  }if( (r->state & PDL_NOMYDIMS) && r->trans == NULL ) {
	     r->datatype = PDL_L;
	  } else if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if( (g->state & PDL_NOMYDIMS) && g->trans == NULL ) {
	     g->datatype = PDL_L;
	  } else if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = PDL_L;
	  } else if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = icolzero;
__privtrans->pdls[1] = r;
__privtrans->pdls[2] = g;
__privtrans->pdls[3] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  r->state |= PDL_BADVAL;
  g->state |= PDL_BADVAL;
  b->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = r_SV;
  ST(1) = g_SV;
  ST(2) = b_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgcolbg(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *r_SV;
  SV *g_SV;
  SV *b_SV;
  pdl  *r;
  pdl  *g;
  pdl  *b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       r_SV = sv_newmortal();
       r = PDL->null();
       PDL->SetSV_PDL(r_SV,r);
       if (bless_stash) r_SV = sv_bless(r_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       r_SV = POPs;
       PUTBACK;
       r = PDL->SvPDLV(r_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       g_SV = sv_newmortal();
       g = PDL->null();
       PDL->SetSV_PDL(g_SV,g);
       if (bless_stash) g_SV = sv_bless(g_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       g_SV = POPs;
       PUTBACK;
       g = PDL->SvPDLV(g_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       b_SV = sv_newmortal();
       b = PDL->null();
       PDL->SetSV_PDL(b_SV,b);
       if (bless_stash) b_SV = sv_bless(b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       b_SV = POPs;
       PUTBACK;
       b = PDL->SvPDLV(b_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgcolbg(r,g,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgcolbg_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgcolbg_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (r->state & PDL_NOMYDIMS) && r->trans == NULL ) {
	     r->datatype = PDL_L;
	  } else if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if( (g->state & PDL_NOMYDIMS) && g->trans == NULL ) {
	     g->datatype = PDL_L;
	  } else if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = PDL_L;
	  } else if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  r->state |= PDL_BADVAL;
  g->state |= PDL_BADVAL;
  b->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = r_SV;
  ST(1) = g_SV;
  ST(2) = b_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap0(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *r;
  pdl  *g;
  pdl  *b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plscmap0(r,g,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap0_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap0_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap1(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *r;
  pdl  *g;
  pdl  *b;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plscmap1(r,g,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap1_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap1_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgcol0a(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *r_SV;
  SV *g_SV;
  SV *b_SV;
  SV *a_SV;
  pdl  *icolzero;
  pdl  *r;
  pdl  *g;
  pdl  *b;
  pdl  *a;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    icolzero = PDL->SvPDLV(ST(0));
    r = PDL->SvPDLV(ST(1));
    g = PDL->SvPDLV(ST(2));
    b = PDL->SvPDLV(ST(3));
    a = PDL->SvPDLV(ST(4));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    icolzero = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       r_SV = sv_newmortal();
       r = PDL->null();
       PDL->SetSV_PDL(r_SV,r);
       if (bless_stash) r_SV = sv_bless(r_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       r_SV = POPs;
       PUTBACK;
       r = PDL->SvPDLV(r_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       g_SV = sv_newmortal();
       g = PDL->null();
       PDL->SetSV_PDL(g_SV,g);
       if (bless_stash) g_SV = sv_bless(g_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       g_SV = POPs;
       PUTBACK;
       g = PDL->SvPDLV(g_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       b_SV = sv_newmortal();
       b = PDL->null();
       PDL->SetSV_PDL(b_SV,b);
       if (bless_stash) b_SV = sv_bless(b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       b_SV = POPs;
       PUTBACK;
       b = PDL->SvPDLV(b_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       a_SV = sv_newmortal();
       a = PDL->null();
       PDL->SetSV_PDL(a_SV,a);
       if (bless_stash) a_SV = sv_bless(a_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       a_SV = POPs;
       PUTBACK;
       a = PDL->SvPDLV(a_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgcol0a(icolzero,r,g,b,a) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgcol0a_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgcol0a_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((icolzero->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != icolzero->datatype) {
	     icolzero = PDL->get_convertedpdl(icolzero,PDL_L);
	  }if( (r->state & PDL_NOMYDIMS) && r->trans == NULL ) {
	     r->datatype = PDL_L;
	  } else if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if( (g->state & PDL_NOMYDIMS) && g->trans == NULL ) {
	     g->datatype = PDL_L;
	  } else if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = PDL_L;
	  } else if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }if( (a->state & PDL_NOMYDIMS) && a->trans == NULL ) {
	     a->datatype = PDL_D;
	  } else if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = icolzero;
__privtrans->pdls[1] = r;
__privtrans->pdls[2] = g;
__privtrans->pdls[3] = b;
__privtrans->pdls[4] = a;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  r->state |= PDL_BADVAL;
  g->state |= PDL_BADVAL;
  b->state |= PDL_BADVAL;
  a->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = r_SV;
  ST(1) = g_SV;
  ST(2) = b_SV;
  ST(3) = a_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgcolbga(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *r_SV;
  SV *g_SV;
  SV *b_SV;
  SV *a_SV;
  pdl  *r;
  pdl  *g;
  pdl  *b;
  pdl  *a;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 4;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       r_SV = sv_newmortal();
       r = PDL->null();
       PDL->SetSV_PDL(r_SV,r);
       if (bless_stash) r_SV = sv_bless(r_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       r_SV = POPs;
       PUTBACK;
       r = PDL->SvPDLV(r_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       g_SV = sv_newmortal();
       g = PDL->null();
       PDL->SetSV_PDL(g_SV,g);
       if (bless_stash) g_SV = sv_bless(g_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       g_SV = POPs;
       PUTBACK;
       g = PDL->SvPDLV(g_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       b_SV = sv_newmortal();
       b = PDL->null();
       PDL->SetSV_PDL(b_SV,b);
       if (bless_stash) b_SV = sv_bless(b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       b_SV = POPs;
       PUTBACK;
       b = PDL->SvPDLV(b_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       a_SV = sv_newmortal();
       a = PDL->null();
       PDL->SetSV_PDL(a_SV,a);
       if (bless_stash) a_SV = sv_bless(a_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       a_SV = POPs;
       PUTBACK;
       a = PDL->SvPDLV(a_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgcolbga(r,g,b,a) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgcolbga_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgcolbga_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (r->state & PDL_NOMYDIMS) && r->trans == NULL ) {
	     r->datatype = PDL_L;
	  } else if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if( (g->state & PDL_NOMYDIMS) && g->trans == NULL ) {
	     g->datatype = PDL_L;
	  } else if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = PDL_L;
	  } else if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }if( (a->state & PDL_NOMYDIMS) && a->trans == NULL ) {
	     a->datatype = PDL_D;
	  } else if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
__privtrans->pdls[3] = a;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  r->state |= PDL_BADVAL;
  g->state |= PDL_BADVAL;
  b->state |= PDL_BADVAL;
  a->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = r_SV;
  ST(1) = g_SV;
  ST(2) = b_SV;
  ST(3) = a_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap0a(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *r;
  pdl  *g;
  pdl  *b;
  pdl  *a;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plscmap0a(r,g,b,a) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap0a_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap0a_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0) || ((a->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
__privtrans->pdls[3] = a;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap1a(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *r;
  pdl  *g;
  pdl  *b;
  pdl  *a;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    r = PDL->SvPDLV(ST(0));
    g = PDL->SvPDLV(ST(1));
    b = PDL->SvPDLV(ST(2));
    a = PDL->SvPDLV(ST(3));
  }
  else {
    croak ("Usage:  PDL::plscmap1a(r,g,b,a) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap1a_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap1a_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((r->state & PDL_BADVAL) > 0) || ((g->state & PDL_BADVAL) > 0) || ((b->state & PDL_BADVAL) > 0) || ((a->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != r->datatype) {
	     r = PDL->get_convertedpdl(r,PDL_L);
	  }if(PDL_L != g->datatype) {
	     g = PDL->get_convertedpdl(g,PDL_L);
	  }if(PDL_L != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_L);
	  }if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = r;
__privtrans->pdls[1] = g;
__privtrans->pdls[2] = b;
__privtrans->pdls[3] = a;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plscmap1la(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *itype;
  pdl  *isty;
  pdl  *coord1;
  pdl  *coord2;
  pdl  *coord3;
  pdl  *coord4;
  pdl  *rev;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    itype = PDL->SvPDLV(ST(0));
    isty = PDL->SvPDLV(ST(1));
    coord1 = PDL->SvPDLV(ST(2));
    coord2 = PDL->SvPDLV(ST(3));
    coord3 = PDL->SvPDLV(ST(4));
    coord4 = PDL->SvPDLV(ST(5));
    rev = PDL->SvPDLV(ST(6));
  }
  else if (items == 7) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    itype = PDL->SvPDLV(ST(0));
    isty = PDL->SvPDLV(ST(1));
    coord1 = PDL->SvPDLV(ST(2));
    coord2 = PDL->SvPDLV(ST(3));
    coord3 = PDL->SvPDLV(ST(4));
    coord4 = PDL->SvPDLV(ST(5));
    rev = PDL->SvPDLV(ST(6));
  }
  else {
    croak ("Usage:  PDL::plscmap1la(itype,isty,coord1,coord2,coord3,coord4,rev) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plscmap1la_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plscmap1la_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((itype->state & PDL_BADVAL) > 0) || ((isty->state & PDL_BADVAL) > 0) || ((coord1->state & PDL_BADVAL) > 0) || ((coord2->state & PDL_BADVAL) > 0) || ((coord3->state & PDL_BADVAL) > 0) || ((coord4->state & PDL_BADVAL) > 0) || ((rev->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < isty->datatype) {
		 	__privtrans->__datatype = isty->datatype;
		    }
if(__privtrans->__datatype < coord1->datatype) {
		 	__privtrans->__datatype = coord1->datatype;
		    }
if(__privtrans->__datatype < coord2->datatype) {
		 	__privtrans->__datatype = coord2->datatype;
		    }
if(__privtrans->__datatype < coord3->datatype) {
		 	__privtrans->__datatype = coord3->datatype;
		    }
if(__privtrans->__datatype < coord4->datatype) {
		 	__privtrans->__datatype = coord4->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != itype->datatype) {
	     itype = PDL->get_convertedpdl(itype,PDL_L);
	  }if(__privtrans->__datatype != isty->datatype) {
	     isty = PDL->get_convertedpdl(isty,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord1->datatype) {
	     coord1 = PDL->get_convertedpdl(coord1,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord2->datatype) {
	     coord2 = PDL->get_convertedpdl(coord2,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord3->datatype) {
	     coord3 = PDL->get_convertedpdl(coord3,__privtrans->__datatype);
	  }if(__privtrans->__datatype != coord4->datatype) {
	     coord4 = PDL->get_convertedpdl(coord4,__privtrans->__datatype);
	  }if(PDL_L != rev->datatype) {
	     rev = PDL->get_convertedpdl(rev,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = itype;
__privtrans->pdls[1] = isty;
__privtrans->pdls[2] = coord1;
__privtrans->pdls[3] = coord2;
__privtrans->pdls[4] = coord3;
__privtrans->pdls[5] = coord4;
__privtrans->pdls[6] = rev;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plgfont(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *p_family_SV;
  SV *p_style_SV;
  SV *p_weight_SV;
  pdl  *p_family;
  pdl  *p_style;
  pdl  *p_weight;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    p_family = PDL->SvPDLV(ST(0));
    p_style = PDL->SvPDLV(ST(1));
    p_weight = PDL->SvPDLV(ST(2));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_family_SV = sv_newmortal();
       p_family = PDL->null();
       PDL->SetSV_PDL(p_family_SV,p_family);
       if (bless_stash) p_family_SV = sv_bless(p_family_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_family_SV = POPs;
       PUTBACK;
       p_family = PDL->SvPDLV(p_family_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_style_SV = sv_newmortal();
       p_style = PDL->null();
       PDL->SetSV_PDL(p_style_SV,p_style);
       if (bless_stash) p_style_SV = sv_bless(p_style_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_style_SV = POPs;
       PUTBACK;
       p_style = PDL->SvPDLV(p_style_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       p_weight_SV = sv_newmortal();
       p_weight = PDL->null();
       PDL->SetSV_PDL(p_weight_SV,p_weight);
       if (bless_stash) p_weight_SV = sv_bless(p_weight_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       p_weight_SV = POPs;
       PUTBACK;
       p_weight = PDL->SvPDLV(p_weight_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plgfont(p_family,p_style,p_weight) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plgfont_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plgfont_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (p_family->state & PDL_NOMYDIMS) && p_family->trans == NULL ) {
	     p_family->datatype = PDL_L;
	  } else if(PDL_L != p_family->datatype) {
	     p_family = PDL->get_convertedpdl(p_family,PDL_L);
	  }if( (p_style->state & PDL_NOMYDIMS) && p_style->trans == NULL ) {
	     p_style->datatype = PDL_L;
	  } else if(PDL_L != p_style->datatype) {
	     p_style = PDL->get_convertedpdl(p_style,PDL_L);
	  }if( (p_weight->state & PDL_NOMYDIMS) && p_weight->trans == NULL ) {
	     p_weight->datatype = PDL_L;
	  } else if(PDL_L != p_weight->datatype) {
	     p_weight = PDL->get_convertedpdl(p_weight,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = p_family;
__privtrans->pdls[1] = p_style;
__privtrans->pdls[2] = p_weight;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  p_family->state |= PDL_BADVAL;
  p_style->state |= PDL_BADVAL;
  p_weight->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = p_family_SV;
  ST(1) = p_style_SV;
  ST(2) = p_weight_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plsfont(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *family;
  pdl  *style;
  pdl  *weight;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    family = PDL->SvPDLV(ST(0));
    style = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    family = PDL->SvPDLV(ST(0));
    style = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
  }
  else {
    croak ("Usage:  PDL::plsfont(family,style,weight) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plsfont_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plsfont_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((family->state & PDL_BADVAL) > 0) || ((style->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != family->datatype) {
	     family = PDL->get_convertedpdl(family,PDL_L);
	  }if(PDL_L != style->datatype) {
	     style = PDL->get_convertedpdl(style,PDL_L);
	  }if(PDL_L != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = family;
__privtrans->pdls[1] = style;
__privtrans->pdls[2] = weight;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
plcalc_world(...)
 PREINIT:
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *wx_SV;
  SV *wy_SV;
  SV *window_SV;
  pdl  *rx;
  pdl  *ry;
  pdl  *wx;
  pdl  *wy;
  pdl  *window;
 PPCODE:
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    rx = PDL->SvPDLV(ST(0));
    ry = PDL->SvPDLV(ST(1));
    wx = PDL->SvPDLV(ST(2));
    wy = PDL->SvPDLV(ST(3));
    window = PDL->SvPDLV(ST(4));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    rx = PDL->SvPDLV(ST(0));
    ry = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       wx_SV = sv_newmortal();
       wx = PDL->null();
       PDL->SetSV_PDL(wx_SV,wx);
       if (bless_stash) wx_SV = sv_bless(wx_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       wx_SV = POPs;
       PUTBACK;
       wx = PDL->SvPDLV(wx_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       wy_SV = sv_newmortal();
       wy = PDL->null();
       PDL->SetSV_PDL(wy_SV,wy);
       if (bless_stash) wy_SV = sv_bless(wy_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       wy_SV = POPs;
       PUTBACK;
       wy = PDL->SvPDLV(wy_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       window_SV = sv_newmortal();
       window = PDL->null();
       PDL->SetSV_PDL(window_SV,window);
       if (bless_stash) window_SV = sv_bless(window_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       window_SV = POPs;
       PUTBACK;
       window = PDL->SvPDLV(window_SV);
    }
  }
  else {
    croak ("Usage:  PDL::plcalc_world(rx,ry,wx,wy,window) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_plcalc_world_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_plcalc_world_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((rx->state & PDL_BADVAL) > 0) || ((ry->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != rx->datatype) {
	     rx = PDL->get_convertedpdl(rx,PDL_D);
	  }if(PDL_D != ry->datatype) {
	     ry = PDL->get_convertedpdl(ry,PDL_D);
	  }if( (wx->state & PDL_NOMYDIMS) && wx->trans == NULL ) {
	     wx->datatype = PDL_D;
	  } else if(PDL_D != wx->datatype) {
	     wx = PDL->get_convertedpdl(wx,PDL_D);
	  }if( (wy->state & PDL_NOMYDIMS) && wy->trans == NULL ) {
	     wy->datatype = PDL_D;
	  } else if(PDL_D != wy->datatype) {
	     wy = PDL->get_convertedpdl(wy,PDL_D);
	  }if( (window->state & PDL_NOMYDIMS) && window->trans == NULL ) {
	     window->datatype = PDL_L;
	  } else if(PDL_L != window->datatype) {
	     window = PDL->get_convertedpdl(window,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = rx;
__privtrans->pdls[1] = ry;
__privtrans->pdls[2] = wx;
__privtrans->pdls[3] = wy;
__privtrans->pdls[4] = window;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  wx->state |= PDL_BADVAL;
  wy->state |= PDL_BADVAL;
  window->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = wx_SV;
  ST(1) = wy_SV;
  ST(2) = window_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

unsigned int plgfci ()
    CODE:
    {
	unsigned int	RETVAL;
        unsigned int    fci;
	c_plgfci(&fci);
        RETVAL = fci;

	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL


MODULE = PDL::Graphics::PLplot PACKAGE = PDL::Graphics::PLplot

void
plsfci(fci)
        unsigned int fci
    CODE:
        c_plsfci(fci);

MODULE = PDL::Graphics::PLplot PACKAGE = PDL



BOOT:

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")
   perl_require_pv("PDL::Core");
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  PDL_COMMENT("SV* value")
#ifndef aTHX_
#define aTHX_
#endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "Can't load PDL::Core module");
   PDL = INT2PTR(Core*, SvIV( CoreSV ));  PDL_COMMENT("Core* value")
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] PDL::Graphics::PLplot needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);
                                                                                                                                         
